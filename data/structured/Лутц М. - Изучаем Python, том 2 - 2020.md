


5-е издание Изучаем Python Том 2 FIFTH EDITION Learning Python Mark Lutz Beijing • Boston • Farnham • Sebastopol «Tokyo O’REILLY 5-е издание Изучаем Python Том 2 Марк Лутц ^АЦДЛЕКШика Москва • Санкт-Петербург

2020 ББК 32.973.26-018.2.75 Л86 УДК 681.3.07 ООО “Диалектика"’ Зав. редакцией С.Н. Тригуб Перевод с английского и редакция Ю.Н. Артеменко По общим вопросам обращайтесь в издательство “Диалектика” по адресу:

info@dialektika.com, http://www.dialektika.com Лутц, Марк. Л86 Изучаем Python, том 2, 5-е изд. : Пер. с англ. — СПб. : ООО “Диалектика”, 2020. — 720 с. : ил. — Парал. тит. англ. ISBN 978-5-907144-53-8 (рус., том 2)

ISBN 978-5-907144-51-4 (рус., многотом.) ББК 32.973.26-018.2.75 Все названия программных продуктов являются зарегистрированными торговыми марками соответствую­ щих фирм. Никакая часть настоящего издания ни в каких целях не может быть воспроизведена в какой бы то ни было

форме и какими бы то ни было средствами, будь то электронные или механические, включая фотокопирование и запись на магнитный носитель, если на это нет письменного разрешения издательства O’Reilly&Associates.

Authorized Russian translation of the English edition of Learning Python, 5th Edition (ISBN 978-1-449-35573-9) © 2013 by Mark Lutz. This translation is published and sold by permission of O’Reilly Media, Inc., which owns or controls all rights to

publish and sell the same. All rights reserved. No pail of this work may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording, or by any information storage or retrieval system, without the prior

written permission of the copyright owner and the Publisher. Научно-популярное издание Марк Лутц Изучаем Python, том 2 5-е издание Подписано в печать 25.11.2019. Формат 70x100/16. Гарнитура Times. Усл. печ. л. 58,05. Уч.-изд. л. 47,3.

Тираж 1000 экз. Заказ № 10632. Отпечатано в АО “Первая Образцовая типография” Филиал “Чеховский Печатный Двор” 142300, Московская область, г. Чехов, ул. Полиграфистов, д. 1 Сайт: www.chpd.ru, E-mail: sales@chpd.ru, тел. 8 (499) 270-73-59

ООО “Диалектика”, 195027, Санкт-Петербург, Магнитогорская ул., д. 30, лит. А, пом. 848 ISBN 978-5-907144-53-8 (рус., том 2) ISBN 978-5-907144-51-4 (рус., многотом.) ISBN 978-1-449-35573-9 (англ.) © 2020, ООО “Диалектика”

© 2013 by Mark Lutz Оглавление Предисловие 17 Часть VI. Классы и объектно-ориентированное программирование 10 ГЛАВА 26. Объектно-ориентированное программирование: общая картина 20 Г Л А В А 27. Основы написания классов

34 Г Л А В А 28. Более реалистичный пример 54 Г Л А В А 29. Детали реализации классов 96 Г Л А В А 30. Перегрузка операций 123 Г Л А В А 31. Проектирование с использованием классов 169 ГЛАВА 32. Расширенные возможности классов

216 Часть VII. Исключения и инструменты 315 ГЛАВА 33. Основы исключений 316 Г Л А В А 34. Детали обработки исключений 327 Г Л А В А 35. Объекты исключений 357 Г Л А В А 36. Проектирование с использованием исключений

375 Часть VIII. Более сложные темы 399 Г Л А В А 37. Unicode и байтовые строки 400 Г Л А В А 38. Управляемые атрибуты 455 Г Л А В А 39. Декораторы 504 Г Л А В А 40. Метаклассы 590 Г Л А В А 41. Все хорошее когда-нибудь заканчивается

644 Часть IX. Приложения 653 Приложение А. Установка и конфигурирование 654 Приложение Б. Запускающий модуль Windows для Python 668 Приложение В. Изменения в Python и настоящая книга 677 Приложение Г. Решения упражнений, приводимых в конце частей

692 Предметный указатель 709 Содержание Предисловие 17 Часть VI. Классы и объектно-ориентированное программирование 19 Г Л А В А 26. Объектно-ориентированное программирование: общая картина 20 Для чего используются классы?

21 Объектно-ориентированное программирование с высоты птичьего полета 22 Поиск в иерархии наследования 23 Классы и экземпляры 25 Вызовы методов 25 Создание деревьев классов 26 Перегрузка операций 28 Объектно-ориентированное программирование — это многократное

использование кода 29 Резюме 32 Проверьте свои знания: контрольные вопросы 32 Проверьте свои знания: ответы 33 Г Л А В А 27. Основы написания классов 34 Классы генерируют множество объектов экземпляров

34 Объекты классов обеспечивают стандартное поведение 35 Объекты экземпляров являются конкретными элементами 35 Первый пример 36 Классы настраиваются через наследование 38 Второй пример 39 Классы являются атрибутами в модулях

41 Классы могут перехватывать операции Python 42 Третий пример 43 Для чего используется перегрузка операций? 45 Простейший в мире класс Python 46 Снова о записях: классы или словари 49 Резюме 51 Проверьте свои знания: контрольные вопросы

51 Проверьте свои знания: ответы 52 Г Л А В А 28. Более реалистичный пример 54 Шаг 1: создание экземпляров 55 Написание кода конструкторов 55 Тестирование в ходе дела 56 Использование кода двумя способами

58 Шаг 2: добавление методов, реализующих поведение 59 Написание кода методов 61 Шаг 3: перегрузка операций 63 Реализация отображения 63 Шаг 4: настройка поведения за счет создания подклассов 65 Написание кода подклассов

66 Расширение методов: плохой способ 66 Расширение методов: хороший способ 67 Полиморфизм в действии 69 Наследование, настройка и расширение 70 Объектно-ориентированное программирование: основная идея 71

Шаг 5: настройка конструкторов 72 Объектно-ориентированное программирование проще, чем может казаться 73 Другие способы комбинирования классов 74 Шаг 6: использование инструментов интроспекции 77 Специальные атрибуты класса

78 Обобщенный инструмент отображения 79 Атрибуты экземпляра или атрибуты класса 81 Размышления относительно имен в классах инструментов 82 Финальная форма классов 83 Шаг 7 (последний): сохранение объектов в базе данных

84 Модули pickle, dbm и shelve 85 Сохранение объектов в базе данных shelve 86 Исследование хранилища shelve в интерактивной подсказке 87 Обновление объектов в хранилище shelve 89 Указания на будущее 91

Резюме 93 Проверьте свои знания: контрольные вопросы 93 Проверьте свои знания: ответы 94 Г Л А В А 29. Детали реализации классов 96 Оператор class 96 Общая форма 97 Пример 97 Методы 99 Пример метода 100

Вызов конструкторов суперклассов 101 Другие возможности вызова методов 101 Наследование 102 Построение дерева атрибутов 102 Специализации унаследованных методов 104 Методики связывания классов 104 Абстрактные суперклассы

106 Пространства имен: заключение 108 Простые имена: глобальные, если не выполнено их присваивание 109 Имена атрибутов: пространства имен объектов 109 “Дзен” пространств имен: присваивания классифицируют имена

110 Вложенные классы: снова о правиле областей видимости LEGB 112 Словари пространств имен: обзор 114 Связи между пространствами имен: инструмент подъема по дереву 117 Снова о строках документации 119 Классы или модули

120 Резюме 121 Проверьте свои знания: контрольные вопросы 121 Проверьте свои знания: ответы 122 Г Л А В А 30. Перегрузка операций 123 Основы 123 Конструкторы и выражения:__ in it__ и__ sub__ 124 Распространенные методы перегрузки операций

124 Индексирование и нарезание:__ getitem__ и__ setitem__ 127 Перехват срезов 127 Нарезание и индексирование в Python 2.Х 129 Но метод__ index__ в Python З.Х не имеет отношения к индексированию! 130 Итерация по индексам:__ getitem__

130 Итерируемые объекты:__ iter__ и___next__ 131 Итерируемые объекты, определяемые пользователем 132 Множество итераторов в одном объекте 135 Альтернативная реализация: iter плюс yield 138 Членство: contains , iter и getitem

142 Доступ к атрибутам:__ getattr__ и__ setattr__ 145 Ссылка на атрибуты 146 Присваивание и удаление атрибутов 147 Другие инструменты управления атрибутами 148 Эмуляция защиты атрибутов экземпляра: часть 1

149 Строковое представление: г ер г и str 150 Для чего используются два метода отображения? 151 Замечания по использованию отображения 152 Использование с правой стороны и на месте:__ г add__ и__ iadd__

153 Правостороннее сложение 154 Сложение на месте 157 Выражения вызовов:__ cal 1__ 158 Функциональные интерфейсы и код, основанный на обратных вызовах 160 Сравнения:__ It__ ,__ gt__ и другие 162 Метод__ стр__ в Python 2.Х

163 Булевские проверки:__ bool__ и_ 1еп___ 163 Булевские методы в Python 2.Х 164 Уничтожение объектов:__ del__ 166 Замечания относительно использования деструкторов 166 Резюме 167 Проверьте свои знания: контрольные вопросы

168 Проверьте свои знания: ответы 168 Г Л А В А 31. Проектирование с использованием классов 169 Python и объектно-ориентированное программирование 169 Полиморфизм означает интерфейсы, а не сигнатуры вызовов

170 Объектно-ориентированное программирование и наследование: отношения “является” 171 Объектно-ориентированное программирование и композиция: отношения “имеет” 173 Снова об обработчиках потоков данных

174 Объектно-ориентированное программирование и делегирование: промежуточные объекты-оболочки 178 Псевдозакрытые атрибуты классов 180 Обзор корректировки имен 180 Для чего используются псевдозакрытые атрибуты?

181 Методы являются объектами: связанные или несвязанные методы 183 Несвязанные методы являются функциями в Python З.Х 185 Связанные методы и другие вызываемые объекты 187 Классы являются объектами: обобщенные фабрики объектов

190 Для чего используются фабрики? 191 Множественное наследование: “подмешиваемые” классы 192 Реализация подмешиваемых классов отображения 193 Другие темы, связанные с проектированием 214 Резюме 214 Проверьте свои знания: контрольные вопросы

215 Проверьте свои знания: ответы 215 Г Л А В А 32. Расширенные возможности классов 216 Расширение встроенных типов 217 Расширение типов путем внедрения 217 Расширение типов путем создания подклассов 218

Модель классов “нового стиля” 220 Что нового в новом стиле? 221 Изменения в классах нового стиля 222 Процедура извлечения атрибутов для встроенных операций пропускает экземпляры 224 Изменения модели типов

229 Все классы являются производными от ob j ect 232 Изменение ромбовидного наследования 234 Дополнительные сведения о MRO: порядок распознавания методов 238 Пример: отображение атрибутов на источники наследования

241 Расширения в классах нового стиля 246 Слоты: объявления атрибутов 247 Свойства: средства доступа к атрибутам 256 Метод__ getattribute__ и дескрипторы: инструменты для работы с атрибутами 259 Другие изменения и расширения классов

260 Статические методы и методы классов 261 Для чего используются специальные методы? 261 Статические методы в Python 2.Х и З.Х 262 Альтернативы для статических методов 264 Использование статических методов и методов класса

265 Подсчет экземпляров с помощью статических методов 267 Подсчет экземпляров с помощью методов классов 268 Декораторы и метаклассы: часть 1 271 Основы декораторов функций 272 Первый взгляд на декораторы функций, определяемые пользователем

273 Первый взгляд на декораторы классов и метаклассы 275 Дополнительные сведения 277 Встроенная функция super: для лучшего или для худшего? 277 Продолжительные дебаты относительно super 277 Традиционная форма вызова методов суперкласса:

переносимая, универсальная 279 Базовое использование встроенной функции super и связанные с ней компромиссы 279 Положительные стороны S 11рв Г: изменения деревьев и координирование 285 Изменения классов во время выполнения и super

