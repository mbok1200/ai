


Э. Хант, Д. Тома
ПРОГРАММИСТ
ПРАГМАТИК
Путь от подмастерья к мастеру
г* Как бороться с недостатками программного обеспечения
_Т_ Как создать динамичную и адаптируемую программу
•ч Как осуществлять эффективное тестирование
"<|Г Как формировать команды программистов-прагматиков
ddison-Wesley
Е^ППТЕР

The Pragmatic
Programmer
From Journeyman
to Master
Andrew
Hunt
David
Thomas
•
Addison-Wesley
An imprint of Addison Wesley Longman, Inc.
Reading, Massachusetts Harlow, England Menlo Park,
California Berkeley, California Don Mills, Ontario
Sydney
Bonn Amsterdam
Tokyo Mexico City

Программист-
прагматик
Путь от подмастерья к мастеру
Эндрю Хант
ДЭВИД
Томас
Издательство «Лори»
Издательский дом «Питер»

i
V.
The Pragmatic Programmer
Andrew Hunt
David Thomas
Copyright © 2000
All rights reserved
Прогаммист-прагматик. Путь от подмастерья к мастеру
Эндрю Хант, Дэвид Томас
Переводчик А. Алексашин
Научный редактор А. Головко
Корректор Л. Белая
Верстка Л. Федерякиной
Copyright © 2000 by Addison-Wesley Longman, Inc.
AWL Direct Sales, Addison-Wesley Longman, Inc.
One Jakob Way
(781)944-3700
ISBN 0-201-61622-X
© Издательство "Лори", 2007
Изд. № : OAI (03)
Л Р №: 07612
30.09.97 г.
ISBN 5-85582-213-3
Подписано в печать 16.04.2007
Формат 70 х 100/16
Печ. л. 18
Тираж 1000
Заказ № 4193
Цена договорная
Издательство "Лори"
Москва, 123100, Шмитовский пр., д. 13/6, стр. 1 (пом. ТАРП ЦАО)
Телефон для оптовых покупателей: (495)256-02-83
Размещение рекламы: (495)259-01-62
www.lory-press.ru
ООО "Питер Пресс"
194044, Санкт-Петербург, Б. Сампсониевский пр., д. 29, лит. А
Телефон для оптовых покупателей:
Санкт-Петербург(812)703-73-73, 703-73-72
Москва (495)234-38-15, 255-70-67, 255-70-68
WWW.PITER.COM
Отпечатано в типографии ООО "ТИЛЬ-2004"
Москва, ул. Электрозаводская, д. 21, т. 963-60-55

<
Высказывания программистов-практиков
о книге "Программист-прагматик"
Главное в этой книге то, что она поддерживает процесс создания программ в хо­
рошей форме. [Книга] способствует вашему постоянному росту и явно написана
людьми, знающими толк в программировании.
Кент Бек, автор книги Extreme Programming Explained:
Embrace Change
Я обнаружил, что это книга является смесью убедительных советов и замеча­
тельных аналогий!
Мартин Фаулер, автор книг Refactoring и UML Distilled
Я бы купил книгу, прочел ее дважды, а затем сказал бы всем моим коллегам,
чтобы они скорее бежали в магазин и купили себе по экземпляру. Эту книгу я
никогда не дал бы никому почитать, так как сходил бы с ума от беспокойства за
ее сохранность.
Кевин Руланд, сотрудник отдела менеджмента фирмы
MSG-Logistics
Мудрость и практический опыт авторов очевидны. Разделы, представленные в
книге, уместны и полезны... Сильнейшее впечатление на меня произвели вы­
дающиеся аналогии — стрельба трассирующими, разбитые окна и фантастиче­
ское по своей аналогии с управлением вертолетом объяснение необходимости
ортогонального подхода, что особенно важно в критической ситуации. Я прак­
тически не сомневаюсь, что эта книга станет превосходным источником полез­
ной информации как для начинающих программистов, так и для умудренных
опытом мэтров.
Джон Лакос, автор книги Large-Scale С + + Software
Design
Когда такие книги появляются на прилавках магазинов, я покупаю по десять эк­
земпляров для раздачи моим клиентам.
Эрик Вот, инженер-программист

3
Большинство современных книг по разработке программ не в состоянии охва­
тить основ становления программиста-мастера. Они тратят время на специфи­
кацию синтаксиса или технологии, тогда как на самом деле движущей силой
любой команды является наличие талантливых программистов, которые реаль­
но владеют своим ремеслом. Отличная книга.
Прочитав книгу, я реализовал много из тех практических предложений и под­
сказок, которые дают нам авторы. Честно говоря, они сэкономили моей фирме
время и деньги, помогая выполнить работу быстрее! "Программист-прагматик"
должен стать настольной книгой для всех, кто зарабатывает на жизнь програм­
мированием.
Я хотел бы, чтобы эта книга попала ко всем новым сотрудникам моей фирмы.
Пит Макбрин, независимый консультант
Джаред Ричардсон, старший программист фирмы
iRenaissance, Inc.
Крис Клилэнд, Старший инженер-программист фирмы
Object Computing, Inc.

Предисловие
Книга, которую вы сейчас держите в руках, попала ко мне как рецензенту еще до вы­
хода в свет. Даже в черновом варианте она оказалась превосходной. Дэйву Томасу и
Энди Ханту есть что сказать, и они знают, как сказать. Я видел то, над чем они труди­
лись, и уверен, что сделанное ими будет работать. Меня попросили написать это пре­
дисловие, в котором я и объясняю причины своей уверенности.
В этой книге говорится о способе программирования, которому вы можете после­
довать. Вполне возможно, что вы даже и не думали, что программирование окажется
таким трудным занятием, но дело обстоит именно так. Почему? С одной стороны, не
все книги о программировании написаны профессиональными программистами.
Многие из них скомпилированы создателями языков программирования или же жур­
налистами, которые сотрудничают с ними в продвижении на рынок этих языков. Кни­
ги эти рассказывают вам, как общаться на некоем языке программирования (что, ко­
нечно, является немаловажным фактором), но это лишь малая часть того, чем,
собственно, занимается программист.
Что же программист делает помимо общения на языке программирования? Эта
проблема достаточно глубока. Большинство программистов затруднились бы объ­
яснить, что же они делают. Программирование — это работа, насыщенная под­
робностями, и, для того чтобы уследить за ними, необходимо сосредоточиться.
Проходит время, на свет появляется программа. Если всерьез не задуматься над
тем, что вы делали, можно придти к выводу, что программирование сводится к на­
бору операторов на специфическом языке. Разумеется, это неправда, но вы ни за
что бы так не подумали, осмотревшись по сторонам в секции программирования
книжного магазина.
В своей книге "Программист-прагматик" Дэйв и Энди рассказывают нам о спосо­
бе программирования, которому мы можем последовать. Как же им удалось добиться
таких успехов? Не сосредоточились ли они на деталях, уподобившись другим про­
граммистам? Нет, они лишь уделили внимание тому, что они делали во время самой
работы, а затем попытались сделать это несколько лучше.
Представьте, что вы сидите на совещании. Наверное, вы думаете, что совещание
длится целую вечность, а вместо него лучше было бы заняться программированием.
Дэйв и Энди в такой ситуации думали бы о том, почему происходит это совещание, и за­
дались вопросом, существует ли что-то еще, что они могли бы сделать вместо совеща­
ния, и может ли это "что-то" быть автоматизировано таким образом, чтобы это сове­
щание проходило не в настоящем, а в будущем. Затем они бы осуществили задуманное.
Именно таков образ мышления Дэйва и Энди. Это совещание не отвлекало бы их
от программирования. Напротив, это и было бы программирование. И этот способ
может быть усовершенствован. Я знаю, что они мыслят именно таким образом, по­
скольку в книге есть подсказка 2: "Думай! О своей работе".

viii
Представьте себе, что авторы мыслят подобным образом на протяжении несколь­
ких лет. У них вскоре должна была бы собраться целая коллекция решений. Теперь
представьте, что они используют эти решения в своей работе на протяжении еще не­
скольких лет и при этом оказываются от слишком трудных решений или тех, что не
всегда приводят к желаемому результату. Этот подход и может быть определен как
прагматический. Вы могли бы подумать, что подобная информация — настоящая зо­
лотая жила. И будете правы.
Авторы рассказывают нам, как они программируют. И рассказывают тем спосо­
бом, которому мы можем последовать. Но в этом втором утверждении есть нечто
большее, чем вы думаете. Позвольте мне объяснить.
Авторы проявили осторожность, избегая выдвижения теории разработки про­
граммного обеспечения. Это и хорошо, поскольку в противном случае им пришлось
бы исказить всю книгу, защищая эту теорию. Подобное искажение является традици­
ей в физике, где теории в конечном счете становятся законами или же преспокойно
отвергаются. С другой стороны, программирование подчиняется немногим (если во­
обще каким-нибудь) законам. Поэтому совет в области программирования, вращаю­
щегося вокруг квазизаконов, может прекрасно выглядеть в теории, но на практике
провалиться. Это то, что происходит со многим книгами по методологии.
Я изучал эту проблему в течение десяти лет и обнаружил, что самым многообещаю­
щим является подход, который называется языком шаблонов. Вкратце шаблон пред­
ставляет собой некое решение, а язык шаблонов является некоторой системой реше­
ний, подкрепляющих друг друга. Вокруг поиска таких систем сформировалось целое
сообщество.
Эта книга — больше, чем просто собрание подсказок. Это и есть язык шаблонов,
но в "овечьей шкуре". Я говорю так потому, что каждая подсказка получена из реаль­
ного опыта, подана как конкретный совет, и соотносится с другими, образуя систему.
Подсказки представляют собой характеристики, которые позволяют нам изучать и
следовать языку шаблонов.
Вы можете последовать советам, содержащимся в данной книге, потому что они
конкретны. В книге нет расплывчатых абстракций. Дэйв и Энди пишут непосредст­
венно для вас, так, как будто каждая подсказка является жизненно необходимой для
пробуждения вашей карьеры в сфере программирования. Они упрощают эту сферу,
они рассказывают некую историю, используют легкие намеки, а затем отвечают на
вопросы, которые возникают, когда вы попробуете сделать что-либо.
Есть и нечто большее. После того как вы прочтете десяти или пятнадцать подска­
зок, вам начнет открываться новое измерение вашей работы. В английском языке это
измерение обозначается аббревиатурой QWAN (Quality Without A Name — качество
без имени). Книга содержит философию, которая будет внедряться в ваше сознание и
смешиваться с вашей собственной. Она не занимается проповедью. Она лишь сооб­
щает, что может работать. Но рассказ способствует проникновению внутрь. В этом
состоит красота этой книги: она воплощает философию, и делает это непретенциозно.
И вот она перед вами — простая в чтении и применении книга о практике про­
граммирования. Я все говорю и говорю, о том, почему она действенна. Вам же, веро­
ятно, нужно, чтобы она действовала в принципе. Она действует. Вы это увидите сами.
УордКаннингхэм

От авторов
Эта книга поможет вам стать лучшим программистом.
Неважно, кем вы являетесь — разработчиком-одиночкой, членом большой про­
ектной команды, или консультантом, одновременно работающим со многими заказчи­
ками. Эта книга поможет вам — отдельно взятой личности — повысить качество ра­
боты. Она не посвящена теории — авторы сосредоточились на практических
аспектах, на том, как использовать свой опыт для принятия более продуманных реше­
ний. Слово "прагматик" происходит от латинского pragmaticus — "сведущий в
каком-либо виде деятельности", а оно, в свою очередь, от греческого 7 c p c m e i v , озна­
чающего "делать что-либо". Таким образом, эта книга посвящена деятельности.
Программирование — это прикладное искусство. Простейший его смысл заклю­
чается в следующем: заставить компьютер делать, то что вам нужно (или то, что нуж­
но пользователю, работающему с вашей программой). Программист — он и слуша­
тель, он и советник, он и переводчик и даже диктатор. Вы пытаетесь ухватить суть не
совсем ясных требований и найти такой способ их выражения, что только машина
сможет оценить их по достоинству. Вы пытаетесь задокументировать работу так, что­
бы она была понятна другим, спроектировать ее так, чтобы другие могли на нее поло­
житься. Кроме того, вы пытаетесь сделать все это вопреки безжалостному ходу
стрелки часов, отсчитывающих время, отпущенное на проект. Каждый день вы совер­
шаете по маленькому 'гуду.
Это непростая работа.
Многие предлагают вам помощь. Фирмы-поставщики инструментальных средств
настойчиво говорят о чудесах, которые творят их программы. Мудрецы от методологии
заверяют в том, что их средства гарантируют результаты. Каждый считает свой язык
программирования лучшим из лучших, а операционную систему — панацеей.
Разумеется, эти утверждения неверны. Простых ответов не существует. Не суще­
ствует такого понятия, как наилучшее решение, будь то инструментальное средство,
язык или операционная система. Существуют лишь некие системы, которые являют­
ся более приемлемыми при конкретном стечении обстоятельств.
И в этот момент на сцену выходит прагматизм. Стоит избегать обряда венчания с
конкретной технологией, но при этом необходимо обладать подготовкой и опытом, на­
столько обширными, что это позволит выбрать верные решения в конкретных ситуа­
циях. Ваша подготовка происходит из понимания основных принципов информатики,
а опыт основывается на разнообразных практических проектах. Теория и практика
сочетаются, придавая вам силу.
Вы корректируете ваш подход, приспосабливая его к существующим обстоятель­
ствам и окружающей среде. Вы оцениваете относительную важность все факторов,
влияющих на проект, и используете свой опыт в выработке приемлемых решений.
И все это вы делаете непрерывно по ходу работы. Программисты-прагматики делают
дело и делают его хорошо.

>
От авторов
Кому адресована эта книга?
Эта книга предназначена программистам, желающим повысить эффективность и про­
дуктивность своей работы. Возможно, вы разочарованы тем, что не реализуете до
конца свой потенциал. Возможно, вы смотрите на коллег, которые, как вам кажется,
используют инструментальные средства, чтобы опередить вас в продуктивности сво­
его труда. Может быть, в вашей работе используются устаревшие технологии, и вам
хотелось бы узнать, как можно приложить новые идеи к тому, над чем вы работаете в
данный момент.
Авторы не претендуют на то, что обладают ответами на все вопросы (или даже
большинство), и на то, что их идеи применимы ко всем ситуациям. Можно лишь ска­
зать, что если следовать подходу авторов, то опыт приобретается быстро, продуктив­
ность увеличивается и целостное понимание процесса разработки программ улучша­
ется. И вы создаете лучший программный продукт.
Каждый разработчик уникален, со своими сильными сторонами и слабостями, предпоч­
тениями и неприязнью. С течением времени каждый создает собственную окружающую
среду. Эта среда отражает индивидуальность программиста в той же степени, как его
(или ее) хобби, одежда или прическа. Однако если вы принадлежите к программистам-
прагматикам, то у вас есть общие черты, характеризующие данный тип:
•
Опережающее восприятие и быстрая адаптация. У вас есть инстинкт на
технологии и методы, и вам нравится проверять их на практике. Вы быстро
схватываете новое и объединяете его с уже имеющимися знаниями. Ваша
уверенность рождается из опыта.
•
Любознательность. Вы стремитесь задавать вопросы. "Это здорово — как
тебе это удалось?" "У тебя возникали сложности при работе с этой библио­
текой?" "Что это за система BeOS, о которой я как-то слышал?" "Как реали­
зуются символические ссылки?" Вы — охотник до мелких фактов, каждый
из которых повлияет на то или иное решение даже годы спустя.
•
Критическое осмысление. Вы редко принимаете что-то на веру, не ознако­
мившись предварительно с фактами. Когда коллеги говорят, что "этого не
может быть, потому что этого не может быть никогда", или же фирма-
поставщик обещает решить абсолютно все ваши проблемы, у вас возникает
ощущение близящейся схватки с соперником.
•
Реализм. Вы пытаетесь нащупать, где же находятся подводные камни в каж­
дой проблеме, с которой приходится сталкиваться. Реализм дает понимание
того, насколько трудными могут быть многие предметы и сколько времени
займет то или иное действие. Осознание для себя, что процесс должен быть
непростым или что для его завершения потребуется время, придаст вам жиз­
ненные силы, необходимые для его осуществления.
Как происходит становление
программиста-прагматика?

От авторов
•
Универсальность. Вы стараетесь познакомиться с большим числом техно­
логий и операционных систем, и работаете, чтобы не отставать от новшеств.
Хотя для вашей теперешней работы может потребоваться узкая специализа­
ция, вы всегда сможете перейти в новую область, открывая для себя новые
горизонты.
Под конец авторы приберегли наиболее общие характеристики. Все программи­
сты-прагматики обладают ими. Они настолько общие, что могут расцениваться как
подсказки:
Подсказка 1
Позаботьтесь о вашем ремесле
Нет смысла разрабатывать программы, если вы не заботитесь о качестве работы.
Подсказка 2
Думай! О своей работе
Авторы призывают вас во время работы думать только о работе — только так вы
останетесь программистом-прагматиком. Это не случайная оценка существующей
практики, а критическая оценка каждого принимаемого вами решения — в течение
каждого рабочего дня и по каждому проекту. Никогда не пользуйтесь автопилотом.
Думайте постоянно, критикуя свою работу в реальном масштабе времени. Старый де­
виз фирмы IBM "ДУМАЙ!": является своего рода мантрой для программиста-
прагматика.
Если сказанное покажется вам каторжной работой, это значит, что вы обнаружи­
ваете реалистическое мышление.рто, вероятно, отнимет некоторую часть вашего
драгоценного времени — того времени, которое уже спрессовано до крайности. Но
наградой станет более активное вовлечение в работу, которую вы любите, чувство
властителя над все большим числом предметов и удовольствие, порождаемое чувст­
вом постоянного усовершенствованиям Вложенное вами время будет приносить доход
в течение долгого периода, по мере того, как вы и ваша команда будете работать с
большей эффективностью, писать программы, которые легче поддерживать, и тра­
тить меньше времени на производственные собрания.
Прагматики-одиночки и большие команды
У некоторых людей возникает чувство, что в больших командах или сложных проектах
нет места индивидуальности. "Разработка программ является инженерной дисципли­
ной, которая нарушается, когда отдельные члены команды начинают решать сами за
себя", — говорят они.
Авторы не согласны с этим утверждением.
Разработка программ призвана быть инженерной дисциплиной. Однако это не ис­
ключает индивидуального мастерства. Достаточно вспомнить о больших соборах, по­
строенных в Европе в средние века. Для каждого из них потребовались тысячи

xii
От авторов
Непрерывность процесса
Во время экскурсии
по Итонскому
колледжу
в Англии
турист
спросил
садовника,
как ему удается
содержать
лужайки
в столь идеальном
со­
стоянии.
"Это несложно,
— ответил
садовник,
— вы просто
стряхи­
ваете росу каждое утро, выкашиваете
лужайку
через день и
утрамбо­
вываете
раз в
неделю".
"И это все?"
— спросил
турист.
"Абсолютно
все, — ответил
садовник,
— если заниматься
этим
на
протяжении
500 лет, то ваша лужайка
будет не
хуже".
Великие лужайки, как и великие программисты, нуждаются в ежедневном уходе.
В ходе беседы консультанты в области менеджмента не преминут вставить японское
слово "кайдзен". "Кайдзен" — японский термин, означающий политику непрерывно­
го внедрения большого количества мелких усовершенствований. Считается, что
"кайдзен" стала одной из основных причин резкого роста производительности и каче­
ства в японской промышленности, и эту политику стали применять во многих странах.
"Кайдзен" применима и к отдельным личностям. Каждый день необходимо работать,
оттачивая свои навыки и добавляя в свой репертуар новые произведения. В отличие
от итонских газонов, для достижения результата потребуются дни. Годы спустя вы бу­
дете поражаться своему преуспеванию и профессиональному росту.
Как составлена эта книга
Книга составлена из кратких разделов. Каждый раздел является законченным и по­
священ определенной теме. В тексте есть перекрестные ссылки, которые помогают
поставить каждую тему в контекст. Разделы можно читать в любом порядке — данная
книга не предназначена для чтения от начала до конца.
человеко-лет усилий, прилагаемых на .протяжении десятилетий. Приобретенный
опыт передавался следующему поколению строителей, которые своими достижения­
ми двигали строительную технику вперед. Но плотники, каменотесы, резчики по дере­
ву и стекольщики оставались мастерами, преобразующими требования для создания
единого целого, что выходило за границы чисто механической стороны строительства.
Именно вера в их личный вклад не давала замереть этим проектам:
Отесывая
камни, всегда думай о
соборах,
которые
будут строиться
из них.
— Кредо средневекового каменотеса
В общей структуре проекта всегда найдется место индивидуальности и мастерству.
Это утверждение особенно верно, если учитывать сегодняшнее состояние програм­
мирования. Через сотню лет современные методы программирования могут показать­
ся такими же архаичными, какими сегодня кажутся методы строительства средневе­
ковых соборов, тогда как наше мастерство по-прежнему будет в почете.

I
От авторов

x i i i
"""Чьи*
Периодически вам будут попадаться вставки типа "Подсказка пп" (например,
"Подсказка 1: Позаботьтесь о вашем ремесле" ^Помимо выделения некоторых важ­
ных моментов в тексте, подсказки живут своей собственной жизнью, а авторы живут
по ним повседневно.
В приложении А содержится перечень использованных ресурсов: библиографиче­
ский список, список ссылок на web-ресурсы, а также список рекомендованных перио­
дических изданий, книг и профессиональных организаций. В тексте книги есть биб­
лиографические ссылки и ссылки на web-ресурсы, такие как [КР99] и [URL 18]
соответственно.
Авторы включили Упражнения и Вопросы для обсуждения. Упражнениям (и от­
веты к ним), как правило, несложные, тогда как Вопросы для обсуждения более за­
мысловаты. Для того чтобы передать свой образ мышления, авторы включили свои
собственные ответы к упражнениям в приложение В, но лишь некоторые из упраж­
нений имеют единственное корректное решение. Вопросы для обсуждения могут
стать основой для групповых дискуссий или написания эссе на углубленных курсах
программирования.
Исходные тексты программ и другие
ресурсы
Большинство программ, представленных в этой книге, извлечены из компилируемых
исходных файлов, которые можно загрузить с web-сайта
www. pragmaticprogrammer. com.
Ваши отклики
Авторам книги интересны ваши отклики. Комментарии, предложения, замеченные в
тексте ошибки и проблемы в приведенных примерах всячески приветствуются. Наш
электронный адрес:
ppbook@pragmaticprogrammeг.com.
Благодарности
Когда мы начали писать эту книгу, у нас не было мыслей насчет коллективных усилий,
необходимых для ее выпуска в свет.
Издательство Addison-Wesley было как всегда великолепно, пригласив пару начи­
нающих хакеров и показав авторам весь процесс издания книги — от идеи до
оригинал-макета. Авторы выражают благодарность Джону Уэйту и Меере Равинди-
рану за поддержку в начале работы над книгой, Майку Хендриксону, редактору-
энтузиасту (и оформителю обложки!), Лоррейн Ферье и Джону Фуллеру за помощь в
производстве и неутомимой труженице Джулии Дебаггис, связавшей нас воедино.
Затем наступил черед рецензентов. Это Грег Эндресс, Марк Чиэрс, Крис Кли-
лэнд, Алистер Кокбэрн, Уорд Каннингхэм, Мартин Фаулер, ТхангТ. Зиан, Роберт Л.

От авторов
Гласе, Скотт Хеннингер, Майкл Хантер, Брайан Кирби, Джон Лакос, Пит Макбрин,
Кэри П. Моррис, Джаред Ричардсон, Кевин Рулэнд, Эрик Старр, Эрик Ваут, Крис
Ван Вик и Дебора Зуковски. Без их заботливых комментариев и ценных советов эта
книга читалась бы хуже, была бы менее точной и в два раза длиннее. Благодарим их за
уделенное нам время и мудрость.
Второе издание этой книги существенно выиграло за счет пристальных взоров чи­
тателей. Благодарим Брайана Блэнка, Пола Боула, Тома Экберга, Брента Фулгэма,
Луи-Поля Эбера, Хенка-Яна Ульде Лоохюса, Алана Лунда, Гарета Маккофана, Ио-
шики Шибату и Фолькера Вурста за найденные ошибки и деликатность, проявленную
при указывании на них авторам.
В течение многих лет мы работали с большим количеством продвинутых клиентов,
от них мы набирались опыта, который и описали в этой книге. Недавно мы имели сча­
стье работать с Питером Герке над несколькими проектами. Мы благодарны ему за
поддержку и энтузиазм.
При издании данной книги использовались программные продукты LaTex, pic,
Perl, dvips, ghostview, ispell, GNU make, CVS, Emacs, XEmacs, EGCS, GCC, Java,
iContract и SmallEiffel, оболочки Bash и zsh в операционной среде Linux. Поражает
тот факт, что все эта груда программного обеспечения распространяется абсолютно
бесплатно. Авторы говорят "спасибо" тысячам программистов-прагматиков, создав­
ших эти продукты и передавших их нам. Отдельно хотелось бы поблагодарить Рето
Крамера за его помощь в работе с iContract.
И последнее, но оттого не менее важное: авторы в огромном долгу перед своими
семьями, которые не только смирились с поздним засиживанием за компьютером, ог­
ромными счетами за телефонные разговоры и постоянным беспорядком, но и благо­
родно время от времени соглашались прочесть то, что написали авторы. Благодарим
их за то, что они не давали нам спускаться с небес на землю.
Энди
Хант
Дэйв
Томас

(
ОГЛАВЛЕНИЕ
Глава 1. Прагматическая
философия
1
1
Мой исходный текст съел кот Мурзик
Принятие ответственности

2
2
Энтропия в программах

3
3
Суп из камней и сварившиеся лягушки

6
4
Приемлемые программы

8
Находите компромисс с пользователями
8
Знайте меру

9
5
Портфель знаний
Ю
Ваш портфель знаний
Построение вашего портфеля
11
Цели
12
Возможности обучения
13
Критическое осмысление
14
6
Общайтесь!
15
Глава 2. Прагматический
подход
21
7
Пороки дублирования
Как возникает дублирование?
23
Навязанное дублирование
23
Неумышленное дублирование
25
Нетерпеливое дублирование
26
Коллективное дублирование
27
8
Ортогональность
28
Что такое ортогональность?
28
Преимущества ортогональности
29
Проектные группы
31
Проектирование
31
Инструментарии и библиотеки
33
Написание текста программы
34
Тестирование
35
Документация
36
Жизнь в условиях ортогональности
36
9
Обратимость
37
Обратимость
38
Гибкая архитектура
39
10 Стрельба трассирующими
41
Программа, которую видно в темноте
41
При стрельбе трассирующими вы не всегда попадаете в цель
43
Программа трассировки и создание прототипов
44
11 Прототипы и памятные записки
45
Для чего создаются прототипы
46
Как использовать прототипы
46
Создание прототипов архитектуры
47
Как не надо использовать прототипы
48
12 Языки, отражающие специфику предметной области
49
13 Оценка
55

xvi
Оглавление
Насколько точной является "приемлемая точность"?
56
Из чего исходят оценки?
57
Что сказать, если вас просят оценить что-либо
60
Глава 3. Походный набор инструментов
61
14 Преимущество простого текста
62
Что такое простой текст?
63
Недостатки
63
Преимущества простого текста
64
Подводим итог
66
15 Игры с оболочками
67
Утилиты оболочек и системы Windows
70
16 Мощь редактирования
71
Один-единственный редактор
71
Средства редактирования
72
Производительность
73
Куда же направиться?
74
Какой же редактор выбрать?
75
17 Управление исходным текстом программ
75
Команда, в которой я работаю, не использует систему
управления исходным текстом
77
Программы управления исходным текстом
78
18 Отладка
78
Психология процесса отладки
79
Умонастроение отладки
79
С чего начать?
80
Стратегии отладки
81
Элемент удивления
85
Контрольные вопросы при отладке
86
19 Обработка текста
86
20 Генераторы текстов программ
90
Пассивные генераторы
90
Активные генераторы текста
91
Генераторы текста не должны быть слишком сложными
93
Генераторы текста не всегда генерируют тексты программ
93
Глава 4. Прагматическая
паранойя
95
21 Проектирование по контракту
96
Реализация принципа ППК
100
ППК и аварийное завершение работы программы
101
Другие случаи применения инвариантов
103
Динамические контракты и агенты
105
22 Мертвые программы не лгут
107
Аварийное завершение не означает "отправить в корзину
для мусора"
107
23 Программирование утверждений
109
Не отключайте утверждения
110
24 Случаи, в которых используются исключения
112
Что является исключительным?
113
Обработчики ошибок как альтернатива исключению
114
25 Балансировка ресурсов
116

(
Оглавление
xvll
Объекты и исключения
S .
.J
Балансировка и исключения . . . .

4 v *
• • ц,- • •
^
Случаи, при которых балансировка ресурсов невозможна
121
Проверка баланса
122
Глава 5. Гибкость против хрупкости
125
26 Несвязанность и закон Деметера
126
Сведение связанности к минимуму
126
Закон Деметера для функций
128
А не всели равно?
128
27 Метапрограммирование
131
Динамическая конфигурация
131
Приложения, управляемые метаданными
132
28 Временное связывание
136
Последовательность операций
137
Архитектура
138
Проектирование с использованием принципа параллелизма
140
Развертывание
142
29 Всего лишь визуальное представление
143
Протокол "Публикация и подписка"
143
Принцип "модель-визуальное представление-контроллер"
145
Отходя от графических интерфейсов
147
Все такой же связанный (после стольких лет)
149
30 Доски объявлений
150
Реализация концепции доски объявлений
151
Пример приложения
153
Глава 6. Пока вы пишете программу
155
31 Программирование в расчете на стечение обстоятельств
156
Как программировать в расчете на стечение обстоятельств
156
Преднамеренное программирование
158
32 Скорость алгоритма
160
Что подразумевается под оценкой алгоритмов?
161
Система обозначений ОС)
161
Оценка сточки зрения здравого смысла
163
Скорость алгоритма на практике
164
33 Реорганизация
167
Когда осуществлять реорганизацию?
168
Как производится реорганизация?
169
34 Программа, которую легко тестировать
172
Модульное тестирование
172
Тестирование в рамках контракта
173
Создание модульных тестов
175
Применение тестовых стендов
176
Построение тестового окна
178
Культура тестирования
179
35 Злые волшебники
180
Глава 7. Перед тем, как начать проект
._.
183
36 Карьер для добычи требований
184
В поисках требований
184
Документация требований
186

J
xviii
Оглавление
Чрезмерная спецификация
189
Видеть перспективу
189
Еще одна мелочь
. ТТ.
190
Поддержка глоссария
191
Прошу слова
191
37 Разгадка невероятных головоломок
192
Степени свободы
193
Есть более простой способ!
194
38 Чувство готовности
195
Здравое суждение или промедление?
195
39 Западня со стороны требований
196
40 Круги и стрелки
199
Какова отдача от методов?
200
Должны ли мы использовать формальные методы?
201
Глава 8. Прагматические
проекты
203
41 Команды прагматиков
204
Никаких разбитых окон
204
Сварившиеся лягушки
204
Общайтесь
205
Не повторяйте самого себя
206
Ортогональность
206
Автоматизация
208
Чувствуйте момент, когда нужно остановиться
208
42 Вездесущая автоматизация
209
Все в автоматическом режиме
210
Компилирование проекта
Автоматизация процесса сборки
212
Автоматические административные процедуры
213
Дети сапожника
215
43 Безжалостное тестирование
216
Что тестировать
• 217
Как проводить тестирование
219
Когда тестировать
Кольцо сжимается
224
44 Все эти сочинения
225
Комментарии в программе
226
Исполняемые документы
228
Технические писатели
229
Печатать документ или ткать его на холсте?
229
Языки разметки
230
45 Большие надежды
231
Передача надежд
232
Небольшой довесок
233
46 Гордость и предубеждение
234
Приложение
А. Информационные
ресурсы
235
Профессиональные общества
236
Собираем библиотеку
236
Интернет-ресурсы
239
Приложение
В. Ответы к упражнениям
251

Глава 1
Прагматическая
философия
Что отличает программистов-прагматиков? Мы полагаем, что это склад ума, стиль,
философия подхода к существующим проблемам и их решениям. Прагматики выходят
за пределы сиюминутной проблемы, всегда стараются рассмотреть ее в более широ­
ком контексте, осознать общую картину происходящего. В конце концов, как можно
быть прагматиком вне широкого контекста? Как приходить к интеллектуальным ком­
промиссам и принимать взвешенные решения?
Другим ключом к успеху прагматиков является то, что они берут на себя ответст­
венность за все, что они делают; это обсуждается ниже в разделе "Мой исходный
текст съел кот Мурзик". Будучи ответственными, прагматики не сидят сложа руки,
глядя на то, как их проекты погибают из-за небрежного отношения. В разделе "Про­
граммная энтропия" говорится о том, как сохранить проекты в первоначальном виде.
Большинство людей с трудом воспринимают изменения: иногда по понятным при­
чинам, иногда в силу старой доброй инерции. В разделе "Суп из камней и сварившие­
ся лягушки" рассматривается стратегия провоцирования изменений, а также (для
равновесия) предлагается поучительная сказка о некоем земноводном, которое не
учло опасностей, таящихся в постепенном изменении.
Одним из преимуществ понимания контекста, в котором вы работаете, является
более легкое осознание того, насколько хорошими должны быть создаваемые про­
граммы. Иногда "почти идеальность" является единственно возможным вариантом,
но зачастую приходится идти на компромиссы. Этот аспект исследуется в разделе
"Приемлемые программы".
Конечно, необходимо обладать обширной базой знаний и опыта, чтобы все это
одолеть. Обучение представляет собой непрерывный и продолжительный процесс.
В разделе "Портфель знаний" обсуждаются некоторые стратегии поддержания
стремления к обучению.
Разумеется, никто из нас не работает в безвоздушном пространстве. Все мы про­
водим большое количество времени в общении с другими людьми. В разделе "Общай­
тесь!" перечислены способы, как сделать это общение более эффективным.

2
Глава 1
Принятие ответственности
Ответственность — это то, на что активно соглашаются. Вы связываете себя обяза­
тельством, чтобы гарантировать, что нечто делается правильно, но ваш непосредст­
венный контроль над каждым аспектом делаемого не является необходимостью. В до­
полнение к тому, что вы делаете все от вас зависящее, необходимо анализировать
ситуацию на предмет наличия неконтролируемых вами рисков. Вы имеет право не
принимать на себя ответственность за невозможную ситуацию или за ситуацию, рис­
ки в которой слишком велики. Вам придется сделать самоотвод, основанный на вашей
собственной этике и оценках.
Если вы приняли на себя ответственность за результат, то вам придется за него
перед кем-то отчитываться. Если вы делаете ошибку (как и все мы),признайте ее че­
стно и попытайтесь предложить варианты исправления.
Не стоит перекладывать вину на кого-либо (или на что-либо) или выдумывать от­
говорки. Не стоит сваливать все на субподрядчика, язык программирования, менедж­
мент или коллег по работе. Все они могут сыграть свою роль в неудаче, но вашим де­
лом является решение проблем, а не отговорки.
Если есть вероятность, что субподрядчик не справится со своими обязанностями,
то у вас должен быть план на случай возникновения непредвиденных обстоятельств.
Если жесткий диск выходит из строя, унося в небытие весь исходный текст, а у вас
нет резервной копии, это ваша вина. Фраза "Мой исходный текст съел кот Мурзик",
высказываемая вашему шефу, не решит возникшей проблемы.
Прагматическое программирование ведет свое начало от философии прагматиче­
ского мышления. В данной главеприводятся основные положения этой философии.
1
Мой исходный текст съел кот Мурзик
Страх показаться
слабым есть
величайшая
из всех
слабостей.
Ж. Б. Боссюэ, Политика
и Священное
Писание,
1709
Одним из краеугольных камней прагматической философии является идея приня­
тия ответственности за себя и за свои действия с точки зрения карьерного роста,
проекта и каждодневной работы. Программист-прагматик принимает на себя от­
ветственность за свою собственную карьеру и не боится признавать неведение или
ошибке. Конечно, это не самый приятный момент программирования, но это слу­
чается даже с лучшим из проектов. Несмотря на тщательное тестирование, хоро­
шее документирование и основательную автоматизацию, осе идет не так как надо.
Выпуски программ запаздывают. Появляются непредусмотренные технические
проблемы.
Подобные вещи случаются, и мы пытаемся справиться с ними настолько профес­
сионально, насколько это возможно. Это означает быть честным и непосредствен­
ным. Мы можем гордиться нашими способностями, но мы должны быть честными, го­
воря и о наших недостатках — нашем неведении и наших ошибках.

Прагматическая философия
3
Ч
Подсказка 3
Представьте варианты решения проблемы, а не варианты
отговорок
Перед тем как подойти к кому-либо, чтобы высказать, почему что-либо не может
быть сделано или уже сломалось, остановитесь и прислушайтесь к себе. Поговорите с
резиновым утенком, стоящим на вашем мониторе, или с котом. Как звучит ваша отго­
ворка, разумно или глупо? И как ее воспримет ваш шеф?
Смоделируйте разговор в уме. Что, вероятнее всего, скажет ваш собеседник?
Спросит ли он: "А так вы пробовали?" или "А это вы учли?" Как ответить? Перед тем
как пойти и сообщить плохие новости, может, попробовать что-то еще? Иногда вы
просто знаете, что он собирается сказать, поэтому избавьте его от лишних забот.
Вместо отговорок представьте варианты решения проблемы. Не говорите, что это
не может быть сделано, объясните, что может быть сделано для спасения ситуации.
Может быть, взять да и выбросить исходный текст? Развивайте эти варианты, ис­
пользуя реорганизацию (см. "Реорганизация"). Стоит ли тратить время на разработку
прототипа, чтобы определить лучший способ, который необходимо использовать (см.
"Прототипы и памятные записки")? Стоит ли внедрять более совершенные процеду­
ры тестирования (см. "Программа, которую легко тестировать" и "Безжалостное тес­
тирование") или автоматизации (см. "Вездесущая автоматизация"), чтобы предот­
вратить дальнейшие неудачи? Возможно, вам понадобятся дополнительные ресурсы.
Не бойтесь спрашивать или признаваться, что нуждаетесь в помощи.
Попытайтесь исключить неубедительные отговорки до того, как их озвучить. Если
нужно, выскажите их сначала вашему коту. Ну а если ваш Мурзик возьмет вину на
себя ...
Другие разделы, относящиеся к данной теме:
•
Прототипы и памятные записки
•
Реорганизация
•
Программа, которую легко тестировать
•
Вездесущая автоматизация
•
Безжалостное тестирование
Вопросы д л я обсуждения:
•
Как вы отреагируете, когда кто-нибудь — кассир в банке, механик в авто­
сервисе или клерк — придет к вам с подобными отговорками? Что в итоге
можно подумать о них лично и об их фирме?
2
Энтропия в программах
Разработка программного обеспечения обладает иммунитетом почти ко всем физиче­
ским законам, однако энтропия оказывает на нас сильное влияние. Энтропия — это

J
термин из физики, обозначающий уровень "беспорядка" в системе. К сожалению, за­
коны термодинамики утверждают, что энтропия во вселенной стремится к максимуму.
Увеличение степени беспорядка в программах на профессиональном жаргоне назы­
вается "порчей программ".
Существует много факторов, вносящих свой вклад в порчу программ. Похоже, что
наиболее важным из них является психология или культура в работе над проектом.
Даже если команда состоит лишь из одного-единственного сотрудника, психология
проекта может быть весьма тонкой материей. При наличии наилучших планов и спе­
циалистов экстракласса, проект все же может рухнуть и сгнить в период разработки.
Однако существуют и другие проекты, которые, несмотря на огромные трудности и
постоянные неудачи, успешно борются с природной тенденцией к беспорядку и закан­
чиваются хорошо.
В чем же состоит разница?
Некоторые здания, расположенные в старых кварталах города, находятся в хоро­
шем состоянии и чистоте, тогда как другие представляют собой жуткие развалины.
Почему? Исследователи в области преступности и упадка больших городов открыли
удивительный механизм, запускающий процесс быстрого превращения чистенького,
нетронутого жилого дома в полуразрушенную и заброшенную трущобу [WK82].
Причина — одно-единственное разбитое окно.
Одно разбитое окно, стекло в котором не меняется в течение длительного време­
ни, развивает в обитателях здания ощущение заброшенности — ощущение, что вла­
стям нет дела до того, что происходит со зданием. Затем разбивается другое окно.
Люди начинают мусорить. На стенах появляются похабные надписи. Возникают серь­
езные повреждения строительной конструкции. За относительно короткое время зда­
ние портится, несмотря на стремление владельца отремонтировать его, и ощущение
заброшенности становится реальностью.
"Теория разбитого окна" дала полицейским участкам в Нью-Йорке и других боль­
ших городах стимул: навалиться всем миром на решение малых проблем ради сдержи­
вания больших. И это срабатывает: сосредоточение усилий на первоочередном реше­
нии проблем разбитых окон, похабных надписей и других малых правонарушений
привело к сокращению уровня тяжких преступлений.
Подсказка 4
Не живите с разбитыми окнами
Не оставляйте "разбитые окна" (неудачные конструкции, неверные решения или
некачественный текст программы) без внимания. Как только их обнаружите, чините
сразу. Если нет времени на надлежащий ремонт, забейте окно досками. Наверняка вы
сможете закомментировать ошибочный фрагмент или вывести на экран сообщение
"В стадии разработки", или использовать фиктивные данные. Необходимо предпри­
нять хотя бы малейшее действие, чтобы предотвратить дальнейшее разрушение, и по­
казать, что вы контролируете ситуацию.
Мы видели, как безошибочные, функциональные системы быстро портились, как
только окна начали разбиваться. Существуют и другие факторы, которые вносят свой
4
Глава 1

Прагматическая философия
5
вклад в порчу программ, и мы коснемся некоторых из них далее, но небрежность уско­
ряет порчу быстрее, чем любой другой фактор.
Вы можете подумать, что ни у кого не будет времени обойти "разбитые окна" про­
екта и отремонтировать их. Если вы продолжаете думать подобным образом, тогда
вам лучше спланировать приобретение мусорного контейнера или переехать в другой
район города. Не давайте энтропии победить себя.
Как погасить пожар
И напротив, существует история абсурдного (до неприличия) опыта одного из авторов
книги, Энди Ханта. Его дом был в идеальном порядке, великолепен, наполнен бесцен­
ным антиквариатом, произведениями искусства и прочими ценностями. Однажды го­
белен, висевший слишком близко от камина в жилой комнате, загорелся. Пожарные
примчались, чтобы спасти положение, а заодно и дом. Но перед тем как втащить в дом
свои большие, грязные шланги, они остановились перед полыхающим огнем, чтобы
раскатать специальный мат от входной двери до очага пожара.
Они боялись испортить ковер.
Конечно, это весьма экстремальный случай, но именно этот способ должен исполь­
зоваться в случае с программным обеспечением. Одно разбитое окно — неудачно
спроектированный фрагмент программы, неверное решение, принятое менеджером
(действующее на протяжении всего проекта) — это все, что требуется для того, чтобы
началось отклонение от нормы. Если оказывается, что вы работаете над проектом с не­
сколькими разбитыми окнами, то слишком легко сползти к умонастроению типа "Вся
оставшаяся часть программы — это ерунда, я всего лишь следую примеру". Не важно,
в каком состоянии находился проект до этого момента. В оригинальном эксперименте,
приведшем к возникновению теории разбитых окон, заброшенный автомобиль стоял в
течение недели нетронутым. Но как только одно-единственное окно было разбито, ав­
томобиль был "раздет" и перевернут вверх колесами за несколько часов.
К тому же, если вы находитесь в команде и работаете над проектом, тексты про­
грамм которого совершенны изначально — корректно написаны, хорошо спроекти­
рованы и элегантны, — вы, вероятно предпримете дополнительные усилия к тому,
чтобы не испортить их, так, как это сделали пожарные с ковром. Даже если речь идет
о чрезвычайной ситуации (контрольные сроки, дата выпуска, демонстрационная вер­
сия для выставки и т.д.), вы не захотите быть первым среди тех, кто портит проект.
Другие разделы, относящиеся к данной теме:
•
Суп из камней и сварившиеся лягушки
•
Реорганизация
•
Команды прагматиков
Вопросы д л я обсуждения
•
Поспособствуйте укреплению вашей команды, изучив ваших компьютерных
"соседей". Выберите одно или два "разбитых окна" и обсудите с вашими кол­
легами, в чем состоят проблемы и что можно сделать для их решения.

6
Глава 1
•
Можно ли сказать, когда разбивается первое окно? Какова ваша реакция?
Если это произошло в результате чьего-либо решения или по воле руково­
дства, как вести себя в этом случае?
3
Суп из камней и сварившиеся лягушки
Трое солдат возвращались
с войны и проголодались.
Когда они увидели
впереди
деревню,
их, настроение
поднялось
— они были уверены,
что крестьяне
накор­
мят их. Но как только
они пришли в деревню,
все двери оказались
заперты,
а
окна — закрыты.
После долгой войны крестьяне
бедствовали
и прятали
то,
что у них
есть.
Это не смутило солдат, они вскипятили
котел воды и аккуратно
положи­
ли в него три камня. Удивленные
крестьяне
вышли
посмотреть.
"Это суп из камней",
— объяснили
солдаты
крестьянам.
"И это все,
что
вы в него кладете?"
— спросили крестьяне.
"Абсолютно
все — хотя на вкус
он будет
намного
лучше,
если положить
в него немного
моркови".
Один
из
крестьян
убежал,
и быстро вернулся
с корзиной
моркови
из своего
погреба.
Через некоторое
время крестьяне
вновь спросили:
"И это
все?"
"Да, — сказали
солдаты,
— но пара картофелин
сделает
суп
посытнее".
И другой крестьянин
убежал.
В течение
следующего
часа солдаты
попросили
у крестьян
другие
ингреди­
енты, которые
сделали суп вкуснее:
мясо, лук, соль и травы. Каждый раз
раз­
ные крестьяне
потрошили
свои личные
запасы.
Так они сварили
большой
котел
дымящегося
супа. Затем
солдаты
вынули
камни и уселись вместе со всей деревней,
чтобы поесть досыта
— первый
раз
за многие
месяцы.
В истории с супом из камней есть два важных урока. Солдаты обманывают кресть­
ян, используя любопытство последних, чтобы добыть у них пишу. Но что более важно,
солдаты явились катализатором, объединяя жителей деревни с тем, чтобы общими
усилиями сделать то, что они не смогли сделать сами, — синергетический результат.
В конечном итоге выигрывают все.
Иногда в этой жизни вам бы хотелось оказаться на месте солдат.
Вы можете оказаться в ситуации, когда вам точно известно, что нужно сделать и
как это сделать. Перед глазами возникает общий план системы, и вы осознаете, что
именно так это и должно быть. Но если вы спросите разрешение на проработку ас­
пекта в целом, то столкнетесь с волокитой и пустыми глазами. Люди будут образовы­
вать комиссии, бюджет должен быть одобрен, и все будет усложнено. Каждый будет
держаться за свое кресло. Иногда это называется "изначальной усталостью". Пора
вытаскивать камни из котла. Выработайте то, о чем вы реально можете попросить.
Проработайте детали. Как только вы это сделаете, покажите людям и позвольте им
удивиться. Они скажут: "Конечно, было бы лучше, если бы мы добавили...". Поло­
жим, что это не важно. Расслабьтесь и подождите, пока они не начнут спрашивать вас
о добавлении функциональных возможностей, которые вы задумали изначально. Лю-

Прагматическая философия
7
дям легче присоединиться к грядущему успеху. Покажите им свет в конце туннеля, и
они сплотятся вокруг вас
1.
Подсказка 5
Будьте катализатором изменений
С другой стороны, история с супом из камней — это история о ненавязчивом и по­
степенном обмане. Это история о шорах на глазах. Крестьяне думают о камнях и за­
бывают обо всем остальном в мире. Все мы впадаем в подобное состояние ежедневно.
Нечто просто подкрадывается к нам.
Всем нам известны симптомы. Проекты медленно и неизбежно полностью выхо­
дят из-под контроля. Большинство программных катастроф начинаются с малозамет­
ных вещей, и большинство проектов в один прекрасный день идут вразнос. Шаг за
шагом система отклоняются от требований, при этом фрагмент текста программы об­
растает "заплатами", пока от оригинала не остается ничего. Зачастую именно скопив­
шиеся мелочи приводят к разрушению морали и команд.
Подсказка 6
Следите за изменениями
Сами мы, по чести, никогда этого не делали. Но говорят, что если взять лягушку и
бросить ее в кипящую воду, то она сразу выпрыгнет наружу. Однако если бросить ля­
гушку в кастрюлю с холодной водой, а затем медленно нагревать ее, то лягушка не за­
метит медленного увеличения температуры и останется сидеть в кастрюле, пока не
сварится.
Заметим, что проблема лягушки отличается от проблемы разбитых окон, обсуж­
даемой в разделе 2. В теории "разбитых окон" люди теряют волю к борьбе с энтропи­
ей, поскольку она никого не волнует. Лягушка же просто не замечает изменений.
^Tie будьте лягушкой. Не сводите глаз с общей картины происходящего. Постоян­
но наблюдайте за тем, что происходит вокруг вас, а не только за тем, что делаете вы
Другие разделы, относящиеся к данной теме:
•
Энтропия в программах
•
Программирование в расчете на совпадение
•
Реорганизация
•
Западня требований
•
Команды прагматиков
1
При этом можно утешаться изречением, приписываемым контр-адмиралу д-ру Грэйсу
Хопперу: "Легче просить прощения, чем получать разрешение".

8
Глава 1
Вопросы д л я обсуждения
•
Просматривая черновик данной книги, Джон Лакос поднял следующий во­
прос: солдаты постоянно обманывали крестьян, но в результате изменений,
катализатором которых они стали, лучше стало всем. Однако, постоянно об­
манывая лягушку, вы наносите ей вред. Когда вы пытаетесь ускорить изме­
нения, то можете ли определить, варите вы суп из камней или же лягушку?
Является ли это решение субъективным или объективным?
4
Приемлемые программы
Для лучшего
добро сгубить
легко.
У. Шекспир, Король Лир, действие 1, сцена 4
Существует старый анекдот об американской фирме, котирая заказала 100 ООО ин­
тегральных схем на предприятии в Японии. В условиях контракта указывался уровень
дефектности: один чип на 10 ООО. Несколько недель спустя заказ прибыл в Америку:
одна большая коробка, содержащая тысячи интегральных схем, и одна маленькая, в ко­
торой находилось десять схем. К маленькой коробке был приклеен ярлычок с надписью
"Дефектные схемы".
Если бы у нас был такой контроль качества! Но реальный мир не позволяет нам
производить многое из того, что является действительно совершенным, — особенно
программы без ошибок. Время, технология и темперамент — все находится в сговоре
против нас.
Однако это не должно вас обескураживать. По словам Эда Йордона, автора ста­
тьи в журнале IEEE Software [You95], вы можете обучиться созданию приемлемых
программ — приемлемых для ваших пользователей, служб сопровождения и с точ­
ки зрения вашего же собственного спокойствия. Вы обнаружите, что производи­
тельность вашего труда повысилась, а ваши пользователи стали чуть-чуть счастли­
вее. Кроме того, ваши программы станут лучше за счет сокращения инкубационного
периода.
Перед тем, как пойти дальше, мы должны определиться ?.том, что собираемся ска­
зать. Фраза "приемлемый" не подразумевает неаккуратную или неудачно написанную
программу. Все удачные системы должны отвечать требованиям их пользователей.
Мы просто призываем к тому, чтобы пользователям была дана возможность участво­
вать в процессе принятия решения, если созданное вами действительно приемлемо.
Находите компромисс с пользователями
Обычно вы пишете программы для других людей. Часто вы вспоминаете о том, что хо­
рошо бы получить от них требования

## Но как часто вы спрашиваете их, а насколько хо­


рошими они хотят видеть эти программы? Иногда выбирать не из чего. Если вы рабо­
таете над передовыми технологиями, космическим челноком или низкоуровневой
Это, конечно шутка!

Прагматическая философия
9
библиотекой, которая будет широко распространяться, то требования будут более
строгими, а варианты — ограниченными. Но если вы работаете над новым продуктом,
то у вас будут ограничения другого рода. Маркетологам придется сдерживать обеща­
ния, вероятные конечные пользователи могут строить планы, основанные на дате по­
ставки программы, а ваша фирма, конечно, будет ограничена в денежных средствах.
Профессионалы не могут игнорировать требования пользователей — просто добавить
к программе новые средства или "отшлифовать" еще раз тексты программ. Мы не при­
зываем к паническим настроениям: одинаково непрофессионально обещать невероят­
ные сроки и срезать основные "технические углы" чтобы уложиться вовремя.
Сфера действия и качество создаваемой вами системы должны указываться в час­
ти системных требований.
Подсказка 7
Сделайте качество одним из пунктов требований
Часто вы будете оказываться в ситуациях, когда необходимо идти на компромисс.
Удивительно, но многие пользователи предпочтут использовать программы с некото­
рыми недоработками, но сегодня, чем год ожидать выпуска мультимедийной версии.
Многие IT-департаменты, имеющие ограничения по бюджету, могли бы согласиться с
этим утверждением. Хорошие программы (но сегодня) зачастую являются более
предпочтительными по сравнению с отличными программами (но завтра). Если вы за­
ранее дадите другим пользователям поиграться с вашей программой, то часто их от­
зывы будут способствовать выработке лучшего конечного решения (см. "Стрельба
трассирующими").
Знайте меру
В ряде случаев программирование подобно живописи)[Вы начинаете с чистого холста
и определенных базовых исходных материалов. Используете сочетание науки, искус­
ства и ремесла, чтобы определить, что же делать с нимидНабрасываете общую фор­
му, выписываете основу, затем работаете над деталями. Постоянно отступаете назад,
чтобы критически взглянуть на то, что же вы сделали. Иногда отбрасываете холст и
начинаете снова.
Но художники скажут вам, что вся тяжелая работа идет насмарку, если вы не знае­
те, в какой момент нужно остановиться. Если вы добавляете слой за слоем, деталь за
деталью, живопись может потеряться в краске.
Не стоит портить очень хорошую программу путем приукрашивания и излишней
шлифовки. Двигайтесь вперед и дайте вашей программе отстаивать свои права в те­
чение какого-то времени. Она может быть несовершенной. Не беспокойтесь, воз­
можно, она никогда не станет совершенной. (В главе 6 мы обсудим философию разра­
ботки программ в несовершенном мире.)
Другие разделы, относящиеся к данной теме:
•
Стрельба трассирующими

10
Глава 1
•
Западня требований
•
Команды прагматиков
•
Большие надежды
Вопросы д л я обсуждения
•
Обратите внимание на производителей инструментальных программных
средств и операционных систем, которыми вы пользуетесь. Можете ли вы
найти свидетельство тому, что эти компании не испытывают неудобства, по­
ставляя программное обеспечение, хотя им известно, что оно несовершен­
но? Как пользователь, вы скорее: (1) подождете, пока они устранят все
ошибки, (2) выберете усложненную версию программы и примете отдель­
ные ошибки, или (3) выберете упрощенную версию программы, но с мень­
шим числом дефектов?
•
Рассмотрите эффект разбиения на модули при поставке программного обес­
печения. Больше или меньше времени потребуется для доведения монолит­
ного программного блока до требуемого уровня качества по сравнению сис­
темой, спроектированной по модульному принципу? Можете ли вы привести
коммерческие примеры?
5
Портфель знаний
Инвестиции
в знания окупаются
лучше
всего.
Бенджамен Франклин
Ах, старина Франклин! Никогда лез в карман за многозначительным наставлением.
Если бы мы рано ложились и рано вставали, мы стали бы великими программистами,
не так ли? Ранняя птичка никогда не остается без червячка, но что при этом происхо­
дит с червячком?
Хотя в данном случае Бенджамен действительно попал в точку. Знание и опыт яв­
ляются самыми важными профессиональными активами.
К сожалению, знания и опыт представляют собой истекающие активы

## Ваше зна­


ние устаревает по мере того, как разрабатываются новые методики, языки, техноло­
гии и операционные среды. Изменение расстановки сил на рынке может сделать ваш
опыт устаревшим или полностью неприменимым. Принимая во внимание скорость, с
которой промчались годы Интернета, это может произойти довольно быстро.
По мере того как величина ваших знаний уменьшается, то же происходит с ценно­
стью вас для фирмы-работодателя или заказчика. Мы хотели бы предотвратить воз­
никновение подобной ситуации.
Истекающий актив представляет собой некий актив, чья стоимость со временем умень­
шается. Примерами могут послужить склад, доверху заполненный бананами, и билет на
бейсбол.

Прагматическая философия
11
Ваш портфель знаний
Портфелями знаний мы предпочитаем называть все факты, известные программи­
стам, об информатике, области приложений, в которых они работают, и накопленный
ими опыт. Управление портфелем знаний очень похоже на управление финансовым
портфелем:
1.
Серьезные инвесторы инвестируют регулярно — это как привычка.
2.
Диверсификация — это залог успеха в течение длительного времени.
3.
У проворных инвесторов портфель всегда сбалансирован — в нем имеются и
консервативные, и высокорисковые, высокодоходные инвестиции.
4.
Инвесторы стараются покупать ценные бумаги дешевле и продавать их доро­
же, обеспечивая тем самым максимальный возврат.
5.
Портфели нуждаются в периодическом пересмотре и повторной балансировке.
Управляйте вашим портфелем знаний, используя те же самые принципы, и ваша
карьера будет успешной.
Построение вашего портфеля
•
Инвестируйте на регулярной основе. Как и в случае финансов, необходимо
инвестировать в ваш портфель знаний регулярно. Даже если объем инвести­
ций невелик, сама по себе привычка важна, как, впрочем, и объемы. Не­
сколько примеров на эту тему приводятся в следующем разделе.
•
Инвестируйте в различные сферы. Чем больше вы знаете о различных ве­
щах, тем большую ценность вы представляете. Как минимум вы обязаны
знать плюсы и минусы конкретной технологии, с которой вы работаете в
данный момент. Но не останавливайтесь на этом. Лицо информатики меня­
ется быстро — новейшая технология сегодняшнего дня может оказаться
почти бесполезной (или, по меньшей мере, не найти спроса) завтра. Чем
больше технологий вы освоите, тем легче вам будет приспособиться к из­
менениям.
•
Управляйте риском. Технология находится в некоем диапазоне — от риско­
вых и потенциально высокодоходных до низкорисковых и низкодоходных
стандартов. Вложение всех ваших денег в высокорисковые акции, курс кото­
рых может внезапно обвалиться, и другая крайность — консервативное вло­
жение и упущение возможностей — не самые лучшие идеи. Не кладите все
"технические яйца" в одну корзину.
•
Покупайте дешевле, продавайте дороже. Обучение передовой технологии
до того, как она станет популярной, может быть столь же сложной задачей,
как найти недооцененные акции, но отдача может стать наградой. Изучение
языка Java, когда он только что появился, могло показаться рискованным, но
оно щедро вознаградило тех, кто принял это раньше всех, и сегодня они зани­
мают лидирующие позиции в данной области.

12
Глава 1
•
Пересмотр и повторная балансировка. Информатика — очень динамичная
отрасль. Новейшая технология, которую вы начали изучать в прошлом меся­
це, сегодня может устареть. Возможно, вам понадобится восстановление на­
выков по технологии баз данных, которой вы не пользовались какое-то вре­
мя. А может быть, вы смогли бы стать лучшей кандидатурой на открывшуюся
вакансию, если бы попробовали изучить другой язык...
Из всех этих директив, самой важной и самой простой в исполнении является:
Подсказка 8
Инвестируйте регулярно в ваш портфель знаний
Цели
Теперь у вас есть некоторые директивы, что и когда добавлять к вашему портфелю
знаний, как лучше приобрести интеллектуальный капитал, который будет вложен в
ваш портфель? Вот несколько предложений.
•
Учите (как минимум) по одному языку программирования каждый год.
Различные языки решают различные проблемы по-разному. Выучив не­
сколько подходов, вы можете помочь расширить ваше мышление и избежать
закоснелости. Вдобавок, изучать многие языки сейчас намного легче благо­
даря богатому выбору бесплатно распространяющегося программного обес­
печения в сети Интернет (см. Приложение А).
•
Читайте по одной технической книге ежеквартально. В книжных мага­
зинах полным-полно технической литературы по интересующим вас те­
мам или связанным с проектом, над которым вы работаете в настоящее
время. Как только это войдет у вас в привычку, читайте по одной книге в
месяц. После того как вы овладеете технологиями, которыми вы пользуе­
тесь на данный момент, расширяйте круг своих интересов и изучайте дру­
гие технологии.
•
Читайте книги, не относящиеся к технической литературе. Важно пом­
нить, что пользователями компьютеров являются люди — люди, чьи потреб­
ности вы пытаетесь удовлетворить. Не забывайте о человеческом факторе.
•
Повышайте квалификацию на курсах. Ищите интересные курсы в вашем
районе, школе или университете, а может быть, и во время грядущей техни­
ческой выставки, которая проводится в вашем городе.
•
Участвуйте в собраниях локальных групп пользователей. Но не просто
приходите и слушайте, а принимайте активное участие. Изоляция может
оказаться смертельной для вашей карьеры; разузнайте, над чем работают
люди за пределами вашей компании.
•
Экспериментируйте с различными операционными средами. Если вы ра­
ботали только в среде Windows, поиграйте со средой Unix дома (для этой
цели прекрасно подходит бесплатно распространяемая версия Unix). Если

Прагматическая философия
13
вы использовали только сборочные файлы и редактор, попробуйте интегри­
рованную среду разработчика и наоборот.
•
Оставайтесь в курсе событий.]Подпишитесь на профессиональные журна­
лы и другие периодические издания}(рекомендации приведены в Приложе­
нии А). Выберите из них те, которые покрывают технологии, отличные от ва­
шего текущего проекта.
•
Подключайтесь к информационным сетям. Хотите знать плюсы и минусы
нового языка или технологии? Группы новостей отлично подходят для поиска
практических результатов работы с ними других людей, используемого ими
жаргона и т.д. Походите по Интернету в поисках статей, платных сайтов и
любых других доступных источников информации.
Важно продолжать инвестирование. Как только вы почувствуете, что освоили но­
вый язык или фрагмент технологии, двигайтесь дальше. Изучайте другой.
Неважно, будете ли вы когда-либо использовать одну из этих технологий в проек­
те или даже не упомянете о них в своем резюме. Процесс обучения расширит ваше
мышление, открывая вас для новых возможностей и новых путей в творчестве. "Пе­
рекрестное опыление" идей важно; попытайтесь применить выученные уроки к про­
екту, над которым вы работаете в настоящее время. Даже если в вашем проекте не
используется некая технология, вы наверняка сможете позаимствовать некоторые
идеи. К примеру, ознакомьтесь с объектно-ориентированным подходом, и вы напише­
те простые программы на языке С различными способами.
Возможности обучения
Итак, вы жадно и много читаете, находитесь в курсе всех новейших разработок в ва­
шей сфере (это не так-то легко), и кто-то задает вам вопрос. У вас нет даже намека на
идею, каким должен быть ответ, но вы не признаете это открыто, как и многие.
В этот момент не останавливайтесь. Примите это как брошенный вам вызов
для поиска ответа. Спросите гуру (если в вашем офисе нет гуру, вы должны найти
его в Интернете: см. следующую врезку). Поищите в Интернете. Сходите в биб­
лиотеку
1.
Если вы не можете найти ответ самостоятельно, найдите того, кто это может. Не
бросайте это дело. Разговор с другими людьми поможет в построении вашей собст­
венной сети, и вы можете удивиться, находя по пути ответы на другие, не относящиеся
к делу проблемы. И этот старый портфель все утолщается и утолщается ...
Все это чтение и исследование требует времени, а времени уже не хватает. Так что
вам придется планировать наперед. Запаситесь литературой на то время, которое мо­
жет бездарно пропасть. Время, которое проходит в очередях на прием к врачам, мож­
но с пользой потратить на чтение литературы — но убедитесь, что вы принесли с со­
бой ваш журнал, а не замусоленную страницу из газеты 1973 года о положении в
Папуа Новой Гвинее.
В эру Интернета, многие люди, кажется, забыли о настоящих библиотеках, в которых име­
ется штат сотрудников и научные материалы.

14
Глава 1
Критическое осмысление
Последним важным пунктом является критическое осмысление того, что вы прочли
или услышали. Необходимо убедиться, что знание в вашем портфеле является точ­
ным и не поддается влиянию субподрядчика или типа носителя информации. Опасай­
тесь фанатиков, настаивающих на том, что их догма обеспечивает единственно пра­
вильный ответ — последний может быть применим или неприменим к вам и вашему
проекту.
Всегда имейте в виду силу меркантильности. Первое попадание, выданное поиско­
вой системой, не обязательно оказывается наилучшим; владелец содержимого может
просто заплатить, чтобы оказаться в начале списка. Если книжный магазин "раскру­
чивает" книгу, это вовсе не означает, что она хороша или даже популярна; за это про­
сто могли заплатить.
Подсказка 9
Критически анализируйте прочитанное и услышанное
К сожалению, простых ответов немного. Но, обладая растущим портфелем и при­
менив некоторый критический анализ к потоку изучаемой вами технической литерату­
ры, вы сможете понять и сложные ответы.
Разведение гуру и уход за ними
С глобальным принятием сети Интернет гуру внезапно стали ближе — на
расстоянии нажатия клавиши Enter. Итак, как найти гуру и вызвать его на раз­
говор?
Здесь есть несколько простых уловок.
•
Знайте точно, что вы хотите спросить, и будьте конкретным,
насколько
это возможно.
•
Формулируйте ваш вопрос внимательно и вежливо. Помните, что вы
просите одолжения; в противном случае может показаться, что вы тре­
буете ответа.
•
Как только вы сформулировали ответ, остановитесь и вновь поищите
ответ. Выхватите несколько ключевых слов и поищите их в Интернете.
Поищите подходящие списки часто з а д а в а е м ы х вопросов и ответов
на них.
•
Решите, каким о б р а з о м вы з а д а д и т е вопрос: в открытой ф о р м е или
же частным о б р а з о м . Группы новостей Usenet — п р е к р а с н о е м е с т о
встреч для экспертов практически по л ю б о й теме, но
некоторые
о п а с а ю т с я открытого х а р а к т е р а этих групп. Кроме того, вы в с е г д а
можете
отправить с о о б щ е н и е
н е п о с р е д с т в е н н о
вашему гуру
по
электронной почте. В любом с л у ч а е используйте строку темы с о о б ­
щения с о с м ы с л о м , ( С о о б щ е н и е "Нужна помощь!" не о с т а е т с я не­
замеченным.)

Прагматическая философия
15
•
Р а с с л а б ь т е с ь и наберитесь терпения. Люди заняты, и, возможно, по­
требуется несколько дней, чтобы получить конкретный ответ.
И наконец, обязательно поблагодарите всех, кто ответил вам. И если вы ви­
дите людей, задающих вопросы, на которые вы можете ответить, ответьте
взаимностью и примите участие.
Вопросы д л я обсуждения
•
На этой неделе начните учить новый язык программирования. Всегда про­
граммировали на С + + ? Попытайтесь выучить язык Smalltalk[URL 13] или
Squeak [URL 14]. Работаете с Java? Попробуйте поработать с языком Eiffel
[URL 10] или ТОМ [URL 15]. Информация о других бесплатных компилято­
рах и средах разработчиков содержится в Приложении А.
•
Начните читать новую книгу (но сначала прочтите эту книгу до конца!) Если
вы занимаетесь детальной реализацией и программированием, прочтите
книгу по проектированию и архитектуре. Если вы занимаетесь высокоуров­
невым проектированием, прочтите книгу о методиках программирования.
•
Найдите время для разговора о технологии с людьми, не участвующими в
проекте, над которым вы работаете в настоящее время, или с теми, кто не ра­
ботает в вашей фирме. Общение может проходить в кафетерии вашей фир­
мы, а может быть, стоит поискать коллег-энтузиастов на собрании локаль­
ной группы пользователей.
6
Общайтесь!
'[Лучше быть проигнорированным
вовсе, чем
недооцененным.
Мэй Уэст, Красавица
90-х,
1934
Может быть, мы способны выучить урок, преподанный мисс Уэст. Важно не только
то, что у вас есть, но и как оно упаковано.|71учшие идеи, лучшие программы или са­
мое прагматичное мышление практически не приносят результата, если вы не мо­
жете общаться с другими людьми) Без эффективного общения удачная идея может
осиротеть.
Нам, разработчикам, приходится общаться на многих уровнях. Мы проводим вре­
мя на собраниях, слушаниях и переговорах. Мы работаем с конечными пользователя­
ми, пытаясь понять их нужды. Мы пишем программы, которые передают наши наме­
рения машине и документируют наши размышления для будущих поколений
разработчиков. Мы пишем предложения и служебные записки, в которых требуем и
обосновываем предоставляемые нам ресурсы, сообщая наш статус и предлагая новые
подходы. Мы работаем ежедневно в своих командах, отстаивая наши идеи, изменяя
существующую практику и вводя новую. Большая часть дня проходит в общении, по­
этому нам необходимо овладеть его искусством.
Мы обобщили ряд идей, которые находим полезными.

16
Глава 1
Знайте то, что вы хотите сказать
Возможно, самой трудной частью более формальных стилей общения, используемых
в бизнесе, является выработка именно того, что вы хотите сказать. Беллетристы в де­
талях намечают сюжет книги перед тем, как они начать свой труд, но люди, состав­
ляющие технические документы, часто рады сесть за клавиатуру, напечатать " 1 . Вве­
дение" и затем набирать все, что придет им в голову.
Планируйте то, что вы хотите сказать. Напишите "рыбу". Затем спросите себя:
"Не противоречит ли это тому, что я пытаюсь высказать?" Совершенствуйте это,
пока не наступит момент выступления.
Этот подход применим не только к написанию документов. Когда вы готовитесь к
важной встрече или телефонному разговору с важным заказчиком, законспектируйте
идеи, которыми собираетесь обменяться, и разработайте несколько стратегий для
четкого их изложения.
Знайте вашу
аудиторию
Вы общаетесь только в том случае, если передаете информацию. Для этого вам необ­
ходимо осознавать потребности, интересы и способности вашей аудитории. Все нам
приходилось присутствовать на собраниях, где нахал-разработчик затуманивает глаза
вице-президенту по маркетингу долгим монологом о заслугах некоторой скрытой тех­
нологии. Это не общение: это просто разговоры и это утомляет
1.
Составьте устойчивый
психологический
образ
вашей
аудитории.
Акростих
WISDOM, показанный на рис. 1.1, может помочь в этом.
Например, вы собираетесь предложить интернет-систему, позволяющую конеч­
ным пользователям представлять отчеты об ошибках. Об этой системе можно расска­
зать по-разному в зависимости от аудитории. Конечные пользователи обрадуются
тому, что смогут представлять отчеты об ошибках 24 часа в сутки, не занимая телефо­
на. Отдел маркетинга сможет использовать этот факт в целях увеличения объема
продаж. Менеджеры в отделе поддержки будут счастливы по двум причинам: можно
будет обойтись меньшим числом сотрудников, и генерация отчетов о возникающих
проблемах будут автоматизирована. И, наконец, разработчики смогут приобрести
опыт в работе с клиент-серверными интернет-технологиями и новым ядром баз дан­
ных. Выступая перед каждой из этих групп с отдельной трибуны, вы добьетесь того,
что они станут неравнодушными к вашему проекту.
Выбирайте подходящий
момент
Итак, наступила пятница, конец рабочего дня, неделю назад на фирме прошла ауди­
торская проверка. Младший ребенок вашей начальницы попал в больницу, на улице
идет проливной дождь, и дорога домой представляется сущим кошмаром. Не самое
лучшее время для просьб о наращивании памяти на вашем компьютере.
В оригинале: английское слово annoy происходит от старофранцузского enui, что также оз­
начает "наскучить".

Прагматическая философия
17
Необходимо выяснить для себя, каковыми являются приоритеты аудитории, чтобы
лучше понять то, что она хочет услышать от вас. Поймайте менеджера, получившего
выговор от шефа, потому что потерялась часть исходного текста программы, и вы
найдете в его лице слушателя, который лучше воспринимает ваши идеи о централизо­
ванных БД данных исходных текстов. То, что вы говорите, должно быть уместным по
времени и содержанию. Иногда для этого достаточно лишь задать вопрос типа: "Удоб­
но ли сейчас поговорить о ...?"
What do you want them to learn? (Чему вы хотите их научить)
What is their interest in what you have got to say? (Какова их заинтересованность в вашей речи?)
How sophisticated are they? (Насколько искушена ваша аудитория?)
How much detail do they want? (Насколько детальным должно быть выступление?)
Whom do you want to own the information? (Кто должен обладать информацией?)
How can you motivate them to listen to you? (Как мотивировать слушателей?)
Буквы оригинала складываются в слово "Wisdom" — мудрость (англ.)
Р ис. 1.1.
Акростих WISDOM — о понимании
аудитории
Выбирайте стиль
Определите стиль подачи материала в соответствии с требованиями аудитории. Од­
ним хочется формального брифинга в стиле "только факты". Другим нравятся долгие,
обширные беседы, перед тем как перейти к делу. Что касается печатных материалов,
то одни любят получать большие переплетенные отчеты, тогда как другие ожидают
простой записки или сообщения по электронной почте. Если сомневаетесь, спраши­
вайте.
Однако следует помнить, что вы — лишь одна половина коммуникационной тран­
закции. Если кто-нибудь говорит, что ему необходимо описать что-либо в одном абза­
це, а вы видите, что это можно сделать лишь в объеме нескольких страниц, скажите
ему об этом. Помните, этот вид отклика также является формой общения.
Встречают по одежке
Ваши идеи важны. Они заслуживают хорошего способа их подачи вашей аудитории.
Многие разработчики (и их менеджеры) при подготовке письменных документов
сосредоточены исключительно на содержании. Мы думаем, что это ошибочно. Любой
шеф-повар скажет вам, что вы можете корпеть в кухне целыми часами и затем обра­
тить в прах все ваши усилия неправильной сервировкой стола.
Сегодня нет оправдания подготовке небрежных печатных материалов. Современ­
ные текстовые процессоры (наряду с настольными издательскими системами, такими,
как L A T E X И troff) могут печатать великолепные выходные документы. Вам необходи­
мо выучить лишь несколько основных команд. Если ваш текстовый процессор поддер­
живает стили, используйте их. (Ваша фирма могла уже определить стили, которыми
вы можете пользоваться.) Выучите, как задаются верхние и нижние колонтитулы.
В поисках идей стиля и макета, взгляните на образцы документов, включенные в тек­
стовый процессор. Проверьте правописание, вначале автоматически и затем вруч-

18
Глава 1
ную. Ведь в право писании мокнут встреть си и такие ушиб кий, кто торты про грамма
не смолит у ловить.
Привлекайте свою аудиторию
Мы часто обнаруживаем, что документы, которые мы составляем, прекращают свое
существование, будучи менее важными, чем процесс их составления. Если возможно,
привлекайте ваших читателей с момента появления черновиков документов. Получи­
те их отклики и используйте их идеи. Вы построите хорошие рабочие взаимоотноше­
ния и наверняка улучшите составленный документ.
Умейте слушать
Существует одна методика, которую вы должны использовать, если хотите, чтобы
люди слушали вас: прислушивайтесь к ним. И в ситуации, когда вы располагаете
всей информацией, и во время формального собрания, на которой вы держите речь
переддвадцатью руководителями — если вы не будете слушать их, они не будут слу­
шать вас.
Вдохновляйте людей для беседы, задавая вопросы или заставляя их подытожить
сказанное вами. Превратите собрание в диалог, и вы сможете выделить что-либо бо­
лее эффективно. Может быть, вы почерпнете что-то и для себя.
Обращайтесь к людям
Если вы задаете кому-нибудь вопрос, и вам не отвечают, то вы полагаете, что данный
человек невежлив. Но как часто вы не можете ответить людям, когда они посылают
вам сообщение по электронной почте или служебную записку, пытаясь получить ин­
формацию, или требуют какого-либо действия? Всегда отвечайте на сообщения элек­
тронной почты и голосовые сообщения, даже если ваш ответ звучит просто: "Я вер­
нусь к вам с этим позже". Если вы держите людей в курсе, они намного легче
прощают случайные промахи и чувствуют, что о них не забыли.
Подсказка 10
Важно, что говорить и как говорить
Поскольку вы не работаете в безвоздушном пространстве, вам необходимо
уметь общаться. Чем эффективнее это общение, тем более влиятельным вы стано­
витесь.
Связь по электронной почте
Все, что с к а з а н о о коммуникации в письменном виде, одинаково применимо
и к электронной почте. Электронная почта с т а л а основой внутрикорпоратив­
ных и межкорпоративных коммуникаций. Электронная почта используется
при обсуждении контрактов, решении споров и в качестве свидетельства в

Прагматическая философия
19
с у д е . Но, в силу некоторых причин, люди, которые никогда бы не выслали
убогий бумажный документ, позволяют с е б е распространять отвратительно­
го вида сообщение по всему миру.
Наши подсказки относительной электронной почты довольно просты:
•
Перед тем как щелкнуть мышкой н а кнопке "^end (Отправить), тщатель­
но проверьте текст.
•
Проверьте
правописание.
•
Используйте простой
формат. Некоторые
люди читают
сообщения
электронной почты, используя пропорциональные шрифты, так что кар­
тинки, которые вы старательно создавали при помощи символов ASCII,
для них будут выглядеть так, как будто это п и с а л а "курица лапой".
•
Используйте форматы RTF или HTML, е с л и вы точно знаете, что все полу­
чатели смогут прочесть послание. Простой текст универсален.
•
С т а р а й т е с ь сводить цитирование к минимуму. Никто не любит получать
н а з а д свое собственное сообщение в 100 строк, снабженное помет­
кой " с о г л а с е н " .
•
Если вы цитируете сообщения других людей, убедитесь, что они атри­
бутированы, и цитируйте их в тексте (это лучше, чем вложение).
•
Не используйте обидных сообщений, е с л и не хотите, чтобы позже они
вернулись, лишив в а с покоя.
•
П е р е д отправкой необходимо проверить список а д р е с а т о в . Статья в
недавнем номере "Уолл-стрит джорнэл" р а с с к а з ы в а е т о служащем,
который взялся распространять критические
высказывания о своем
ш е ф е по отделу, не подумав о том, что а д р е с ш е ф а был включен в
список рассылки.
•
Архивируйте и организуйте вашу электронную почту — как получае­
мые, так и отсылаемые материалы.
Как обнаружили служащие фирм Microsoft и Netscape во время р а с с л е д о ­
вания Министерства юстиции С Ш А (1999 г.), электронная почта — это б е с ­
смертно. Постарайтесь заботиться об электронной почте так, как вы заботи­
тесь о любой написанной записке или отчете.
Другие разделы, относящиеся к данной теме:
•
Прототипы и памятные записки
•
Команды прагматиков
Вопросы д л я обсуждения
•
Есть несколько хороших книг, описывающих взаимодействие внутри команд
разработчиков [Bro95, МсС95, DL99], Следует обратить на это особое вни-

Глава 1
мание и попытаться прочесть все три книги в течение следующих 18 месяцев.
В дополнение к этому, книга "Dinosaur Brains" [ВегЭб] посвящена эмоцио­
нальному багажу, который мы вносим в рабочую среду.
В следующий раз, когда вам придется проводить презентацию или писать
служебную записку, отстаивающий некую позицию, до начала работы вос­
пользуйтесь акростихом WISDOM. Посмотрите, поможет ли это вам в пред­
ставлении того, с чем вы выступаете. Если это возможно, поговорите со сво­
ей аудиторией после выступления,
и посмотрите,
насколько
точной
оказалась ваша оценка их потребностей.

Глава 2
Прагматический
подход
Существует ряд подсказок и уловок, применимых ко всем уровням разработки про­
грамм: идеи, которые почти аксиоматичны, и процессы, которые практически универ­
сальны. Однако эти подходы редко документируются как таковые; в основном они
фиксируются как случайные высказывания в дискуссиях по проектированию, руково­
дству проектами или программированию.
В этой главе эти идеи и процессы сводятся воедино. Первые два раздела, "Пороки
дублирования" и "Ортогональность", тесно свызаны между собой. Первый предосте­
регает от дублирования знания в ваших системах, второй — от растаскивания едино­
го фрагмента знания по многим компонентам системы.
Все вокруг меняется очень быстро, становится все труднее и труднее поддержи­
вать приложения на должном уровне. В разделе "Обратимость" рассматриваются не­
которые методики, позволяющие изолировать проекты от изменяющейся окружаю­
щей среды.
Следующие два раздела также связаны между собой. В разделе "Стрельба трасси­
рующими", говорится о стиле разработки программ, позволяющем одновременно
осуществлять сбор требований, тестировать проектные решения и реализовывать
текст программы. Если для вас это звучит слишком хорошо, чтобы быть правдой, то
так оно и есть: разработки в стиле "Стрельба трассирующими" применимы не всегда.
Для последнего случая в разделе "Прототипы и памятные записки" показано, как при
тестировании архитектур, алгоритмов, интерфейсов и идей используются прототипы.
По мере того как информатика медленно становится зрелой, разработчики изо­
бретают языки программирования все более высокого уровня. Поскольку компиля­
тор, работающий по принципу "сделай так, как приказано', еще не изобретен, в раз­
деле "Языки, отражающие специфику предметной области" представлен ряд более
скромных предложений, которые можно реализовать для себя.
Ну и наконец, все мы работаем в мире с ограниченным временем и ресурсами. Оба
этих недостатка переживаются легче (радуя ваше начальство), если поднатореть в
оценке продолжительности какого-либо дела, о чем и говорится в разделе "Оценка".

22
Глава 2
Держа в голове эти фундаментальные принципы, можно создать программу, кото­
рая будет лучше, быстрее и устойчивее. Ее можно даже сделать на вид более простой.
7
Пороки дублирования
Капитан Джеймс Т. Кирк больше всего любил отключать хищный искусственный ин­
теллект, вводя в компьютер два противоречащих друг другу фрагмента знания. К не­
счастью, этот принцип оказывается столь же эффективным при доведении вашей
программы до обморочного состояния.
Программисты собирают, организуют, сопровождают и связывают воедино зна­
ние. Знание документируется в требованиях, воплощается в запускаемых программах
и используется для контроля в ходе тестирования.
К сожалению, знание нестабильно. Оно изменяется — часто очень быстро. Пони­
мание некоего требования может измениться после встречи с заказчиком. Прави­
тельство изменяет административные положения, и некая бизнес-логика устаревает.
Тесты могут показать, что выбранный алгоритм не будет работать. Вся эта нестабиль­
ность означает, что мы проводим большую часть времени в режиме сопровождения,
осуществляя реорганизацию знания и выражая его по-новому в опекаемых нами сис­
темах.
Большинство людей полагает, что сопровождение начинается в момент выпуска
приложения в свет и означает устранение ошибок и улучшение характеристик. Мы ду­
маем, что эти люди ошибаются. Программисты постоянно находятся в режиме сопро­
вождения. Наше понимание изменяется день ото дня. Новые требования возникают по
мере того, как мы проектируем или создаем текст программы. Возможно, изменяется
операционная система. Какой бы ни была причина, сопровождение является не дис­
кретным видом деятельности, а рутинной частью процесса разработки в целом.
Когда мы осуществляем сопровождение, нам приходится отыскивать и изменять
представления о предметах — капсулах знания, заложенных в приложение. Пробле­
ма состоит в том, что тиражировать знание в требованиях, процессах и программах,
которые мы разрабатываем, легко, и, когда мы поступаем подобным образом, возни­
кает призрак сопровождения — тот самый, который начинает делать свое черное
дело задолго до отправки готового приложения заказчику.
Мы полагаем, что единственно надежным способом разработки программ и облег­
чения их понимания и сопровождения является следование принципу "Не повторяй
самого себя" (далее DRY = Don't Repeat Yourself. — Прим.
пер.):
КАЖДЫЙ ФРАГМЕНТ ЗНАНИЯ ДОЛЖЕН ИМЕТЬ ЕДИНСТВЕННОЕ. ОДНОЗНАЧНОЕ,
НАДЕЖНОЕ ПРЕДСТАВЛЕНИЕ В СИСТЕМЕ.
Подсказка 11
Не повторяй самого себя
Альтернативой является представление одного и того же предмета в двух или бо­
лее местах. Если меняется одно, придется вспоминать и об изменении других, или же

Прагматический подход
23
ваша программа (подобно компьютерам пришельцев) будет поставлена на колени
ввиду противоречий. Вопрос не в том, вспомните ли вы о необходимом изменении или
нет; вопрос в том, когда вы об этом забудете.
Вы обнаружите, что принцип "Не повторяй самого себя" будет время от времени
появляться на протяжении всей книги, часто в контексте, который не имеет ничего
общего с программированием. Мы полагаем, что этот принцип является одним из
наиболее важных инструментов в арсенале программиста-прагматика.
В этом разделе мы обрисуем проблемы, связанные с дублированием, и предложим
общие стратегии по тому, как с ним справиться.
Как возникает дублирование?
Большинство наблюдаемых явлений дублирования подпадают под одну из следующих
категорий:
•
Навязанное дублирование. Разработчики чувствуют, что у них нет выбо­
ра — им кажется, что дублирования требует среда окружения.
•
Неосознанное дублирование. Разработчики не осознают, что они тиражи­
руют информацию.
•
Нетерпеливое дублирование. Разработчики ленятся и осуществляют дуб­
лирование, потому что им кажется, что так проще.
•
Коллективное дублирование. Фрагмент информации тиражируется не­
сколькими членами одной команды разработчиков (или нескольких команд)
Рассмотрим эти четыре категории дублирования более подробно.
Навязанное дублирование
Иногда кажется, что нас заставляют осуществлять дублирование. Стандарты, по ко­
торым делается проект, могут потребовать наличия документов, содержащих дубли­
рованную информацию, или документов, которые тиражируют информацию в тексте
программы. При наличии нескольких целевых платформ каждая из них требует от­
дельных языков программирования, библиотек и сред разработки, что заставляет нас
тиражировать общедоступные определения и процедуры. Сами языки программиро­
вания требуют наличия ряда конструкций, которые тиражируют информацию. Все мы
находились в ситуациях, когда были не в силах избежать дублирования. И все же за­
частую находятся способы сохранения каждого фрагмента знания в одном и том же
месте — в соответствии с принципом DRY — и облегчения нашей жизни одновре­
менно. Вот некоторые методики:
Множественные
представления
информации.
На уровне создания текста
программы нам часто необходимо представить одну и ту же информацию в различных
формах. Возможно, мы пишем приложение "клиент—сервер" с использованием раз­
личных языков для клиента и сервера и должны представить некоторую общедоступ­
ную конструкцию и на первом, и на втором. Возможно, нам необходим класс, чьи ат­
рибуты отражают схему таблицы базы данных. Может быть, вы пишете книгу и

24
Глава 2
хотите включить в нее фрагменты программ, которые вы также хотели бы скомпили­
ровать и протестировать.
Немного изобретательности — и дублирование вам не понадобится. Зачастую от­
вет сводится к написанию простого фильтра или генератора текста программы. Кон­
струкции с использованием нескольких языков могут быть собраны из обычного
представления метаданных, используя простой генератор текста программ всякий раз
при осуществлении сборки программы (пример этого показан на рис. 3.4). Определе­
ния класса могут быть сгенерированы автоматически из интерактивной схемы базы
данных или из метаданных, используемых для построения схемы изначально. Фраг­
менты программ в этой книге вставлялись препроцессором всякий раз при формати­
ровании текста. Уловка состоит в том, чтобы сделать процесс активным: это не может
быть однократным преобразованием, в противном случае мы опять окажемся в поло­
жении людей, тиражирующих данные.
Документация
в тексте
программы.
Программистов учат комментиро­
вать создаваемый ими текст программы: удачный текст программы снабжен боль­
шим количество комментариев. К сожалению, им никогда не объясняли, зачем
тексту программы нужны комментарии: неудачному текст/ требуется большое ко­
личество комментариев.
Принцип DRY говорит о сохранении низкоуровневого знания в тексте программы,
частью которого он является, и о сохранении комментариев для других, высокоуров­
невых толкований. В противном случае мы тиражируем знание, и каждое изменение
означает изменение и в тексте программы, и в комментариях. Комментарии неизбеж­
но устаревают, а ненадежные комментарии хуже, чем отсутствие комментариев вооб­
ще. (Более подробная информация о комментариях содержится в разделе "Все эти
сочинения".)
Документация
и текст программы.
Вы пишете документацию, затем соз­
даете текст программы. Что-то меняется, и вы исправляете документацию и обнов­
ляете текст. И документация, и текст содержат представления одного и того же зна­
ния. И все мы знаем, что в суматохе, когда приближается контрольный срок, а
важные заказчики высказывают требования, обновление документации стараются
отложить.
Однажды Дэйв Хант работал над переключателем телекса на разные языки. Впол­
не понятно, что заказчик требовал исчерпывающей тестовой спецификации, а также
того, чтобы программы проходили полное тестирование при поставке каждой новой
версии. Чтобы убедиться в том, что тесты находились в точном соответствии со спе­
цификацией, команда сгенерировала их автоматически из самого документа. Когда за­
казчик вносил исправления в спецификацию, автоматически изменялся и тестовый
набор программ. Команда убедила заказчика, что, после того как процедура прошла
нормально, генерация приемочных тестов длилась лишь несколько секунд.
Языковые
аспекты.
Многие языки навязывают значительное дублирование в
исходном тексте программы. Зачастую это происходит, когда язык отделяет интер­
фейс модуля от его реализации. Языки С и С + + используют файлы заголовка, кото­
рые тиражируют имена и печатают информацию о переменных экспорта, функциях и

Прагматический подход
25
классах (для С + + ). Язык Object Pascal даже тиражирует эту информацию в том же
самом файле. Если вы используете удаленные вызовы процедур или технологию
CORBA[URL 29], то при этом происходит дублирование интерфейсной информации в
спецификации интерфейса и тексте программы, его реализующей.
Не существует простой методики, позволяющей преодолеть требования языка. В
то время как некоторые среды разработки скрывают потребность в файлах заголовка,
генерируя их автоматически, а язык Object Pascal позволяет вам сокращать повто­
ряющиеся объявления функции, в общем случае вы используете то, что вам дано. По
крайней мере, для большинства языковых аспектов, файл заголовка, который проти­
воречит реализации, будет генерировать некоторое сообщение об ошибке компиля­
ции или компоновки.
Также стоит подумать о комментариях в файлах заголовка и реализации. В дубли­
ровании комментария функции или заголовка класса в этих двух файлах нет абсолют­
но никакого смысла. Файлы заголовка используются для документирования аспектов
интерфейса, а файлы реализации — для документирования некоторых подробностей,
которых пользователи вашей программы знать не должны.
Неумышленное дублирование
Иногда дублирование происходит в результате ошибок в проекте.
Рассмотрим пример из области транспорта. Пусть аналитик установил, что, наря­
ду с прочими атрибутами, грузовик имеет тип, номерной знак и водителя. Аналогично,
маршрут доставки грузка представляет собой сочетание маршрута, грузовика и води­
теля. Мы создаем программы для некоторых классов, основанных на этом представ­
лении.
Но что происходит, если водитель по имени Салли заболевает и приходится менять
водителя? Классы Truck и DeliveryRoute содержат описание водителя. Какой из них
мы должны изменить? Ясно, что это дублирование неудачно. Нормализуйте его в со­
ответствии с базовой бизнес-моделью — необходим грузовику водитель как часть ба­
зового набора атрибутов? А маршрут? Возможно, необходим третий объект, который
связывает воедино водителя, грузовик и маршрут. Каким бы не было окончательное
решение, стоит избегать этого типа ненормализованных "энных,.
Есть не столь очевидный тип ненормализованных данных, который имеет место
при наличии множественных взаимозависимых элементов данных. Рассмотрим класс,
представляющий отрезок:
class Line {
Public
Point
start
Point end
double length
} ;
На первый взгляд этот класс может показаться разумным. Отрезок явно имеет на­
чало и конец и всегда будет иметь длину (даже если она нулевая). Но происходит дуб­
лирование. Длина определяется начальной и конечной точками: при изменении одной
из точек длина меняется. Лучше сделать длину вычисляемым полем:

26
Глава 2
class Line {
public
Point start
Point end
double lengthO { return start.distanceTo(end); }
};
Позже, в ходе разработки, вы можете нарушить принцип "Не повторяй самого
себя" в силу требований к производительности. Зачастую это происходит, когда вам
необходимо кэшировать данные во избежание повторения дорогостоящих операций.
Эта уловка призвана ограничить воздействие. Нарушение принципа не подвержено
воздействию внешнего мира: лишь методы в пределах класса должны поддерживаться
в надлежащем состоянии.
class Line {
private:
bool changed;
double length
Point start;
Point end;
public:
void setStart(Point p) { start = p; changed = true; }
void setEnd(Point p)
{ end
= p; changed = true; }
Point getStart(void)
{ return start; }
Point getEnd(void)
{ return end;
}
double getLength() {
if (changed) {
length = start.distanceTo(end);
changed = false;
}
return length;
Этот пример также иллюстрирует важный аспект для объектно-ориентированных
языков типа Java и С + + . Там, где это возможно, всегда используются функции сред­
ства доступа — для чтения и записи атрибутов объектов

## Это облегчает добавление


функциональных возможностей (типа кэширования) в будущем.
Нетерпеливое дублирование
Каждый проект испытывает давление времени — силы, которая может двигать луч­
шими из нас, заставляя идти напролом. Вам нужна подпрограмма, подобная уже на­
писанной вами? Вас соблазнит возможность копирования и внесения лишь несколь­
ких изменений. Вам нужно значение, чтобы представить максимальное число точек?
Применение функций средств доступа дополняет книгу Мейера "Object-Oriented Software
Construction" [Mey97b], в которой говорится, что "все службы, обеспечиваемые неким мо­
дулем, должны быть доступны за счет универсальной системы обозначений, которая отлича­
ется надежностью, независимо от того, хранятся ли эти службы в памяти или вычисляются".

Прагматический подход
27
Если я изменю файл заголовка, целый проект должен быть перестроен. Может, мне
просто использовать константы в этом месте? ... и в этом ... и в том... Нужен класс,
подобный тому, который есть в системе поддержки Java? У вас в распоряжении име­
ется исходный текст, так почему бы просто его не скопировать и не внести необходи­
мые изменения (несмотря на лицензионное соглашение)?
Если вы чувствуете, что поддаетесь искушению, вспомните банальный афоризм:
"Тише едешь — дальше будешь". Экономя несколько секунд в данный момент, позже
вы потенциально теряете целые часы. Подумайте об аспектах, относящихся к "про­
блеме 2000 года". Многие из них были вызваны ленью разработчиков, которые не
сделали параметризацию размера полей даты (или не внедрили централизованные
библиотеки служб доступа к дате).
Нетерпеливое дублирование легко обнаруживается и устраняется, но это требует
дисциплины и желания потратить время в настоящий момент, чтобы избежать голов­
ной боли впоследствии.
Коллективное дублирование
Самый трудный в обнаружении и обработке тип дублирования — коллективный —
возникает между различными разработчиками проекта. Целые наборы функциональ­
ных возможностей могут тиражироваться по неосторожности, и это дублирование мо­
жет оставаться незамеченным на протяжении многих лет, что приводит к возникнове­
нию проблем при сопровождении. Нам известно, как в одном из штатов США
компьютерные системы, установленные в правительственных учреждениях, проверя­
лись на наличие "проблемы 2000 года". Аудиторы обнаружили свыше 10 000 про­
грамм, каждая из которых по-своему осуществляла проверку правильности номера
карточки социального страхования.
На высоком уровне, с проблемой можно справиться при наличии ясного проектно­
го решения, сильного технического руководителя проекта (см. "Команды прагмати­
ков") и хорошо осознанного разделения обязанностей в пределах проекта. Однако на
уровне модуля проблема является более коварной. Обычно необходимые функцио­
нальные возможности или данные, которые не относятся к очевидной области ответ­
ственности, могут реализовываться много раз.
Мы полагаем, что лучший способ справиться с SVHM — поощрять активное и
частое взаимодействие между разработчиками. Устраивайте форумы, для обсуж­
дения общих проблем. (При работе над прошлыми проектами мы организовывали
конференции в сети, чтобы позволить разработчикам обмениваться идеями и зада­
вать вопросы. Этим обеспечивается ненавязчивый способ общения — даже на не­
скольких сайтах — при сохранении непрерывной хронологии всего высказанного.)
Назначьте одного из членов команды библиотекарем проекта, чьей обязанностью
будет обеспечение обмена знаниями. Организуйте специальное место в каталоге с
исходными текстами, в котором будут сохраняться сервисные подпрограммы и
скрипты. И обратите особое внимание на чтение исходного текста и документации
других членов команды, неформально или при анализе текста программы. При
этом вы отнюдь не шпионите за ними — вы учитесь у них. И помните, что доступ к
тексту программы осуществляется по взаимной договоренности — вас не должно

28
Глава 2
коробить, если и другие члены команды сосредоточенно изучают (или вынюхива­
ют?) ваш текст программы.
Подсказка 12
Сделайте так, чтобы программу можно было легко
использовать повторно
Все, что вы пытаетесь делать, способствует развитию среды, где проще находить и
многократно использовать существующий материал, чем создавать его самому. Но
если это непросто,
люди просто не будут этого делать.
И если вы будете не в
состоянии многократно использовать этот материал, вы рискуете заняться дублиро­
ванием знания.
Другие разделы, относящиеся к данной теме:
•
Ортогональность
•
Работа с текстом
•
Генераторы исходных текстов
•
Реорганизация
•
Команды прагматиков
•
Вездесущая автоматизация
и Все эти сочинения
8
Ортогональность
Ортогональность очень важна, если вы хотите создавать системы, которые легко под­
даются проектированию, сборке, тестированию и расширению. Однако этому прин­
ципу редко обучают непосредственно. Часто он является лишь скрытым достоинством
других разнообразных методик, которые вы изучаете. Это неправильно. Как только
вы научитесь непосредственно применять принципы ортогональности, вы сразу заме­
тите, как улучшилось качество создаваемых вами систем.
Что такое ортогональность?
Термин "ортогональность" заимствован из геометрии. Две линии являются ортого­
нальными, если они пересекаются под прямым углом, например оси координат на гра­
фике. В терминах векторной алгебры две такие линии
являются независимыми. Если двигаться вдоль одной
из линий, то проекция движущейся точки на другую
линию не меняется.
Этот термин был введен в информатике для обо­
значения некой разновидности независимости или
несвязанности. Два или более объекта ортогональны,
перемещение
параллельно оси X
проекция на ось Y
не меняется

Прагматический подход
29
если изменения, вносимые в один из них, не влияют на любой другой. В грамотно
спроектированной системе программа базы данных будет ортогональной к интерфей­
су пользователя: вы можете менять интерфейс пользователя без воздействия на базу
данных и менять местами базы данных, не меняя интерфейса.
Перед тем как рассмотреть преимущества ортогональных систем, рассмотрим сис­
тему, которая не является ортогональной.
Неортогональная
система
Итак, вы находитесь в экскурсионном вертолете, совершающем полет над Гранд-
Каньоном, когда пилот, который совершил ошибку, наевшись рыбы за обедом, вне­
запно вскрикивает и теряет сознание. По счастливой случайности это происходит,
когда вы парите на высоте 30 метров. Вы догадываетесь, что рычаг управления об­
щим шагом несущего винта
1 обеспечивает подъем машины, так что, если его слегка
опустить, вертолет начнет плавно снижаться. Однако когда вы пытаетесь сделать
это, то осознаете, что жизнь — не такая уж простая штука. Вертолет клюет носом,
и вас начинает вращать по спирали влево. Внезапно вы понимаете, что управляете
системой, в которой каждое воздействие имеет побочные эффекты. При нажатии на
левый рычаг вам придется сделать уравновешивающее движение назад правым ры­
чагом и нажать на правую педаль. Но при этом каждое из этих действий вновь по­
влияет на все органы управления. Неожиданно вам приходится жонглировать неве­
роятно сложной системой, в которой любое изменение влияет на все остальные
управляющие воздействия. Вы испытываете феноменальную нагрузку: ваши руки и
ноги находятся в постоянном движении, пытаясь уравновесить все взаимодействую­
щие силы.
Органы управления вертолетом определенно не являются ортогональными.
Преимущества ортогональности
Как показывает пример с вертолетом, неортогональные системы сложнее изменять и
контролировать. Если составляющие системы отличаются высокой степенью взаимо­
зависимости, то невозможно устранить какую либо неисправность лишь на локаль­
ном уровне.
Подсказка 13
Исключайте взаимодействие между объектами,
не относящимися друг к другу
1
В вертолете имеется четыре основных органа управления. Рычаг управления циклическим
шагом несущего винта находится справа от пилота. При его перемещении вертолет дви­
жется в соответствующем направлении. Слева от пилота расположен рычаг управления
общим шагом несущего винта. Если потянуть за него, то произойдет увеличение шага на
всех лопастях и вертолет начнет подниматься. На конце рычага управления общим шагом
расположен сектор газа. И наконец, есть две ножных педали, которые изменяют тягу на
рулевом винте и способствуют повороту вертолета.

30
Глава 2
Мы хотим спроектировать компоненты, которые являются самодостаточными:
независимыми, с единственным, четким назначением; в книге Йордона и Константи­
на [ YC96] это явление называется сцеплением (cohesion). Когда компоненты изоли­
рованы друг от друга, вы уверены, что можно изменить один из них, не заботясь об
остальных. Пока внешние интерфейсы этого компонента остаются неизменными,
вы можете быть спокойны, что не создадите проблем, которые распространятся по
всей системе.
При создании ортогональных систем у вас появятся два больших преимущества:
увеличение производительности и снижение риска.
Увеличение
производительности
•
Изменения в системе локализуются, поэтому периоды разработки и тестиро­
вания сократятся. Легче написать относительно небольшие, самодостаточ­
ные компоненты, чем один большой программный модуль. Простые компо­
ненты могут быть спроектированы, запрограммированы, протестированы и
затем забыты — не нужно непрерывно менять существующий текст по мере
того, как к нему добавляются новые фрагменты.
•
Ортогональный подход также способствует многократному использованию
компонентов. Если компоненты имеют определенную, четкую сферу ответ­
ственности, то они могут комбинироваться с новыми компонентами теми
способами, которые не предполагались при их первоначальной реализации.
Чем меньше связанность в ваших системах, тем легче их перенастроить и
провести их обратное проектирование.
•
При комбинировании ортогональных компонентов происходит едва замет­
ное увеличение производительности. Предположим, что один компонент
способен осуществлять М различных операций, а второй — N различных
операций. Если эти компоненты ортогональны и комбинируются, то в сумме
они способны осуществить М х N различных операций. Но если два компо­
нента не являются ортогональными, то они будут перекрываться и результат
их действия будет меньшим по сравнению с ортогональными компонентами.
Вы получаете большее количество функциональных возможностей в пере­
счете на единичное усилие, если комбинируете между собой ортогональные
компоненты.
Снижение риска
Ортогональный подход приводит к снижению уровня риска, присущего любой раз­
работке.
•
Ошибочные фрагменты текста программы изолируются. Если модуль содер­
жит ошибку, то вероятность ее распространения на всю систему уменьшает­
ся. Кроме того, ошибочный фрагмент может быть извлечен и заменен новым
(исправленным).

Прагматический подход
31
•
Конечный продукт (система) становится менее хрупким. Проблемы, появ­
ляющиеся при внесении небольших изменений и устранении недочетов на
определенном участке, не проходят дальше этого участка.
•
Ортогональная система способствует повышению качества тестирования,
поскольку облегчается проектирование и тестирование отдельных ее компо­
нентов.
•
Вы не будете слишком сильно привязаны к определенному субподрядчику,
программному продукту или платформе, поскольку интерфейсы между ком­
понентами, производимыми фирмами-субподрядчиками, не будут играть
главенствующей роли в проекте.
Рассмотрим некоторые из способов, при помощи которых вы сможете внедрить
принцип ортогональности в ванту работу.
Проектные группы
Приходилось ли вам замечать, насколько эффективно работают одни проектные ко­
манды, все члены которых знают, что делать, и полностью отдают себя делу, тогда как
в других командах сотрудники постоянно препираются между собой и не собираются
нив чем уступать друг другу?
Зачастую это не что иное, как проблема ортогональности. Если команды организо­
ваны с большим числом перекрытий, то сотрудники путают свои должностные обя­
занности. Для любого изменения необходимо собирать всю команду, поскольку оно,
может быть, затронет любого.
Как разбить команду на группы с четкими обязанностями и минимальным перекры­
тием? На этот вопрос нет простого ответа. В некоторой степени это зависит от проекта
и вашего анализа областей, которые в перспективе могут измениться. Это также зави­
сит от людей находящихся в вашем распоряжении. Мы предпочитаем отделять инфра­
структуру от приложения. Каждому из основных инфраструктурных компонентов (база
данных, интерфейс связи, промежуточное программное обеспечение, и т.д.) приписы­
вается ему только принадлежащая группа. Подобным образом производится и понят­
ное разделение функциональных возможностей приложения. После этого мы изучаем
людей, которые имеются в нашем распоряжении на данный момент (или планируем их
появление в будущем), и сообразно этому корректируем состав групп.
Вы можете неформально определить уровень ортогональности структуры проект­
ной команды. Для этого просто посмотрите, скольких людей необходимо привлечь к
обсуждению каждого изменения, требуемого со стороны. Чем больше эта цифра, тем
ниже уровень ортогональности группы. Отсюда ясно, что ортогональная команда ра­
ботает более эффективно. (Высказав это, мы тем самым поощряем стремление со­
трудников более мелких подразделений постоянно общаться друг с другом).
Проектирование
Большинство разработчиков знакомо с потребностью в проектировании орто­
гональных систем, хотя они наверняка используют термины "модульный", "компо-

32
Глава 2
нентно-ориентированный" и "многоуровневый" для описания конкретного про­
цесса. Системы должны быть скомпонованы из набора
взаимодействующих
модулей, каждый из который реализует функциональные возможности независимо
от других. Иногда эти компоненты объединены в уровни, каждый из которых обес­
печивает некий уровень абстракции. Данный многоуровневый подход является
мощным методом проектирования ортогональных систем. Поскольку на каждом
уровне используются только абстракции, обеспеченные на низших уровнях, можно
легко изменить основные реализации, не затрагивая самой программы. Иерархи­
ческое представление также уменьшает риск появления неконтролируемых зави­
симостей между модулями. Иерархическое представление часто показывается с
помощью диаграмм, как на рис. 2.1.
Интерфейс пользователя
Средства
Подсистема
Бизнес-
доступа к БД
отчетов
логика
Прикладная среда
Стандартная библиотека С
Операционная система
Рис. 2.1.
Типичная диаграмма иерархической
структуры
Существует простой тест на ортогональность проектирования. Как только вы со­
ставили схему компонентов, спросите себя: "Сколько модулей подвергнутся воздей­
ствию, если я резко изменю требования по конкретной функции?" В ортогональной
системе ответ должен быть "один".
1 Перемещение кнопки на панели графического
интерфейса пользователя не должно требовать внесения изменений в схему базы дан­
ных. Добавление контекстно-зависимой справки не должно изменить подсистему вы­
ставления счетов.
Рассмотрим сложную систему контроля и управления нагревательной установкой.
Первоначально требовалось наличие графического интерфейса, но затем требования
были изменены, с тем чтобы добавить систему речевого ответа и управления установ­
кой при помощи телефона с тональным набором. В ортогонально спроектированной
системе для этого вам пришлось бы изменить только модули, связанные с интерфейсом
пользователя, а основная логика управления предприятием остается неизменной. На
самом деле, если вы тщательно структурируете вашу систему, у вас должна быть воз­
можность поддержки обоих интерфейсов при наличии одной и той же программной
В действительности, это наивно. Лишь при очень большом везении большинство требова­
ний из реальной жизни окажут воздействие на многие функции системы. Тем не менее в
идеале каждое функциональное изменение обязано затрагивать лишь один-единственный
модуль.

Прагматический подход
33
базы. В разделе "Всего лишь представление" говорится о написании программ, в кото­
рых отсутствует связанность, используя парадигму "модель—представление—кон­
троллер" (Model—View—Controller), подходящую в данной ситуации.
Стоит спросить себя, как защитить вашу конструкцию от изменений в окру­
жающем мире. Например, вы пользуетесь номером телефона в качестве иденти­
фикатора заказчика. Что произойдет, если телефонная станция изменит коды меж­
дугородной связи? Не полагайтесь на свойства предметов, которыми не можете
управлять.
Инструментарии и библиотеки
Будьте внимательным, чтобы сохранить ортогональность вашей системы при введе­
нии инструментариев и библиотек, произведенных фирмами-субподрядчиками. Про­
явите мудрость при выборе технологии.
Однажды авторы работали над проектом, в котором требовалось, чтобы некий
фрагмент программы на языке Java выполнялся автономно — на сервере и в удален­
ном режиме — на клиентской машине. В этом случае возможными вариантами рас­
пределения классов были технологии RMI и CORBA. Если удаленный доступ к классу
обеспечивался при помощи RMI, то в этом случае каждое обращение к удаленному
методу в этом классе могло бы привести к генерации исключения, означающей, что
эта наивная реализация потребовала бы от нас обработки этого исключения всякий
раз при использовании удаленных классов. В данном случае использование RMI явно
не ортогонально: программа, обращающаяся к нашим удаленным классам не должна
зависеть от их физического расположения. Альтернативный способ — технология
CORBA — не налагает подобного ограничения: мы можем написать программу, для
которой не имело значения, где физически находятся классы.
Когда вы используете инструментарий (или даже библиотеку, созданную другими
разработчиками), вначале спросите себя, не заставит ли он внести в вашу программу
изменения, которых там быть не должно. Если схема долговременного хранения объ­
екта прозрачна, то она ортогональна. Если же при этом требуется создание объектов
или обращение к ним каким-либо особым образом, то ока неортогональна. Отделение
этих подробностей от вашей программы дает дополнительное преимущество, связан­
ное с возможностью смены субподрядчиков в будущем.
Интересным примером ортогональности является система Enterprise Java Beans
(EJB). В большинстве диалоговых систем обработки запросов, прикладная програм­
ма должна обозначать начало и окончание каждой транзакции. В системе EJB эта ин­
формация выражена описательно в виде метаданных вне любых программ. Та же са­
мая прикладная программа может работать в различных транзакционных средах EJB
без каких-либо изменений. Вероятно, это станет прообразом многих операционных
сред будущего.
Другой интересной проверкой на ортогональность является технология Aspect-
Oriented Programming (АОР) — исследовательский проект фирмы Xerox Pare
([KLM+97] и [URL 49]). Технология АОР позволяет выразить в одном-единственном
месте линию поведения, которая в противном случае была бы распределена по всему
исходному тексту программы. Например, журнальные сообщения обычно генериру-

34
Глава 2
ются путем явных обращений к некоторой функции записи в журнал по всему исход­
ному тексту. Используя технологию АОР, вы реализуете процедуру записи в журнал
ортогонально к записываемым данным. Используя версию АОР для языка Java, мож­
но записать сообщение журнала при входе в любой метод класса Fred, запрограмми­
ровав аспект:
aspect Trace {
advise * Fred.*(..) {
s t a t i c before {
Log.write("-> Entering " + thisJoinPoint.methodName);
}
}
}
При вплетении этого аспекта в текст вашей программы будут генерироваться
трассировочные сообщения. Если этого не сделать, не будет и сообщений. В обоих
случаях исходный текст остается неизменным.
Написание текста программы
Всякий раз, когда вы пишете программу, вы подвергаетесь риску снижения уровня
ортогональности вашего приложения. Если вы постоянно не отслеживаете не только
то, что вы делаете, но и весь контекст приложения, то существует опасность неумыш­
ленного дублирования функциональных возможностей в некотором другом модуле
или выражения существующих знаний дважды.
Есть ряд методик, которые можно использовать для поддержки ортогональности:
•
Сохраните вашу программу "несвязанной". Напишите "скромную" про­
грамму — модули, которые не раскрывают ничего лчглнего для других моду­
лей и не полагаются на внедрение других модулей. Попробуйте применить
закон Деметера [LH89], который обсуждается в разделе "Несвязанность и
закон Деметера". При необходимости в изменении состояния объекта это
должен делать сам объект. В этом случае программа остается изолирован­
ным от реализации другой программы и увеличивает вероятность того, что
система останется ортогональной.
•
Избегайте глобальных данных. Всякий раз, когда ваша программа ссы­
лается на глобальные данные, она привязывается к другим компонентам,
использующим эти данные. Даже глобальные переменные, которые вы со­
бираетесь использовать только для чтения, могут вызвать проблемы (на­
пример, если вам необходимо срочно изменить вашу программу, сделав ее
многопоточной). Вообще ваша программа станет проще в понимании и со­
провождении, если вы явно перешлете любой требуемый контекст в ваши
модули. В объектно-ориентированных приложениях контекст часто пере­
сылается как параметр к конструкторам объектов. В другой программе вы
можете создать конструкции, содержащие контекст, и обходить ссылки
на них.

Прагматический подход
35
Шаблон Singleton, упомянутый в книге "Design Patterns" [GHJV95], пред­
ставляет собой способ подтвердить существование единственного предста­
вителя объекта определенного класса. Многие используют эти объекты типа
Singleton как своего рода глобальную переменную (особенно при работе с
языками типа Java, которые иначе не поддерживают технологию глобальных
переменных). Будьте внимательны с шаблонами Singleton — они также мо­
гут приводить к ненужному связыванию.
•
Подобные функции. Зачастую вы сталкиваетесь с набором функций, кото­
рые похожи друг на друга; возможно, они используют общий фрагмент в на­
чале и конце программы, но в ее середине каждый из них пользуется своим
алгоритмом. Дублированная программа является признаком структурных
проблем. Для того чтобы составить программу лучше, следует обратить вни­
мание на шаблон Strategy в книге "Design Patterns".
Пусть постоянное критическое отношение к вашей программе войдет у вас в при­
вычку. Ищите любые возможности ее реорганизации для усовершенствования ее
конструкции и повышения уровня ортогональности. Этот процесс называется реорга­
низацией, и он важен настолько, что в книге ему посвящен целый раздел (см. "Реор­
ганизация").
Тестирование
Систему, спроектированную и реализованную ортогональным образом, проще тести­
ровать. Поскольку взаимодействие между компонентами системы формализовано и
ограничено, большая часть тестирования может осуществился на уровне отдельных
модулей. Это хорошо, поскольку тестирование на уровне модулей значительно легче
поддается спецификации и выполнению, чем интеграционное тестирование. Мы
предлагаем, чтобы каждый модуль был снабжен своим собственным встроенным тес­
том и эти тесты выполнялись автоматически как часть обычной процедуры сборки
(см. "Программа, которую легко тестировать").
Процедура сборки модульного теста сама по себе является интересным тестом на
ортогональность. Что требуется, чтобы собрать и скомпоновать тест модуля? Должны
ли вы задействовать большую часть системы, чтобы только для того, чтобы скомпи­
лировать или скомпоновать тест? В этом случае модуль очень хорошо связан с остав­
шейся частью системы.
Момент устранения ошибки также подходит для оценки ортогональности системы
в целом. Когда вы сталкиваетесь с проблемой, оцените, насколько локален процесс
ее устранения. Нужно изменить лишь один модуль, или изменения должны происхо­
дить по всей системе? Когда вы меняете что-либо, устраняются ли при этом все
ошибки или происходит загадочное появление новых? Это удачный момент для вне­
дрения автоматизации. Если вы применяете систему управления исходным текстом
(и вы будете делать этого, прочитав раздел "Средства управления исходным тек­
стом"), комментируйте устранение ошибок, когда вы осуществляете возвращение из­
мененного модуля в библиотеку после тестирования. Затем вы можете генерировать
ежемесячные отчеты, где анализируются тенденции в ряде исходных файлов, в кото­
рых производилось устранение ошибок.

36
Глава 2
Вопросы д л я обсуждения
•
Рассмотрим различие между большими инструментальными средствами,
ориентированными на графический интерфейс, которые обычно присутству­
ют в системах в среде Windows, и небольшими, но сочетаемыми между собой
утилитами, работающими в режиме командной строки и присутствующими в
командных оболочках. Какой набор является более ортогональным и поче-
Документация
Что удивительно, ортогональность применима и к документации. Координатами явля­
ются содержание и представление. Если документация действительно ортогональна,
вы можете существенно изменить внешний вид, не изменяя содержания. Современ­
ные текстовые процессоры содержат стили и макрокоманды, которые помогают в
этом (см. "Все эти сочинения").
Жизнь в условиях ортогональности
Ортогональность тесно связана с принципом DRY ("Не повторяй самого себя"). Ис­
пользуя этот принцип, ЕЫ можете свести к минимуму дублирование в пределах систе­
мы, а при помощи ортогональности уменьшить взаимозависимость между компонен­
тами системы. Звучит неуклюже, но, если вы используете принцип ортогональности в
тесной связи с принципом DRY, вы обнаружите, что разрабатываемые вами системы
становятся более гибкими, более понятными и более простыми в отладке, тестирова­
нии и сопровождении.
Когда вы присоединяетесь к проекту, в котором люди ведут отчаянную борьбу за
внесение изменений, а каждое изменение приводит к появлению четырех новых про­
блем, вспомните кошмар с вертолетом. Вероятно, проект сконструирован и запро­
граммирован неортогонально. Пришло время реорганизации.
И если вы пилот вертолета, не ешьте рыбы...
Другие разделы, относящиеся к данной теме:
•
Пороки дублирования
•
Средства управления исходным текстом
•
Проектирование по контракту
•
Несвязанность и законДеметера
•
Метапрограммирование
•
Всего лишь представление
•
Реорганизация
•
Программа, которую легко тестировать
•
Злые волшебники
•
Команды прагматиков
•
Все эти сочинения

Прагматический подход
37
му? Какой из них легче использовать именно для той цели, для которой он
предназначен? Какой из них легче скомбинировать с другими инструмен­
тальными средствами для решения вновь возникших проблемных вопросов?
•
Язык С + + поддерживает множественное наследование, а язык Java позво­
ляет классу реализовывать множественные интерфейсы. Как влияет на ор­
тогональность использование этих средств? Есть ли различие в воздействии,
которое оказывается в ходе использования множественного наследования и
множественных интерфейсов? Есть ли разница в применении делегирования
и наследования?
Упражнения
1.
Создается класс Split, который расщепляет вводимые строки на поля. Какая
из двух указанных ниже сигнатур класса Java имеет более ортогональную кон­
струкцию? (Ответ см. в Приложении В.)
class Split {
public Split"!(InputStreamReader rdr) { . . .
public void readNextLine() throws IOException { . . .
public int numFieldsO { . . .
public String getField(int fieldNo)
{...
}
class Split2 {
public Split2(String line) { . . .
public int numFieldsO
{ . . .
public String getField(int fieldNo) { . . .
}
2.
Какая конструкция обладает большей ортогональностью: немодальные или
модальные диалоговые окна? (Ответ см. в Приложении В.)
3.
Сравним процедурные языки и объектно-ориентированные технологии. Что
дает более ортогональную систему? (Ответ см. в Приложении В.)
9
Обратимость
Нет ничего опаснее идеи, если это
едч'нственное,
что у вас есть.
Эмиль-Огюст Шартье, Разговор
о религии,
1938
Технические специалисты предпочитают простые и однозначные решения задач. Мате­
матические тесты, позволяющие с большой уверенностью сказать, что х = 2, намного
лучше, чем нечеткие, но страстные очерки о миллионах причин Французской револю­
ции. К техническим специалистам присоединяются и менеджеры: однозначные и не­
сложные ответы хорошо вписываются в электронные таблицы и проектные планы.
Если бы это находило отклик в реальном мире! К сожалению, сегодня икс может
быть равен двум, а завтра он должен быть равен пяти, а на следующей неделе —

38
Глава 2
трем. Ничто не вечно, и если вы всерьез полагаетесь на некоторое явление, то этим
вы практически гарантируете, что оно непременно изменится.
Для реализации чего-либо всегда существуют не один-единственный способ и не
одна фирма-субподрядчик. Если вы начинаете работать над проектом, недальновидно
полагая, что для его осуществления имеется один-единственный способ, то вы може­
те быть неприятно удивлены. Многим проектным командам открывают глаза прину­
дительно, по мере развития событий:
"Но вы же сказали,
чтобы мы использовали
базу данных XYZ! Мы
написали
85% текста
проекта
— мы не можем изменить
его в данный момент",
—
протестует
программист.
"Очень жаль, но нашафирмарешила
вместо
нее
взять за основу базу PDQ — для всех проектов.
Это не мое решение.
Мы все
должны переписывать
тексты
программ.
Всем вам придется
работать
и
по выходным
— до особого
распоряжения".
Конечно, принимаемые меры не должны быть столь драконовскими, сколь и неот­
ложными. Но поскольку время идет, а ваш проект продвигается, вы можете оказаться
в шатком положении. С принятием каждого важного решения проектная команда ста­
вит перед собой все более узкую цель — ограниченную версию действительности, в
которой имеется меньшее число вариантов.
К тому времени, когда многие важные решения уже приняты, цель уменьшится
настолько, что, если она двинется с места или ветер изменит направление, или же
бабочка в Токио взмахнет своими крылышками, вы промахнетесь

## И здорово про­


махнетесь.
Проблема состоит в том, что непросто дать задний ход важным решениям.
Как только вы решите использовать базу данных этой фирмы или архитектурный
шаблон, или определенную модель развертывания (например, "клиент-сервер" вме­
сто автономной модели), то становитесь на путь, с которого невозможно свернуть —
лишь ценой огромных затрат.
Обратимость
Многие из тем, затронутых в данной книге, нацелены на создание гибкого, легко
адаптируемого
программного обеспечения. Следуя их рекомендациям — в особен­
ности принципу DRY, принципу несвязанности и использованию метаданных (см.
ниже), нет нужды в принятии многих важных необратимых решений. Это и хорошо,
поскольку вначале мы не всегда принимаем наилучшие решения. Мы придержива­
емся некоторой технологии лишь для того, чтобы в один прекрасный день обнару­
жить, что не в состоянии нанять достаточное количество людей, обладающих необ-
Возьмем нелинейную или хаотическую систему и внесем небольшое изменение в один из
входных параметров. Можно получить серьезный и зачастую непредсказуемый результат.
Классический пример: взмах крылышек бабочки в Токио может стать началом цепочки со­
бытий, приводящих к возникновению смерча в Техасе. Не напоминает ли это явление не­
которые известные вам проекты?

Прагматический подход
39
ходимыми навыками. Стоит нам остановить свой выбор на некоторой фирме-
субподрядчике, как ее сразу перекупают конкуренты (этой фирмы). Требования,
пользователи и аппаратные средства изменяются быстрее, чем мы разрабатываем
программное обеспечение.
Предположим, что в начале проекта вы решили использовать реляционную
базу данных, производимую фирмой А. Позже, во время нагрузочного тестирова­
ния, вы обнаруживаете, что база данных просто слишком медленная, а объектная
база данных фирмы В работает быстрее. В большинстве случаев вам не везет.
Большую часть времени обращения к программам фирм-субподрядчиков запуты­
ваются в тексте программ. Но если вы действительно вычленили идею базы, по­
местив ее снаружи — в точку, где она просто обеспечивает сохранение состояния
объектов (как служба), тогда вы обладаете достаточной гибкостью, чтобы менять
коней на переправе.
Аналогично, предположим, что проект начинается по модели "клиент—сервер", но
затем, когда карты уже сданы, отдел маркетинга решает, что для некоторых заказчи­
ков серверы слишком дороги и они хотят сделать автономную версию. Насколько
сложным будет для вас этот переход? Поскольку речь идет :• развертывании, для этого
потребуется минимум несколько дней. Если бы времени требовалось больше, вы бы и
не думали об обратимости. Обратная задача еще интереснее. Что будет, если возник­
нет необходимость в развертывании автономной версии разрабатываемого вами
проекта по схеме "клиент-сервер" или по я-звенной модели? Это также не должно
представлять затруднений.
Ошибка состоит в предположении, что любое решение высечено на камне, и него­
товности к случайностям, которые могут возникнуть. Вместо того, чтобы высекать ре­
шения на камне, рассматривайте их так, как будто они начерчены на морском песке.
В любой момент может накатиться большая волна и смыть их.
Подсказка 14
Не существует окончательных решений
Гибкая архитектура
В то время как многие люди пытаются сохранить свои программы гибкими, вам также
стоит подумать о том, чтобы обеспечить гибкость архитектуры, развертывания и ин­
теграции продуктов фирм-субподрядчиков.
Технологии, подобные CORBA, могут помочь в защите компонентов проекта от из­
менений, происходящих в языке, на котором ведется разработка, или в платформе.
Вдруг производительность Java на этой платформе не соответствует ожиданиям? Еще
раз напишите программу клиента на языке С + + , и больше ничего менять не нужно.
Подсистема правил в С + + не отличается достаточной гибкостью? Перейдите к версии
на языке Smalltalk. При работе с архитектурой CORBA вы должны обращать внимание
только на заменяемый компонент, другие компоненты трогать не нужно.
Вы разрабатываете программы для Unix? Какой версии? Вы рассмотрели все ас­
пекты переносимости? Вы пишете для конкретной версии Windows? Какой — 3.1, 95,
98, NT, СЕ, или же 2000? Насколько сложно будет обеспечить поддержку других вер-

40
Глава 2
сий? Если ваши решения характеризуются мягкостью и пластичностью, то это будет со­
всем несложно. Но это будет невозможно, если пакет неудачно сформирован, есть вы­
сокий уровень связанности, а з тексты программ встроена логика или параметры.
Вы не знаете точно, как отдел маркетинга собирается развертывать систему? По­
думайте об этом заранее, и вы сможете обеспечить поддержку автономной модели,
модели "клиент—сервер" или я-звенной модели только за счет изменений в файле
конфигурации. Мы создавали программы, которые действуют подобным образом.
Обычно вы можете просто скрыть продукт фирмы-субподрядчика за четким, абст­
рактным интерфейсом. На самом деле мы могли это сделать с любым проектом, над
которым мы работали. Но предположим, что вы не смогли изолировать его достаточ­
но четко. Что, если вам пришлось раскидать некоторые инструкции по всей програм­
ме? Поместите это требование в метаданные, и воспользуйтесь автоматическим меха­
низмом наподобие Aspect (см. "Инструментарии и библиотеки") или Perl для вставки
необходимых инструкций в саму программу. Какой бы механизм вы ни использовали,
сделайте его обратимым. Если что-то добавляется автоматически, то оно может и уда­
ляться автоматически.
Никто не знает, что может произойти в будущем, в особенности мы! Дайте вашей
программе работать в ритме рок-н-ролла: когда можно — ка.чатьсг:, а когда нужно —
энергично крутиться.
Другие разделы, относящиеся к данной теме:
•
Несвязанность и закон Деметера
•
Метапрограммирование
•
Всего лишь представление
Вопросы для обсуждения
•
Немного квантовой механики — пример с кошкой Шредингера. Предположим,
что в закрытом ящике сидит кошка и в нем же находится радиоактивная частица.
Вероятность распада частицы на две равна 50%. Если распад произойдет, кош­
ка умрет. Если этого не произойдет, кошка останется жива. Итак, умирает кош­
ка или остается жива? Согласно Шрёдингеру, верно и то, и другое. Всякий раз,
когда происходит ядерная реакция, у которой имеются два возможных результа­
та, происходит клонирование мира. В одном из двух ?.g*j4»» данное событие про­
изошло, а в другом — нет. Кошка жива в одном из миров и мертва в другом.
Лишь открыв ящик, вы осознаете, в .каком т миров находитесь вы.
Не удивительно, что программировать на перспективу так трудно.
Но подумайте об эволюции программы по аналогии с ящиком, в котором на­
ходится множество кошек Шредингера: каждое решение приводит к появле­
нию иной версии будущего. Сколько сценариев будущего поддерживает
ваша программа? Какие из них наиболее вероятны? Насколько сложно бу­
дет поддерживать их в определенный момент в будущем?
Хватит ли у вас смелости открыть ящик?

Прагматический подход
41
Если быть педантичным, то существует много способов стрельбы из пулемета в темное
время суток, включая стрельбу с закрытыми глазами (поливая свинцом все вокруг). Но это
лишь аналогия, и авторам позволительны некоторые вольности.
10 Стрельба трассирующими
На изготовку,
по цели — пли!
Существует два способа стрельбы из пулемета в темное время суток

## Вы можете вы­


яснить точно, где находится ваша цель (расстояние, высота и азимут). Вы можете оп­
ределить погодные условия (температура, влажность, давление, направление ветра и
так далее). Вы можете точно определить характеристики используемых вами патро­
нов и пуль и их взаимодействие с реальным пулеметом, из которого вы стреляете. За­
тем вы можете воспользоваться таблицами или компьютером для вычисления точного
азимута и угла возвышения ствола пулемета. Если все работает в точном соответст­
вии с характеристиками, таблицы корректны, и погодные условия не меняются, то
пули должны лечь близко к цели.
Можно также использовать трассирующие пули.
Трассирующие пули помещаются на пулеметную ленту через равные промежутки
наряду с обычными боеприпасами. При стрельбе фосфор, содержащийся в них, заго­
рается и оставляет пиротехнический след, идущий от пул^м^та до любого места, в ко­
торое они попадают. Если в цель попадают трассирующие пули, то, значит, в нее по­
падут и обычные.
Не удивительно, что стрельбу трассирующими предпочитают математическим
расчетам. Обратная связь возникает немедленно, и поскольку трассирующие пули
работают в той же среде, что и обычные боеприпасы, то внешние эффекты сведе­
ны к минимуму.
Возможно, это слишком сильная аналогия, но она применима к новым проектам,
особенно когда вы создаете то, чего раньше не было. Подобно стрелкам, вы пытае­
тесь поразить цель в темноте. Ваши пользователи никогда ранее не видели ничего по­
добного, поэтому их требования могут быть расплывчатыми. Вы же, в свою очередь,
наверняка применяете алгоритмы, методики, языки или библиотеки, с которыми не
знакомы, то есть сталкиваетесь с большим количеством неизвестных. И, поскольку
для выполнения проекта требуется время, вы можете с уверенностью гарантировать,
что к моменту окончания работы среда, в которой вы работаете, изменится.
Классический способ решения проблемы — предельно специфицировать систе­
му. Написать горы бумажной документации, регламентирующей каждое требова­
ние, связывая каждое неизвестное и ограничивая рабочую среду. Стрелять при по­
мощи жесткого расчета. Один большой предварительный расчет, затем стрельнуть и
надеяться.
Однако программисты-прагматики предпочитают стрелять трассирующими.
Программа, которую видно в темноте
Стрельба трассирующими эффективна, поскольку эти пули работают в той же самой
среде и подвержены тем же ограничениям, что и реальные пули. Они быстро оказыва-

42
Глава 2
ются у цели, так что стрелок получает немедленную обратную связь. И с практиче­
ской точки зрения они представляют собой относительно экономичное решение.
Чтобы добиться того же эффекта в программах, мы ищем нечто такое, что позво­
ляет нам быстро, наглядно и многократно проходить путь от требования до некоторой
характеристики окончательной версии системы.
Подсказка 15
Пользуйтесь трассирующими пулями, для того чтобы найти
цель
Однажды мы работали над сложным маркетинговым проектом с базой данных
"клиент-сервер". Частью требований была способность определять и выполнять
промежуточные запросы. Серверами являлся ряд реляционных и специализирован­
ных баз данных. Клиентский графический интерфейс пользователя, написанный на
языке Object Pascal, использовал набор библиотек С для обеспечения интерфейса с
серверами. Запрос пользователя хранился на сервере с использованием системы обо­
значений, подобной Lisp, до момента преобразования в оптимизированный SQL-
запрос, предшествующего его выполнению. При этом возникло много неизвестных и
много различных сред, и никто не знал наверняка, как же поведет себя графический
интерфейс пользователя.
Это было отличной поводом для применения программы трассировки. Мы разра­
ботали "скелет" внешнего интерфейса, библиотеки для представления запросов и
конструкцию для преобразования сохраненного запроса в запрос, определенный ба­
зой данных. Затем мы свели все воедино и проверили, работает ли это. Все, что мы
могли сделать в этом первоначальном варианте, был запрос, который выдавал пере­
чень всех строк в таблице, но он доказал, что интерфейс пользователя мог взаимодей­
ствовать с библиотеками, библиотеки могли преобразовать запрос в последователь­
ную и параллельную форму, а из результата сервер мог сгенерировать SQL-запрос.
На протяжении следующих месяцев мы постепенно разрабатывали основную конст­
рукцию, добавляя новую функциональную возможность путем параллельного нара­
щивания каждого компонента программы трассировки. Когда интерфейс пользовате­
ля добавлял новый тип запроса, библиотека увеличивалась и генерация SQL-запроса
становилась более утонченной.
Программа трассировки не является одноразовой: вы пишете ее, чтобы сохранить.
Она содержит всю проверку ошибок, структурирование, документацию и самоконтроль,
которые имеются в любом фрагменте рабочей программы. Она просто не обладает всеми
функциональными возможностями. Однако, как только вы добились сквозного соедине­
ния между компонентами вашей системы, вы можете проверить, насколько близко вы
находитесь к цели, и в случае необходимости сделать поправку. Как только вы попали в
цель, добавление функциональных возможностей облегчается.
Разработка программ трассировки находится в согласии с той идеей, что проект
никогда не кончается: всегда будет потребность в изменениях и добавлении функций.
Это — инкрементальный подход.
Обычная альтернатива является своего рода тяжеловесным техническим подхо­
дом: программа разделяется на модули, которые программируются в вакууме. Модули

Прагматический подход
43
объединены в подсистемы, которые затем подлежат дальнейшему объединению, пока
в один прекрасный день вы не получаете завершенное приложение. И только тогда
приложение в целом может быть представлено пользователю и протестировано.
Технология программы трассировки имеет много преимуществ:
•
Пользователи могут увидеть нечто работающее еще до выпуска окончатель­
ной версии. Если вам удалось передать суть делаемого вами (см. "Большие на­
дежды" ), то ваши пользователи будут осознавать, что видят перед собой еще не­
что незрелое. Они не будут разочарованы отсутствием функциональных
возможностей; они будут гореть желанием увидеть некий видимый прогресс в
создании их системы. По мере того как проект будет продвигаться, они начнут
делать вложения. Эти пользователи и станут теми людьми, которые скажут вам
о том, насколько близко к цели находится та или иная итерация.
•
Разработчики выстраивают некую структуру, в которой они работают.
Наибольший страх вызывает лист бумаги, на котором ничего не написано.
Если вы разработали все механизмы взаимодействия между модулями вашего
приложения и воплотили их в тексте программы, то вашей команде не придет­
ся многое высасывать из пальца. Это делает труд каждого из членов команды
более производительным и способствует последовательности в их работе.
•
У вас есть платформа для интеграции. Как только все компоненты системы
связаны друг с другом, появляется некая среда, куда вы можете добавлять
новые фрагменты программ, которые прошли модульное тестирование. Вы
будете заниматься интеграцией каждый день (иногда несколько раз в день),
не пытаясь интегрировать все сразу по методу "большого скачка". Воздейст­
вие каждого вновь вносимого изменения становится более очевидным, взаи­
модействия более ограниченными, поэтому отладка и тестирование будут
более быстрыми и точными.
•
У вас есть что продемонстрировать. Спонсоры проекта и руководство стре­
мятся увидеть демонстрационные версии в самое неподходящее время. При
наличии программы трассировки у вас всегда будет то, что можно им проде­
монстрировать.
•
Вы лучше ощущаете прогресс. При разработке программы трассировки про­
граммисты работают над сценариями использования системы по очереди. Они
заканчивают один сценарий и переходят к следующему. При этом гораздо про­
ще определить производительность и продемонстрировать пользователю про­
движение проекта. Поскольку каждая индивидуальная разработка меньше по
объему, вы избежите создания монолитных программных блоков, о которых
каждую неделю сообщается, что они готовы на 95%.
При стрельбе трассирующими вы не всегда
попадаете в цель
Трассирующие пули показывают, что вы куда-то попали. Это не обязательно должна
быть ваша цель. Затем вы корректируете прицел, пока пули не попадают в цель.
В этом-то все и дело.

44
Глава 2
То же самое относится и к программе трассировки. Вы используете методику в
ситуациях, когда вы не уверены на 100%, куда же вам двигаться. Не стоит удив­
ляться, если две ваших первых попытки сорвались: пользователь говорит: "Это
совсем не то, что я имел в виду", нужные данные становятся недоступными в са­
мый неподходящий момент, и явно возникают проблемы с производительностью.
Выработайте подход, для изменения того, что мешает приблизиться к цели, и будь­
те благодарны судьбе за то, что вы используете скудную методологию разработки.
Небольшой фрагмент программы отличается малой инерцией — его легко и быст­
ро изменить. Вы сможете собрать отклики на ваше приложение и сгенерировать
новую, более точную версию быстрее и дешевле. И поскольку каждый основной
компонент приложения представлен в программе трассировки, ваши пользовате­
ли могут быть уверены — то, что они видят, основано на реальности, а не на бу­
мажных спецификациях.
Программа трассировки и создание прототипов
Вы могли бы подумать, что принцип программы трассировки — это то же самое,
что и создание прототипов, только с более агрессивным названием. Отличие есть.
Цель работы с прототипом — исследование определенных характеристик (аспектов)
конечной версии системы. Создавая истинный прототип, вы отбросите все то, что
критиковали при опробовании принципа, и перепишете его надлежащим образом, ис­
пользуя полученные уроки.
Например, вы создаете приложение, которое помогает транспортным компаниям
определять, как упаковывать ящики нестандартного размера в контейнеры. Помимо
всего прочего, интерфейс пользователя должен быть интуитиво понятным, а алгорит­
мы, используемые для определения оптимальной упаковки, очень сложны.
Вы могли бы создать интерфейс для конечных пользователей при помощи соответ­
ствующих инструментальных средств. Вашей программы достаточно для того, что бы
сделать интерфейс восприимчивым к действиям пользователя. Как только пользовате­
ли согласятся с компоновкой интерфейса, вы можете отбросить его и переписать на
этот раз на основе бизнес-логики, используя целевой язык. Аналогично, вы можете за­
хотеть создать прототип ряда алгоритмов, которые осуществляют реальную упаковку.
Вы можете запрограммировать функциональные тесты на высокоуровневом, "всепро­
щающем" языке типа Perl и затем запрограммировать низкоуровневые тесты произво­
дительности на языке, который более близок к машинному. В любом случае, как только
вы приняли решение, необходимо начать сначала и запрограммировать алгоритмы в
окончательной версии среды, которая взаимодействует с внешним миром. Это и есть
создание прототипов, и это очень полезно.
Подход типа "стрельба трассирующими" обращается к иной проблеме. Вам необ­
ходимо знать, как работает приложение в целом. Вы хотите показать вашим пользо­
вателям, как на практике осуществляется взаимодействие, и дать им "скелет" архи­
тектуры", на который наращивается тело программы. В этом случае вы можете
сконструировать программу трассировки, состоящую из тривиальной реализации ал­
горитма упаковки контейнера (возможно, нечто вроде FIFO), и простой, но работаю-

Прагматический подход
45
щий интерфейс пользователя. Как только вы соедините все компоненты приложения,
у вас уже есть каркас, который можно представить вашим пользователям и разработ­
чикам. Спустя некоторое время вы добавляете к этому каркасу новую функциональ­
ную возможность, заменяя заглушки программами. Но сам остов остается нетрону­
тым, и вы знаете, что система будет вести себя тем же образом, как и в тот момент,
когда завершалась первая программа трассировки.
Различие достаточно важно, чтобы гарантировать повторяемость. Прототипы ге­
нерируют одноразовую программу. Программа трассировки является скудной, но за­
вершенной; она образует часть "скелета" конечной версии системы. Рассматривайте
создание прототипов, как рекогносцировку и сбор данных разведки до начала стрель­
бы трассирующими.
Другие разделы, относящиеся к данной теме:
•
Приемлемые программы
•
Прототипы и памятные записки
•
Западня спецификации
•
Большие надежды
11 Прототипы и памятные записки
Для опробования определенных идей во многих отраслях промышленности использу­
ются прототипы; это дешевле, чем организовывать полномасштабное производство.
Например, в автомобильной промышленности для новой модели автомобиля может
быть построено несколько различных прототипов. Каждый из них конструируется для
проверки определенных свойств автомобиля — аэродинамики, дизайна, свойств кон­
струкции и т.д. Для испытания в аэродинамической трубе изготавливается модель из
глины, для отдела дизайна создается модель из бальзовой древесины и клейкой ленты
и т.д. Некоторые автомобильные фирмы идут дальше и осуществляют значительную
часть работы по моделированию при помощи компьютеров, что приводит к еще боль­
шему сокращению расходов. В этом случае нет необходимости в реальном изготовле­
нии рискованных элементов конструкции для их опробования.
Мы создаем прототипы программ тем же образом и по тем же причинам — для
анализа и выявления риска, предлагая возможности для коррекции при существенно
меньших затратах. Подобно тому, как это делается в автомобильной промышленно­
сти, мы можем использовать прототип для опробования одного или нескольких харак­
теристик проекта.
Мы склонны полагать, что основой прототипов являются программы, но не это не
всегда так. Подобно тому, как это делается в автомобильной промышленности, мы
можем строить прототипы из различных материалов. Памятные записки великолепно
подходят для создания прототипов таких динамических объектов, как логика докумен­
тооборота и прикладная логика. Прототип интерфейса может моделироваться на лек-

46
Глава 2
ционной доске, как модель без функциональных возможностей, изображенная с по­
мощью графической программы или программы-построителя интерфейса.
Прототипы разрабатываются для того, чтобы ответить лишь на несколько вопро­
сов, поэтому их разработка намного дешевле и быстрее, чем приложений, которые
идут в производство. Программа может игнорировать незначительные подробно­
сти — незначительные в данный момент, но позже могущие оказаться для пользова­
теля очень важными. Если, к примеру, вы создаете прототип графического интерфей­
са пользователя, то можете смириться с неправильными результатами или данными.
С другой стороны, если вы просто исследуете характеристики вычислений или произ­
водительности, то можете обойтись скудным графическим интерфейсом пользовате­
ля, или вообще без него.
Но если вы работаете в среде, где нельзя отказаться от подробностей, тогда необ­
ходимо спросить себя, а нужно ли вообще создавать прототип. Возможно, в этом слу­
чае лучше всего подходит стиль разработки типа "стрельба трассирующими" (см.
"Стрельба трассирующими").
Для чего создаются прототипы
Какие объекты можно изучать при помощи прототипов? Все, что характеризуются на­
личием риска. Все, что не подвергались тестированию ранее или являются абсолютно
критичными для конечного варианта системы. Всё, что является недоказанным, экспе­
риментальным или сомнительным. Всё то, с чем вы еще не освоились. Вы можете соз­
давать прототипы:
•
Архитектуры
•
Новой функциональной возможности уже существующей системы
•
Структуры или содержания внешних данных
•
Инструментальных средств или компонентов, выпущенных фирмами-суб­
подрядчиками
•
Рабочих характеристик
•
Дизайна интерфейса пользователя
Создание прототипов способствует приобретению опыта. Значение этого опыта
заключается не в созданной программе, а в полученных уроках. В этом и состоит
смысл создания прототипов.
Подсказка 16
Создавайте прототипы, чтобы учиться на них
Как использовать прототипы
Какими деталями можно пренебречь при построении прототипа?
•
Корректность. Там, где это приемлемо, вы сможете использовать фиктив­
ные данные.

Прагматический подход
47
•
Завершенность. Прототип может функционировать лишь в ограниченном
смысле, возможно, лишь с одним наперед заданным фрагментом входных
данных и одним пунктом меню.
•
Надежность. Процедура проверки ошибок, вероятно, будет неполной или
будет отсутствовать полностью. Если вы отклоняетесь от определенного
пути, то прототип может выйти из строя и сгореть, как ракета. Это нор­
мально.
•
Стиль. Неприятно признавать это, но прототип программы не имеет боль­
шого значения для комментариев или документации. При работе с прототи­
пом можно написать горы документации, но сравнительно малая ее часть бу­
дет посвящена собственно прототипу системы.
Поскольку в прототипе детали отодвигаются на второй план, а в центре рассмот­
рения оказываются определенные аспекты системы, вам может показаться реаль­
ным создание прототипов с использованием языка очень высокого уровня — выше
уровня языка остальной части проекта (язык типа Perl, Python, или Tel). Язык сце­
нариев высокого уровня позволяет опускать многие детали (включая указание типов
данных) и при этом создавать функциональный (хотя и неполный и медленный)
фрагмент программы

## Если вам необходимо создать прототип интерфейсов пользо­


вателей,
изучите
инструментальные
средства
типа
Tcl/Tk,
Visual
Basic,
Powerbuilder, или Delphi.
Языки сценариев хороши для использования в качестве "клея" при соединении
низкоуровневых фрагментов в новые сочетания. При работе в системе Windows язык
Visual Basic может "скреплять" средства управления СОМ. В более общем смысле
вы можете использовать языки типа Perl и Python для связывания воедино низкоуров­
невых библиотек языка С — вручную, или автоматически при помощи инструментов,
наподобие бесплатного SWIG [URL 28]. Используя этот подход, вы можете быстро
собрать существующие компоненты в новые конфигурации, чтобы посмотреть, как
они работают.
Создание прототипов архитектуры
Многие прототипы создаются, чтобы смоделировать рассматриваемую систему в це­
лом. В отличие от подхода типа "стрельба трассирующими", ни один из отдельных мо­
дулей в прототипе системы не должен быть особенно функциональным. На самом
деле вам даже не нужно писать программу для создания прототипов — вы можете
создать прототип на лекционной доске, при помощи памятных записок или каталож­
ных карточек. Вы пытаетесь понять то, как система выглядит в собранном виде, опус­
кая детали. Вот некоторые из конкретных областей, которые вы можете обнаружить в
архитектурном прототипе:
•
Четко ли определены обязанности основных компонентов, и являются ли
они приемлемыми?
При исследовании абсолютной (в противовес относительной) рабочей характеристики, не­
обходимо придерживаться некоего языка, близкого по характеристикам к целевому языку.

48
Глава 2
•
Четко ли определена совместная работа основных компонентов?
•
Сведено ли к минимуму связывание?
•
Можно ли идентифицировать потенциальные источники дублирования?
•
Можно ли применить определения интерфейсов и ограничения?
•
Обладает ли каждый из модулей путем доступа к данным, требуемых ему в ходе
выполнения? Может ли он получить такой доступ в случае необходимости?
Последний пункт приносит большинство сюрпризов и наиболее ценных результа­
ты, основанных на опыте создания прототипов.
Как не надо использовать прототипы
Перед тем как вы займетесь созданием любого прототипа, основанного на программе,
убедитесь, что все понимают — вы пишете одноразовую программу. Прототипы мо­
гут быть обманчиво привлекательными для людей, которые не знают, что это всего
лишь прототипы. Вы должны очень четко уяснить — эта программа одноразовая, не­
завершенная и не может быть завершена.
Легко впасть в заблуждение из-за очевидной завершенности демонстрационного
прототипа, и спонсоры проекта или менеджмент могут насггивать на развертывании
прототипа (или его потомства), если вы заранее не определите, что можно ожидать от
прототипа. Напомните им, что вы, конечно, можете создавать великолепный прото­
тип новой модели автомобиля из бальзовой древесины и клейкой ленты, но вы же не
поедете на нем в час пик!
Если вы полагаете, что в вашей среде или культуре существует большая вероят­
ность того, что назначение прототипа программы может быть истолковано непра­
вильно, вам лучше воспользоваться подходом "стрельба трассирующими". Вы полу­
чите некий жесткий каркас, на котором можно основывать будущие разработки.
При надлежащем использовании прототип может сэкономить вам огромное коли­
чество времени, денег, головной боли и мучений за счет идентификации и исправле­
ния потенциальных проблем в самом начале цикла разработки — затраты на устране­
ние ошибок будут недорогими и не вызовут затруднений.
Другие разделы, относящиеся к данной теме:
•
Мой исходный текст съел кот Мурзик
•
Общайтесь!
•
Стрельба трассирующими
•
Большие надежды
Упражнения
4.
Специалисты по маркетингу хотели бы сесть и вместе с вами провести мозго­
вой штурм по дизайну нескольких интернет-страниц. Они думают об активных
картах ссылок — для перехода к другим страницам. Но они не могут опреде­
литься с моделью ссылки: это могут быть изображения автомобиля, телефона

Прагматический подход
49
или дома. У вас имеется перечень целевых страниц и содержания; они хотели
бы увидеть несколько прототипов. Да, кстати, в вашем распоряжении 15 ми­
нут. Какими инструментами вы могли бы воспользоваться? (Ответ приведен в
Приложении В)
12 Языки, отражающие специфику
предметной области
Границы моего языка есть границы моего
мира.
Людвиг фон Витгенштейн
Языки программирования влияют на то, как вы думаете о проблеме и на то, как вы ду­
маете об общении. В каждом языке имеются свои особенности — ученые словечки
типа "статический и динамический контроль типов", "раннее и позднее связывание",
"модели наследования" (простое, множественное или отсутствие) — все они могут
предложить определенные решения или затруднить их. Решение, создаваемое в стиле
Lisp, отличается от решения, основанного на мышлении приверженца языка С, и на­
оборот. Верно и обратное (и по нашему мнению, более важное) — язык, отражаю­
щий специфику данной области, может, со своей стороны, предложить решение в об­
ласти программирования.
Мы всегда пытаемся написать программу, используя словарь, характерный для
прикладной области (см. "Ловушка требований", где предлагается использовать про­
ектный глоссарий). В ряде случаев можно перейти на следующий уровень и действи­
тельно программировать, пользуясь словарем, синтаксисом и семантикой предметной
области.
Пользователи предложенной системы должны быть в состоянии точно изложить,
как она должна работать:
Ожидать
прихода
сообщений,
определенных
нормативом
12.3
фирмы
ABC, по каналам
связи Х.25, преобразовать
их в формат 43В фирмы XYZ,
ретранслировать
на спутниковый
канал связи и сохранить
для
анализа
в
будущем.
Если ваши пользователи располагают набором подобных четких инструкций, то
вы можете изобрести мини-язык, скорректированный в соответствии с прикладной
областью и выражающий именно то, что им нужно:
From X25LINE1 (Format=ABC123) {
Put TELSTAR1 (Format=XYZ43B);
Store DB;
}
Этот язык не должен быть исполняемым. В своем исходном виде он мог бы просто
фиксировать требования пользователя — спецификации. Однако вы наверняка по­
считали возможным пойти дальше и фактически реализовать язык. Ваша специфика­
ция превратилась в исполняемую программу.

50
Глава 2
После того как вы написали приложение, пользователи предъявляют вам новое
требование: сообщения с отрицательным балансом не должны сохраняться и должны
отсылаться обратно по каналам связи Х.25 в первоначальном формате:
From X25LINE1 (Format=ABC123) {
if (АВС123.balance < 0) {
Put X25LINE1 (Format=ABC123);
}
else {
Put TELSTAR1 (format=XYZ43B);
Store DB;
}
}
Несложно? При наличии надлежащей поддержки вы можете программировать
значительно ближе к прикладной области. Мы не предлагаем, чтобы ваши конечные
пользователи программировали на этих языках. Вместо этого вы даете самому себе
инструмент, который позволяет вам работать ближе к их области.
Подсказка 17
Программируйте ближе к предметной области вашей задачи
Мы полагаем, что вам следует рассмотреть способы перемещения вашего объекта
ближе к предметной области проблемы — будь то простейший язык для конфигури­
рования и управления прикладной программой или же более сложный язык для обо­
значения правил или процедур. При составлении программы на более высоком уров­
не абстракции вам легко сосредоточиться на решении проблем предметной области и
вы можете проигнорировать мелкие детали, связанные с реализацией.
Помните, что с приложением работают многие пользователи. Существует конеч­
ный пользователь, который понимает правила предметной области и то, что должно
быть на выходе программы. Имеются также вторичные пользователи: обслуживаю­
щий персонал, менеджеры, занимающиеся конфигурированием и тестированием,
программисты служб поддержки и сопровождения и будущие поколения разработчи­
ков. У каждого из этих пользователей есть собственная предметная область, и для
всех них вы можете генерировать мини-среды и языки.
Ошибки, отражающие специфику предметной области
Если вы р а б о т а е т е в о п р е д е л е н н о й предметной о б л а с т и , то можете о с у ­
ществить и проверку правильности данных, характерных д л я н е е , с о о б щ а я
о п р о б л е м а х языком, понятным вашим пользователям. Р а с с м о т р и м про­
грамму коммутации каналов, приведенную выше. Предположим, что поль­
зователь неправильно обозначил наименование ф о р м а т а :
From X25LINE1 (Format=AB123)

Прагматический подход
51
Если подобное происходит в универсальном языке программирования, то
выдается стандартное сообщение об ошибке:
Syntax error: undeclared identifier
Используя мини-язык, вместо этого можно создать сообщение об ошибке, с
помощью словаря предметной области:
"АВ123" is not a format. Known formats are ABC123, XYZ43B, PDQB, and 42.
Реализация мини-языка
В самом простейшем варианте мини-язык может реализовываться в строчно-ориен-
тированном, легко анализируемом формате. Практически мы используем эту форму
больше, чем любую другую. Ее просто проанализировать при помощи инструкций
switch, или используя регулярные выражения в языках сценариев типа Perl. Ответ
к упражнению 5 (Приложение В) показывает простую реализацию мини-языка на
языке С.
Вы можете реализовать и более сложный язык, с более формальным синтаксисом.
Хитрость состоит в том, чтобы вначале определить синтаксис, используя систему обо­
значений, подобную нормальной форме Бэкуса-Наура

## Как только вы определили


грамматику, ее обычно легко преобразовать во входной синтаксис для генератора.
Программисты, работающие с языками С и С + + , давно используют уасс (или его
бесплатную версию bison [URL 27]). Подробное описание этих программ приводится
в книге "Lex and Yacc" [LMB92]. Программисты, работающие с языком Java, могут
поработать с программой javaCC, которая находится на сайте [URL 26]. В ответе к уп­
ражнению 7 (Приложение В) показана программа грамматического разбора, напи­
санная с помощью bison. Пример показывает, что, как только вы изучите синтаксис,
написание мини-языков не представляет сложности.
Существует другой способ реализации мини-языка: расширить существующий.
Например, можно могли интегрировать функциональные возможности на уровне
приложения при помощи Python [URL 9] и написать нечто вроде
2:
record = X25LINE1.get(format=ABC123)
if (record.balance < 0):
X25LINE1.put(record,
format=ABC123)
else:
TELSTR1.put(record,
format=XYZ43B)
DB. store( record)
Нормальная форма Бэкуса-Наура (BNF) позволяет осуществлять рекурсивное опреде­
ление контекстно-свободных
грамматик. В любой толковой книге по проектирова­
нию компиляторов или синтаксическому
анализу имеется подробная
спецификация
формы BNF.
Авторы благодарят Эрика Вота за этот пример.

52
Глава 2
Языки управления донными и процедурные языки
Реализуемые вами языки могут использоваться двумя различными способами.
Языки управления
данными создают некую форму структуры данных используе­
мой приложением. Эти языки часто используются для представления конфигурации.
Например, программа sendmail применяется во всем мире для маршрутизации
электронной почты в сети Internet. Она обладает многими достоинствами и преиму­
ществами, которые управляются огромным файлом конфигурации, написанном на
собственном языке конфигурирования программы sendmail:
Mlocal, P=/usг/bin/procmai1,
F=lsDFMAw5:/|@qSPfhn9,
S=10/30, R=20/40,
T=DNS/RFC822/X-Unix,
A=procmail -Y -a $h -d $u
Очевидно, удобочитаемость не является сильной стороной sendmail.
Уже давно фирма Microsoft использует язык данных, который может описывать
меню, реквизиты окон, диалоговые окна и другие ресурсы Windows. На рис. 2.2 пока­
зан фрагмент типичного файла ресурсов. Он читается намного легче, чем пример с
программой sendmail, но используется точно так же — компилируется для генерации
структуры данных.
Процедурные
языки
идут дальше. В этом случае язык является исполняемым и
поэтому может содержать инструкции, конструкции управления и т.п. (подобные сце­
нарию на с. 50).
MAIN_MENU MENU
{
POPUP "&File"
{
MENUITEM "&New", CM_FILENEW
MENUITEM "&0pen...", CM_FILE0PEN
MENUITEM "&Save", CM_FILESAVE
}
}
MY_DIAL0G_B0X DIALOG 6, 15, 292, 287
STYLE DS_M0DALFRAME | WS_POPUP | WS_VISIBLE |
WS_CAPTI0N | WS_SYSMENU
CAPTION "My Dialog Box"
FONT 8, "MS Sans Serif"
{
DEFPUSHBUTTON "OK", ID_0K, 232, 16, 50, 14
PUSHBUTTON "HELP", ID.HELP, 323, 52, 50, 14
CONTROL "Edit Text Control", ID_EDIT1,
"EDIT", WSJODER | WS_TABST0P, 16, 16, 80, 56
CHECKBOX "Checkbox", IDCHECKB0X1, 153, 65, 42, 38,
BS_AUT0CHECKB0X | WS_TABST0P
}
Рис. 2.2.
Файл .rc для Windows

Прагматический подход
53
Вы также можете использовать собственные процедурные языки, чтобы облег­
чить сопровождение программы. Например, вас просят интегрировать информа­
цию из унаследованного приложения в вашу новую разработку графического ин­
терфейса. Обычно это осуществляется при помощи "экранного кармана"; ваше
приложение связывается с основным (mainframe) приложением, так, как если бы
это обычный пользователь-человек, генерируя нажатия клавиш и "считывая" при­
нимаемые отклики. Вы можете создать сценарий взаимодействия при помощи
мини-языка
1.
locate prompt "SSN:"
type "%S" social_security_number
type enter
waitfor keyboardunlock
if text_at(10,14) is "INVALID SSN" return bad_ssn
if text_at(10,14) is "DUPLICATE SSN" return dup_ssn
# etc...
Когда приложение определяет, что пора вводить номер SSN, то по этому сцена­
рию оно вызывает интерпретатор, который затем управляет транзакцией. Если ин­
терпретатор встроен в приложение, то они даже могут совместно использовать дан­
ные (например, при помощи механизма обратного вызова).
В этом случае вы программируете в предметной области программиста сопровож­
дения. Когда изменяется основное приложение и поля смещаются, программист мо­
жет просто обновить высокоуровневое описание, вместо того чтобы копаться в под­
робностях программы на языке С.
Автономные и встроенные языки
Чтобы приносить пользу, мини-язык не должен использоваться приложением напря­
мую. Можно многократно использовать язык спецификации, чтобы создать искусст­
венные объекты (включая метаданные) которые компилируются, считываются или
используются самой программой иным образом (см. "Метапрограммирование").
Например, в разделе "Обработка текста" описывается система, в которой мы ис­
пользовали Perl, чтобы генерировать большое количество выводов из первоначаль­
ной спецификации схемы. Мы изобрели общий язык, чтобы представить схему базы
данных, и затем сгенерировали все его формы, которые нам необходимы, — SQL, С,
интернет-страницы, XML и др. Приложение не использовало спецификацию напря­
мую, но оно полагалось на выходные данные, полученные из нее.
Обычной практикой является встраивание процедурных языков высокого уровня
непосредственно в ваше приложение, так чтобы они исполнялись, когда исполняется
ваша программа. Очевидно, что это мощное средство; вы можете изменять поведение
вашего приложения, изменяя сценарии, которые оно считывает, причем все это
На самом деле можно приобретать инструментальные средства, поддерживающие только
этот способ написания сценариев. Кроме того, можно изучить пакеты с простым исходным
текстом (типа Expect), в которых имеются подобные возможности [URL 24].

54
Глава 2
делается без компиляции. Это существенно упрощает сопровождение в области дина­
мической области приложения.
Несложная разработка
или несложное
сопровождение?
Мы рассмотрели несколько различных грамматик, начиная от простых строчно-ори-
ентированных форматов до более сложных, которые выглядят как реальные языки.
Если для реализации требуются дополнительные усилия, тогда зачем выбирать более
сложную грамматику?
Компромиссом являются расширяемость и сопровождение. В то время как про­
грамма грамматического разбора "реального" языка" может быть более сложной в
написании, для пользователей она будет намного понятнее, и ее будет легче расши­
рить за счет добавления новых средств и функциональных возможностей. Слишком
простые языки могут быть легкими для грамматического разбора, но они могут быть
зашифрованными — подобно примеру с программой sendmail (см. "Языки управле­
ния данными и процедурные языки").
Учитывая, что срок службы большинства прикладных программ превышает ожи­
даемый, вам лучше примириться с суровой действительностью и принять более слож­
ный и удобочитаемый язык. Усилия, затраченные вначале, многократно окупятся за
счет снижения затрат на поддержку и сопровождение.
Другие разделы, относящиеся к данной теме:
•
Метапрограммирование
Вопросы д л я обсуждения
•
Можно ли выразить некоторые из требований проекта, над которым вы ра­
ботаете в настоящее время, на языке, отражающем специфику предметной
области? Возможно ли написать компилятор или транслятор, который мог
бы сгенерировать большую часть требуемой программы?
•
Если вы решили принять мини-язык как способ программирования, близкий
к предметной области, то вы принимаете и то, что для реализации потребу­
ются некоторые усилия. Как выдумаете, есть ли способы, при которых "ске­
лет", разработанный для одного проекта, может многократно использовать­
ся в других?
Упражнения
5.
Требуется реализовать мини-язык управления простым графическим пакетом
(возможно, с графикой в относительных командах). Язык состоит из однобук-
венных команд. После некоторых команд указывается число. Например, сле­
дующий фрагмент изображает на экране прямоугольник. (Ответ см. в Прило­
жении В.)
Р 2 # select pen 2
D
# pen down
W 2 # draw west 2cm

Прагматический подход
55
N 1 # then north 1
Е 2 # then east 2
S 1 n then back south
U
# pen up
Составьте программу, которая анализирует этот язык. Она должна быть разрабо­
тано так, чтобы операция добавления новых команд была несложной.
6.
Спроектируйте грамматику BNF (нормальной формы Бэкуса—Наура), чтобы
провести грамматический разбор спецификаций времени. Все указанные при­
меры должны быть успешно проанализированы. (Ответ см. в Приложении В.)
4pm, 7:38pm, 23:42, 3:16, 3:16am
7.
Реализуйте программу грамматического разбора для грамматики нормаль­
ной формы Бэкуса—Наура вупражнении 6, используя программы уасс, bison
или аналогичный генератор грамматического разбора. (Ответ см. в Прило­
жении В.)
8.
Реализуйте программу грамматического разбора времени, используя Perl.
(Подсказка:
регулярные выражения позволяют написать хорошие программы
грамматического разбора). (Ответ см. в Приложении В.)
13 Оценка
Как скоро? Сколько времени потребуется для пересылки "Войны и мира" по модем­
ной линии 56 байт? Какое место займет на диске миллион имен и адресов? Сколько
времени понадобится для прохождения 1000-байтового блока через маршрутизатор?
Сколько месяцев потребуется, чтобы завершить ваш проект?
С одной стороны, все эти вопросы бессмысленны — информация, содержащаяся
в них, недостаточна для ответа. И тем не менее, на все из них можно ответить, если вы
сможете произвести оценку. В процессе работы над генерацией оценки вы придете к
большему пониманию мира, в котором обитают ваши программы.
Научившись оценивать и развивая этот навык до уровня, на котором у вас появля­
ется интуитивное ощущение величины тоге или иного предмета, вы сможете показать
явно магическую способность к определению их выполнимости. Если кто-либо гово­
рит: "Мы вышлем вам резервную копию по каналу ISDN в центральный офис", вы
сможете интуитивно осознать, имеет ли это смысл. Когда вы составляете программу,
вы сможете понять, какие подсистемы нуждаются в оптимизации, а какие нужно оста­
вить в покое.
Подсказка 18
Проводите оценки во избежание сюрпризов
В конце данного раздела мы приведем единственно правильный ответ (в виде бес­
платного приложения), который необходимо давать во всех случаях, когда вас просят
оценить что-либо.

56
Глава 2
Насколько точной является "приемлемая
точность"?
До некоторой степени все ответы представляют собой оценки. Просто некоторые из
них точнее остальных. Так что первым вопросом, который вам придется задать самому
себе, когда кто-либо просит вас об оценке, является вопрос о контексте, в котором
будет приниматься данный вами ответ. Нужна ли здесь высокая точность, или речь
идет о примерной цифре?
•
Если ваша бабушка спрашивает, когда вы появитесь, она, вероятно, задает­
ся вопросом, к какому времени готовить вам обед или ужин. С другой сторо­
ны, водолаз, оказавшийся в подводной ловушке и испытывающий недоста­
ток воздуха, интересуется ответом с точностью до си^-ады.
•
Каково значение числа "пи"? Если вас интересует, какое количество бор­
дюрного камня понадобится для оформления цветочной клумбы, то цифра 3
вероятно будет приемлемой

## На школьном уровне хорошим приближением


является у-. Ну а если вы работаете в НАСА, то двенадцати цифр после запя­
той будет вполне достаточно.
Одной из интересных особенностей оценки является тот факт, что интерпретация
ее результата зависит от используемых вами единиц измерения. Если выговорите, что
для некоего действия потребуется 130 рабочих дней, то люди будут ожидать наступле­
ния этого события в достаточно узком интервале. Но если вы скажете "около шести
месяцев", они будут знать, что этого события следует ожидать через 5—7 месяцев.
Обе цифры обозначают одну и ту же продолжительность, но "130 дней", вероятно,
подразумевает большую точность, чем вы полагаете. Мы рекомендуем следующую
градацию оценок времени:
Продолжительность
Оценка (порядок)
1 — 15 дней
дни
3—8 недель
недели
8 - 3 0 недель
месяцы
30 и более недель
перед тем, как оценить, стоит хорошенько подумать
Так, если после всей необходимой работы, вы придете к решению, что проект зай­
мет 125 рабочих дней (25 недель), он может быть оценен как "примерно за шесть ме­
сяцев".
Для законодателей вполне достаточно значения 3. В законопроекте № 246 Законодатель­
ного собрания штата Индиана (1897) была сделана попытка установить, что отныне число
"л" будет равно 3. Во втором чтении законопроект был отложен на неопределенное время,
так как некий профессор математики указал, что власть законодателей не распространяет­
ся на законы природы.

Прагматический подход
57
Те же принципы применимы к оценкам любых количеств: выберите единицы, в ко­
торых будет дан ответ, чтобы отразить точность, которую вы намерены передать.
Из чего исходят оценки?
Все оценки основаны на моделях проблемы. Но перед тем как углубиться в мето­
дики построения моделей, необходимо упомянуть о главной хитрости, которая всегда
дает хорошие результаты: спросите того, кто уже делал это. Перед тем как плотно за­
няться построением модели, оглянитесь вокруг в поиска:; тг;, кто ранее находился в
подобной ситуации. Посмотрите, как они решали свою задачу. Маловероятно, что вы
обнаружите точное совпадение, но будете удивлены, сколь часто вы успешно обраща­
лись к опыту других.
Понимание сути заданного вопроса
Первой частью любого упражнения в составлении оценки является понимание сути
заданного вопроса. Как и в случае с вопросами точности, обсуждаемыми выше, вам
необходимо осознать масштаб предметной области. Зачастую он неявно выражен в
самом вопросе, но осознание масштаба, перед тем, как начать строить предположе­
ния, должно войти у вас в привычку. Зачастую выбранная вами предметная область
частично формирует ответ, который выдаете: "Если предположить, что по дороге не
будет аварий и машина заправлена, я буду там через 20 минут"
Построение модели системы
Эта часть процесса оценки — самая интересная. Исходя из вашего понимания задан­
ного вопроса, постройте в уме скелет действующей модели. Если вы оцениваете вре­
мя отклика, то в вашей модели может иметься узел обслуживания и некий входной по­
ток. При работе над проектом моделью могут послужить стадии, которые ваша
организация использует в разработке, наряду с весьма грубым представлением того,
как система может быть реализована.
Построение модели может быть творческим процессом и полезным в долгосрочной
перспективе. Зачастую процесс построения модели приводит к открытию схем и про­
цессов, лежащих в основе чего-либо и не видимых невооруженным глазом. У вас даже
может возникнуть желание повторно исследовать исходный вопрос: "Вы попросили
дать оценку X. Однако, похоже, что Y, являющийся вариантом X, может быть выполнен
примерно в два раза быстрее, и при этом вы теряете лишь одну характеристику".
Построение модели вносит погрешности в процесс оценки. Это и неизбежно, и по­
лезно. Вы жертвуете простотой модели ради точности. Удвоение усилий, прилагаемых
к модели, может увеличить точность лишь незначительно. Ваш опыт подскажет вам,
когда закончить процесс совершенствования.
Декомпозиция
модели
Как только у вас появляется модель, вы можете провести ее декомпозицию на от­
дельные компоненты. Вам понадобится отыскать математические правила, которые

58
Глава 2
описывают взаимодействие этих компонентов. Иногда вклад компонента в конеч­
ный результат выражается одной величиной. Некоторые компоненты могут объеди­
нять несколько факторов, тогда как другие могут быть более сложными (подобно
тем, которые имитируют поток, приходящий к узлу).
Вы обнаружите, что обычно каждый компонент будет обладать параметрами, оп-
ределящими его влияние на модель в целом. На этой стадии достаточно просто обо­
значить каждый параметр.
Присвоение значения каждому
параметру
Как только в вашем распоряжении появились параметры, вы можете пойти напро­
лом и присвоить некое значение каждому из них. На этой стадии вы ожидаете вне­
сения некоторой ошибки. Хитрость состоит в том, чтобы понять, какие параметры
оказывают максимальное воздействие на результат, и сосредоточиться на их точ­
ном получении. Обычно параметры, чьи значения добавляются к результату, явля­
ются менее значительными, чем те, что осуществляют умножение или деление. Уд­
воение скорости канала связи может увеличить вдвое объем данных, получаемых в
течение часа, тогда как добавление транзитной задержки, равной 5 мс, не даст за­
метного эффекта.
У вас должен иметься обоснованный способ вычисления этих критических па-
оаметров. В примере с формированием очереди вы захотели измерить реальную
интенсивность входного потока транзакций в существующей системе или найти
для измерения подобную систему. Аналогично, вы могли определить время, необ­
ходимое для обслуживания запроса, или провести оценку, используя методики,
описанные в этом разделе. На самом деле, вам часто придется основывать свою
оценку на других вспомогательных оценках. Именно в этом месте и возникают са­
мые большие ошибки.
Вычисление ответов
Только в самом простом случае ваша оценка будет иметь один-единственный ответ.
Вы счастливый человек, если можете сказать: "Я могу пройти по городу пять квар­
талов за 15 минут". Но поскольку системы все усложняются, вам захочется подстра­
ховать ваши ответы. Проведите многократные вычисления, изменяя значения кри­
тических параметров, пока не выясните, какие из них действительно управляют
моделью. Серьезную помощь в этом может оказать электронная таблица. Затем
сформулируйте ваш ответ с точки зрения этих параметров. "Время отклика состав­
ляет (грубо) три четверти секунды, если система имеет :
Ti:
-'iy.SCSI и объем памяти
64 Мбайт; и одну секунду при объеме памяти 48 Мбайт". (Заметьте, что "три чет­
верти секунды" дает иное ощущение точности, нежели 750 мс)
Уже на стадии вычислений появляются ответы, которые могут показаться стран­
ными. Не спешите игнорировать их. Если ваша арифметика правильна, то, вероят­
но, ваше понимание проблемы или модель неверны. Это ценная информация.

Прагматический подход
59
Отслеживание
уровня мастерства
Мы полагаем, что было бы здорово вести учет ваших оценок, так, чтобы вы могли
оценить, насколько точным был ваш прогноз. Если общая оценка включала в себя
вспомогательные оценки, учитывайте и их. Часто будет оказываться, что ваши оценки
удачны — на самом деле, спустя некоторое время вы придете к этому.
Если оценка оказывается неверной, не стоит пожимать плечами и уходить. Стоит
выяснить, почему она отличалась от предполагаемой. Возможно, выбраны парамет­
ры, которые не соответствовали реальной проблеме. Возможно, сама модель была
неверной. Какова бы ни была причина, необходимо не спеша прояснить, что же слу­
чилось. Если сделать это, то следующая оценка будет лучше.
Оценка графиков выполнения проекта
Обычные правила оценки могут нарушаться перед лицом сложностей и капризов раз­
работки серьезной прикладной программы. Мы считаем, что зачастую единственным
способом определения графика выполнения проекта является практический опыт,
полученный при работе над этим проектом. Это не обязательно является парадоксом,
если вы практикуете разработку с помощью приращений, повторяя следующие шаги.
•
Проверить требования
•
Проанализировать риск
•
Осуществить проектирование, реализацию, интеграцию
•
Проверить правильность при работе с пользователями
Первоначально у вас может иметься лишь приблизительная оценка того, сколько
итераций понадобится или какова будет их продолжительность. Некоторые методы
требуют, чтобы вы зафиксировали это как часть первоначального плана, но для всех
методов, за исключением наиболее тривиальных, это будет ошибкой. Если вы не соз­
даете приложение, аналогичное предыдущему, с той же командой и по той же техно­
логии, вам придется делать предположения.
Итак, вы завершаете составление текста программы и проверку исходной функ­
циональной возможности и отмечаете это как конечную точку первого приращения.
Основываясь на этом опыте, вы можете уточнить ваше начальное предположение о
числе итераций и о том, что может быть включено в каждую из них. С каждым разом
уточнение становится все совершеннее, и вместе с этим растет уверенность в пра­
вильности графика.
Подсказка 19
Уточняйте график проекта на основе текста программы
Это может не понравиться руководству, которому обычно нужно единственная на­
дежная цифра еще до начала проекта. Вам придется помочь им осознать, что команда, ее
производительность и среда будут определять график выполнения. Формализуя эту про­
цедуру и уточняя график (что является частью итерационного процесса), вы сможете дать
руководству самые точные оценки графика выполнения, какие только сможете.

60
Глава 2
Что сказать, если вас просят оценить что-либо
Говорите: "Я вернусь к вам с этим позже".
Вы почти всегда можете добиться лучших результатов, если не будет торопиться и
потратите некоторое время, чтобы пройтись по всем стадиям, описанным в данном
разделе. К оценкам, сделанным на ходу (например, у офисной кофеварки), придется
возвращаться вновь и вновь (как, впрочем, и к кофе), теряя при этом покой.
Другие разделы, относящиеся к данной теме:
•
Скорость алгоритма
Вопросы д л я обсуждения
•
Заведите журнал регистрации сделанных вами оценок. Для каждой оценки
укажите, насколько точной она оказалась. Если отклонение превысило 50%,
постарайтесь выяснить, где была допущена ошибка.
Упражнения
9.
Спрашивается: какой из двух каналов обладает более широкой полосой про­
пускания: линия связи со скоростью 1 Мбайт/сек, или человек, двигающийся
от компьютера к компьютеру со стриммерной кассетой объемом 4 Гбайт в кар­
мане? Какие ограничения накладываются на ответ, чтобы гарантировать его
корректность в определенной области? (Например, можно указать, что време­
нем доступа к ленте можно пренебречь). (Ответом, в Приложении В.)

## Так какой же из двух каналов обладает более широкой полосой пропускания?


(Ответ см. в Приложении В.)

Глава 3
Походный набор
инструментов
Каждый ремесленник отправляется на поиски заработка, имея при себе походный на­
бор инструментов. Столяру могут пригодиться линейки, шаблоны, пара ножовок, не­
сколько рубанков, тонкие стамески, сверла и зажимы, киянки и струбцины. Эти инст­
рументы он будет тщательно выбирать, настраивать, каждому из них будет уготована
определенная работа, и, что наверное самое важное каждый из них, оказавшись в
умелых руках столяра, найдет свое место под солнцем.
После этого придет черед обучению и притирке. Каждому инструменту будут
присущи свои особенности (и хитрости), и каждый из них потребует, чтобы с ним об­
ращались особым образом. При работе столяр держит инструмент особым образом,
и затачивает его под особым углом. Пройдет время, и от работы инструмент изно­
сится до того, что рукоятка превратится в слепок руки столяра, а режущая поверх­
ность сравнится с углом, под которым столяр держит инструмент относительно ра­
бочей плоскости. В этот момент инструменты станут проводниками идей от головы
столяра к конечному продукту — они станут продолжением рук мастера. Пройдет
время, и в арсенале столяра прибавятся новые орудия — резальные машины, ла­
зерные станки для резки под углом, направляющие шаблоны "ласточкин хвост" —
всё это чудеса технологического
прогресса. Но можно поспорить, что по-
настоящему он счастлив только тогда, когда держит в руках инструмент из старого
походного набора и слышит, как рубанок поет свою песню, выстругивая деревянную
заготовку.
Инструменты — средство усиления вашего таланта. Чем лучше они и чем лучше
вы ими владеете, тем больше вы сможете сделать. Начните с походного универсаль­
ного набора инструментов. По мере того как вы приобретаете опыт и сталкиваетесь
с специальными требованиями, ваш набор пополняется. Стоит уподобиться ремес­
леннику и пополнять набор регулярно. Старайтесь не прекращать поисков лучшего
способа сделать что-либо. Оказавшись в ситуации, когда вы обнаруживаете, что ва­
ших инструментов недостаточно, поищите иное, возможно, более мощное средство

62
Глава 3
для осуществления задуманного. Ваши приобретения должны исходить из сущест­
вующей необходимости.
Многие начинающие программисты делают ошибку, принимая на вооружение
одно-единственное мощное инструментальное средство, в частности, конкретную ин­
тегрированную среду разработчика (ИСР), и никогда не выходят за пределы удобного
для них интерфейса. Это действительно ошибочно. Необходимо осваиваться и вне
пределов, установленных ИСР. Но это можно сделать лишь при условии, что инстру­
менты из походного набора должным образом заточены и готовы к работе.
Данная глава посвящена тому, что вкладывается в похолч,'
тй набор инструментов.
Как и в любой хорошей дискуссии об инструментах, начнем ( в разделе "Преимущест­
ва простого текста") с рассмотрения сырья — материала, которому будет придана
форма. Затем мы перейдем к верстаку — в нашем случае его роль играет компьютер.
Как использовать компьютер для извлечения максимальной пользы из инструмен­
тальных средств, находящихся под рукой? Этот аспект обсуждается в разделе "Игры с
оболочками". Теперь, когда у нас есть материал и верстак, на котором можно рабо­
тать, обратимся к инструменту, который вы наверняка будете использовать чаще все­
го, — ваш текстовый редактор. В разделе "Мощь редактирования" предлагаются
способы того, как сделать работу с ним более эффективной.
Даже для таких простых вещей, как личная адресная книжка, необходимо ис­
пользовать "Систему управления исходным текстом" как гарантию того, что даже
самая малая часть вашей драгоценной работы не канет в небытие! И поскольку от­
крыватель законов Мерфи все же был оптимистом, то вы не можете считать себя
великим программистом, пока не приобретете серьезных навыков в отладке (см.
"Отладка").
Чтобы как-то объединить большую часть элементов магии, необходимо некое свя­
зующее вещество (наподобие столярного клея). Некоторые средства, подобные awk,
Perl и Python, рассмотрены в разделе "Обработка текста".
Подобно тому как при изготовлении сложных конструкций столяры иногда пользу­
ются шаблонами, программисты могут написать программу, которая, в свою очередь,
сама генерирует текст программы. Этот вопрос обсуждается в разделе "Генераторы
исходного текста".
Уделив некоторое время изучению этих инструментальных средств, в один пре­
красный день вы удивитесь, как ваши пальцы бегают по клавиатуре, обрабатывая
текст без дополнительной нагрузки на мозг. Инструменты стали продолжением ва­
ших рук.
14 Преимущество простого текста
Основной материал, с которым работают программисты-прагматики, — не де­
рево, и не металл, а человеческое знание. Оно является форматом при сборе требо­
ваний, а затем выражается в конструкциях, реализациях, тестах и документации. И
мы уверены, что лучшим форматом для постоянного хранен./л знания является про­
стой текст. Простой текст позволяет нам обрабатывать знание, как вручную, так и с

Походный набор инструментов
63
помощью программных средств, используя практически все инструменты, имею­
щиеся у нас под рукой.
Что такое простой текст?
Простой текст состоит из печатаемых символов и представлен в некой форме, кото­
рая непосредственно может быть воспринята и понята людьми. Например, данный
фрагмент не несет в себе смысла, хотя и состоит из печатаемых символов.
Field19=467abe
Читатель и понятия не имеет, каков смысл значения 467abe. Лучше сделать его
понятным:
DrawingType=UMLActivityDrawing
Простой текст вовсе не означает, что в нем отсутствует структура; яркими приме­
рами простого текста с четко определенной структурой являются форматы XML,
SGML и HTML. С простым текстом можно проделывать все те же операции, что и с
двоичным форматом, включая управление версиями.
Простой текст имеет тенденцию находиться на более высоком уровне, чем простая
двоичная кодировка, обычно возникающая непосредственно из реализации. Предпо­
ложим, вам нужно хранить свойство под названием uses_menus, которое может при­
нимать значение TRUE или FALSE. Используя простей гскат, вы можете записать
это следующим образом:
myprop.uses_menus=FALSE
А теперь сравните это с 0010010101110101.
Проблема с большинством двоичных форматов состоит в том, что контекст, необ­
ходимый для понимания данных, отделен от самих данных. Вы искусственно отделяете
данные от их смыслового значения. Вдобавок, данные могут быть зашифрованы; они
абсолютно бессмысленны при отсутствии прикладной логики для их анализа. А с по­
мощью простого текста вы можете создать самодокументированный поток данных, не
зависящий от прикладной программы, которая его породила.
Подсказка 20
Сохраняйте знания в формате простого текста
Недостатки
Простой текст обладает двумя основными недостатками: (1) при хранении он может
занимать больше места, чем сжатый двоичный формат, и (2) с точки зрения вычис­
лений интерпретация и обработка файла с простым текстом может проводиться
медленнее.

64
Глава 3
В зависимости от приложения неприемлемыми могут оказаться одна или обе вы­
шеописанные ситуации — например, при хранении данных СПУТНИКОВОЙ телеметрии
или в случае внутреннего формата реляционной базы данных.
Но и в этих ситуациях допустимо сохранять метаданные, описывающие исходные
данные, в формате простого текста (см. "Метапрограммирование").
Некоторые разработчики боятся помещать метаданные в формате простого тек­
ста, потому что таким образом они раскрывают его содержимое пользователям сис­
темы. Эти опасения не имеют достаточных оснований. Двоичные данные могут быть
более расплывчатыми, чем простой текст, но от этого не становятся более защи­
щенными. Если вы не хотите, чтобы пользователи видели пароли, зашифруйте их.
Если вы не хотите, чтобы они изменяли параметры конфигурации, примените техно­
логию защищенного хеширования
1 ко всем значениям параметров и используйте ре­
зультат в контрольной сумме файла.
Преимущества простого текста
Поскольку "больше" и "медленнее" — не самые популярные требования, предьяв-
гаемые пользователями, то зачем вообще нужен простой текст? Каковы его преиму­
щества?
•
Гарантия того, что данные не устареют
•
Более короткий путь к цели
•
Более простое тестирование
Гарантия того, что донные не устареют
Форматы данных, которые может воспринять человек, и самодокументированные
данные переживут все другие форматы данных и приложения, их породившие.
И точка.
На протяжении всего срока жизни данных вы сможете пользоваться ими и в пер­
спективе еще долго после того, как прикладная программа, их породившая, прекратит
свое существование.
Вы сможете провести синтаксический анализ такого файла, даже не зная полно­
стью его формат; в большинстве же случаев с двоичным файлами успешный анализ
возможен лишь при знании всех особенностей формата.
Рассмотрим файл данных из некой унаследованной
2 системы . Вы обладаете скуд­
ной информацией о прикладной программе, которая создала этот файл; эта информа­
ция сводится к тому, что она поддерживала список номеров SSN (Social Security
Number — номер социального страхования) клиентов, которые вам необходимо най­
ти и извлечь из архива. Среди данных вы видите:
Для этой цели часто применяется MD5. Великолепное введение в чудесный мир крипто­
графии — книга [Sch95].
Все программы становятся унаследованным, как только они написаны.

Походный набор инструментов
65
"FIELD10"123-45-67897FIELD10"
"FIELDIO'567-89-0123 "/FIELD10"
"FIELD10"901-23-4567"/FIELD10"
Опознав формат номера S S N , можно быстро написать небольшую
программу
для извлечения этих данных — даже при отсутствии у вас иной информации об этом
файле.
Но представим, что вместо этого файл отформатирован следующим образом:
АС27123456789В11Р
XY43567890123QTYL
6Т2190123456788АМ
Не так-то легко опознать значение чисел, представленное в таком виде. В этом и
состоит разница между воспринимаемым
человеком
и понятным
человеку.
Но и от обозначения FIEL010 толку будет немного. А нечто вроде:
"SSN0"123-45-67897SSN0"
делает сие упражнение задачкой для детского сада и гарантирует, что данные пережи­
вут любой проект, их породивший.
более короткий путь к цели
Практически любой инструмент в компьютерной вселенной, от систем управления
исходными текстами до компиляторных сред, редакторов и отдельно стоящих фильт­
ров может работать с простым текстом.
Философия ОС Unix
О п е р а ц и о н н а я с и с т е м а Unix и з в е с - ' - ; тем, что о н а п р о е к т и р о в а л а с ь
н а
основе ф и л о с о ф и и небольших, отточенных инструментальных с р е д с т в , к а ­
ж д о е из которых п р е д н а з н а ч е н о для качественного выполнения только од­
ной операции. Э т а ф и л о с о ф и я р е а л и з у е т с я с помощью обычного ф у н д а ­
ментального
ф о р м а т а — строчно-ориентированного
ф а й л а
с
простым
текстом. Базы данных, используемые в с и с т е м н о м
администрировании
(учетные з а п и с и и пароли, конфигурация с е т и и т.д.), х р а н я т с я в виде ф а й ­
лов с простым текстом. (Некоторые с и с т е м ы , подобные Solaris, также под­
д е р ж и в а ю т двоичную форму конкретных б а з данных д л я оптимизации про­
изводительности.
В е р с и я с
простым
текстом
с о х р а н я е т с я в
качестве
и н т е р ф е й с а к двоичной версии).
Если в с и с т е м е происходит аварийный отказ, то при е е восстановлении мо­
жет оказаться, что вам придется работать в с р е д е с минимальным интерфей-

66
Глава 3
сом (например, вы не будете иметь доступ к графическим д р а й в е р а м ) . По­
добные
ситуации д а ю т
вам возможность оценить простоту
выбранного
представления текста.
Например, предположим, что вы развертываете крупномасштабное приложение
со сложным конфигурационным файлом, характерным для конкретного местополо­
жения (на ум сразу приходит sendmail). Если этот файл представляет собой простой
текст, то его можно подчинить системе управления исходными текстами (см. "Управ­
ление исходным текстом"), и вы автоматически сохраняете хронологию всех измене­
ний. Инструментальные средства сравнения файлов, такие как diff и fc, позволяют вам
сразу увидеть, какие изменения были внесены, тогда как su*^
1 позволяет генерировать
контрольную сумму для отслеживания файла на предмет случайных (или злонамерен­
ных) модификаций.
Более простое
тестирование
ЕСЛИ ВЫ используете простой текст при создании синтетических данных для запуска
системных тестов, то добавление, обновление или модификация тестовых данных (без
привлечения каких-либо специальных инструментальных средств) не представляет
особого труда. Аналогично, результат регрессионного тестирования в виде простого
текста может быть проанализирован тривиальным образом (например, с помощью
программы diff) или более тщательно с помощью языков Perl, Python и некоторых
других средств написания сценариев (скриптов).
Подводим итог
Вездесущий текстовый файл никуда не денется и в будущем, когда интеллектуальные
XML-базированные агенты, путешествующие по диким и опасным дебрям Интернета
в автономном режиме, будут согласовывать обмен данными между собой. Действи­
тельно, в гетерогенных операционных средах преимущества простого текста могут
перевесить все его недостатки. Необходимы гарантии того, что все стороны могут об­
мениваться информацией по общему стандарту. Таким стандартом и является простой
текст.
Другие разделы, относящиеся к данной теме:
•
Управление исходным текстом
•
Генераторы исходного текста
•
Метапрограммирование
•
Доски объявлений
•
Вездесущая автоматизация
•
Все эти сочинения

Походный набор инструментов
67
Вопросы для обсуждения
•
Требуется: спроектировать базу данных — небольшую адресную книгу (фа­
милия, номер телефона и т.д.), используя простое двоичное представление
на языке по вашему выбору. Перед тем как продолжить чтение данного про­
блемного вопроса, проделайте следующее:
1.
Преобразуйте этот формат в формат простого текста, используя XML.
2.
Для каждой из версий добавьте новое поле переменной длины под на­
званием directions, в котором вы могли бы вводить указания, как подъе­
хать к дому каждого адресата.
Какие вопросы, связанные с управлением версиями и расширяемостью, мо­
гут возникнуть? Какую форму легче модифицировать? Как обстоит дело с
преобразованием уже существующих данных?
15 Игры с оболочками
Каждому столяру нужен хороший, солидный, надежный верстак — место, располо­
женное на удобной для столяра высоте, на котором он в ходе своей работы мог бы
разместить предметы труда. Верстак становится центром мастерской, ремесленник
возвращается к нему снова и снова, придавая форму материалу.
Для программиста, обрабатывающего файлы или текст, подобным верстаком яв­
ляется командная оболочка. Находясь в командной строке, вы можете задействовать
весь свой арсенал инструментов, комбинируя их такими способами, о которых их раз­
работчики и не мечтали. Из оболочки вы можете запускать приложения, отладчики,
браузеры, редакторы и утилиты. Вы можете осуществлять поиск файлов, опрашивать
состояние системы и осуществлять фильтрацию выходных данных. Для часто исполь­
зуемых процедур вы можете создавать сложные макрокоманды, используя встроен­
ный язык.
Для программистов, выросших на графических интерфейсах и ИСР, это может по­
казаться экстремизмом. В конце концов, разве нельзя проделать все операции с рав­
ным успехом, указывая на объект и щелкая кнопкой мыши?
Ответ прост: "Нет". Графические интерфейсы сами по себе прекрасны, и с их по­
мощью многие простые операции выполняются быстрее и с большим удобством. Пе­
ремещение файлов, чтение сообщений электронной почты с кодировкой MIME и на­
бор текстов писем — это все то, что вы хотели бы осуществлять в графической среде.
Но если вы делаете всю работу, используя графический интерфейс, то используете
далеко не все возможности, предоставляемые операционной системой. И вам не уда­
стся автоматизировать обычные задачи или использовать доступные инструменталь­
ные средства в полную силу. И вы не сможете комбинировать свои средства для соз­
дания
специализированных
макроинструментов.
Преимуществом
графического
интерфейса пользователя является принцип WYSIWYG (что видишь, то и получа­
ешь). Недостатком графического интерфейса можно назвать принцип WYSJAYG —
получаешь только то, что видишь.

68
Глава 3
Графические среды обычно ограничены возможностями, заложенными в них
разработчиками. Если вам необходимо выйти за пределы модели, созданной разра­
ботчиком, то обычно фортуна отворачивается от вас, однако чаще всего вам все-
таки приходится выходить за пределы модели. Прагматики не просто "рубят" текст,
разрабатывают объектные модели, пишут документацию или автоматизируют про­
цесс сборки — они делают все вышеперечисленное. Сфсрг: применения любого
конкретного инструмента обычно ограничена задачами, решения которых от него
ожидают. Предположим, что возникла необходимость в интеграции препроцессора
исходного текста с ИСР (при реализации концепции "проектирования по контрак­
ту", многопроцессных директив и т.п.). Если разработчик ИСР явно не предусмот­
рел наличия в ней специальных средств, то вы не справитесь с решением задачи ин­
теграции.
Если вы уже освоились с работой в режиме командной строки, то можете спокой­
но пропустить данный раздел. В противном случае вам необходимо заручиться друже­
ским расположением со стороны командной оболочки.
Исповедуя прагматизм, вы постоянно будете испытывать потребность в осуще­
ствлении операций ad hoc {лат. для конкретного случая. — Прим. пер.) — это и
есть те самые случаи, когда графический интерфейс может оказаться непримени­
мым. Командная строка может стать лучшим решением, если необходимо быстро
скомбинировать несколько команд при выполнении запроса или иного задания.
Ниже приводится несколько примеров.
Найти все файлы типа *.с, модифицированные позже,
чем ваш Makefile.
Командная строка
find . --name ' * . с ' --newer Makefile --print
Графический
Откройте Проводник Windows, перейдите в нужный ката-
интерфейс
лог., щелкните на Makefile и отметьте для себя время моди­
фикации данного файла, Затем войдите в меню Tools, выбе­
рите пункт Find, и введите *.с в строку, указывающую пара­
метры имени файла. Затем перейдите в поле даты, и введите
дату, которую вы вначале отметили для Makefile. Затем на­
жмите ОК.
Создать архив типа zip/tar моего исходного текста.
Командная строка
zip archive.zip *.h *.с или tar cvf archive, tar *.h *.c
Графический
Запустите утилиту архивирования (например, условно-
интерфейс
бесплатную программу WinZip [URL 41], выберите пункт
Create New Archive, введите его имя, выберите исходный
каталог в диалоге Add, задайте фильтр "*.с", щелкните на
пункте "Add", задайте фильтр "*.h", щелкните на пункте "Add",
затем закройте архир.

Походный набор инструментов
69
Какие файлы Java не были изменены за последнюю неделю?
Командная строка
find . name '*.java' --mtime + 7 --print
Графический
Щелкните и переместитесь к пункту "Find files", щелкните на
интерфейс
поле "Named" и введите в него "*.java", выберите пункт "Date
Modified". Затем выберите пункт "Between". Затем щелкните
на начальной дате и введите начальную дату начала проекта.
Щелкните на конечной дате и введите дату, которая была неде­
лю назад (убедитесь, что календарь находится под рукой). Затем
щелкните на пункте "Find Now".
Какие из этих файлов используют библиотеки awt?
Командная строка
find . --name '*.java' -- mtime +7 —print | xargs grep
'java.awt'
Графический
Загрузите каждый файл в списке из предыдущего примера в
интерфейс
редактор и проведите поиск строки java. awt. Напишите имя
каждого файла, содержащего совпадение.
Ясно, что этот список может быть продолжен. Строчные команды могут быть не­
понятными и компактными, но они обладают мощностью и краткостью. И поскольку
они могут сводиться в файлы сценариев (или командные файлы в системе Windows),
то вы можете создавать последовательности команд для автоматизации часто выпол­
няемых процедур.
Подсказка 21
Используйте сильные стороны командных оболочек
Освойте работу с оболочкой, и вы обнаружите, как выросла ваша производитель­
ность. Нужно создать перечень всех уникальных имен пакетов, которые явно импор­
тируются вашей программой на языке Java? Приведенная ниже программа сохраняет
этот перечень в файле под названием "list".
grep '"import ' *.java |
sed - - e ' s / . "import / / ' —e's/;.. $ / / ' I
sort —и >list
Если вам еще не приходилось часами изучать возможности командной оболочки
систем, с которыми вы работаете, то это занятие может показаться устрашающим.
Тем не менее, приложите некоторое усилие для ознакомления с оболочкой, и вскоре
все станет на свои места. Поиграйте с вашей командной оболочкой, и вы удивитесь,
насколько продуктивнее станет ваша работа.

70
Глава 3
Утилиты оболочек и системы Windows
Хотя командные оболочки, поставляемые с системами Windows, постепенно улучша­
ются, утилиты командной строки Windows все еще уступают их двойникам в Unix. Од­
нако все не так плохо.
Фирма Cygnus Solutions разработала пакет под названием Cygwin [URL 31]. По­
мимо обеспечения слоя совместимости Unix для Windows, Cygwin поставляется вме­
сте с коллекцией более чем 120 утилит Unix, включая такие бестселлеры, как Is, grip
и find. Утилиты и библиотеки могут загружаться и использоваться бесплатно, но обя­
зательно прочтите их лицензию

## Программа Cygwin распространяется вместе с обо­


лочкой Bash.
Использование инструментальных средств Unix при работе
в среде Windows
Нам нравится, что высококачественные инструментальные с р е д с т в а Unix
р а б о т а ю т под Windows, и мы пользуемся ими ежедневно. О д н а к о н а д о
иметь в виду, что существуют проблемы интеграции. Эти утилиты (в отличие
от их двойников, р а б о т а ю щ и х под MS-DOS) чувствительны к регистру в име­
нах файлов, так что к о м а н д а Is а * . b a t не с м о ж е т найти ф а й л AUTOEXEC.BAT.
Вы можете также столкнуться с п р о б л е м а м и , вызванными ф а й л а м и , чьи
и м е н а с о д е р ж а т пробелы, и с различиями в разделителях пути. Наконец,
е с т ь проблемы, связанные с з а п у с к о м из-под оболочек Unix программ MS-
DOS, в которых о ж и д а е т с я наличие аргументов в стиле MS-DOS. Например,
утилиты J a v a , н а п и с а н н ы е фирмой J a v a S o f t , используют двоеточие (как и в
их р а з д е л и т е л е CLASSPATH при р а б о т е в с р е д е Unix), а при р а б о т е в MS-
DOS используют точку с запятой. В результате с ц е н а р и й Bash или ksh, з а ­
п у с к а е м ы й в окне Unix, будет р а б о т а т ь также и из-под Windows, но команд­
ная с т р о к а , п е р е д а в а е м а я ею J a v a , будет интерпретироваться некор­
ректно.
В качестве альтернативы Дэвид. Корн (автор известной оболочки Копт) создал па­
кет под названием UWIN. Он предназначен для тех же целей, что и продукт Cygwin —
Генеральная общая лицензия GNU [URL 57] является разновидностью легального вируса,
который используется разработчиками программ с открытым текстом для защиты своих
(и ваших) прав. Стоит уделить время ее изучению. В сущности, она говорит о том, что
пользователь может использовать и модифицировать программы с генеральной общей ли­
цензией, но если он распространяет модифицированные программы, то они подлежат соот­
ветствующему лицензированию (и маркироваться как таковые), а исходный текст должен
быть открыт. Это и есть часть вируса — если программа создается на основе лицензиро­
ванной программы, то первая также подлежит лицензированию. Тем не менее, пользова­
тель не ограничен никоим образом при использовании инструментальных средств — право
собственности и лицензирование программ, разработанных при помощи указанных
средств, находятся на усмотрении пользователя.

Походный набор инструментов
71
это среда разработчика Unix, работающая в среде Windows. Пакет UWIN распро­
страняется с оболочкой Когп. Коммерческие версии поставляются фирмой Global
Technologies, Ltd. [URL 30]. Кроме того, фирма AT&T допускает бесплатную загрузку
пакета для оценки его работы и использования в академических учреждениях. Перед
его использованием также необходимо прочесть лицензию.
И наконец, Том Кристиансен (во время написания книги) компонует Perl Power
Tools, пытаясь в сжатом виде реализовать все известные утилиты Unix на языке Perl
[URL 32].
Другие разделы, относящиеся к данной теме:
•
Вездесущая автоматизация
Вопросы д л я обсуждения:
•
Существуют ли операции, которые в данное время вам приходится выпол­
нять вручную, работая в графической среде? Приходилось ли вам когда-либо
сочинять для коллег по работе инструкции, состоящие из отдельных пунктов
типа: "щелкните на этой кнопке", "выберите этот пункт"? Можно ли авто­
матизировать этот процесс?
•
При переходе к новой операционной среде обратите особое внимание на то,
какие оболочки находятся в вашем распоряжении. Посмотрите, можете ли
вы перенести в новую среду оболочку, с которой работаете в данный момент.
•
Изучите возможные альтернативы оболочке, используемой вами в настоя­
щее время. Если вы сталкиваетесь с проблемой, которую невозможно ре­
шить средствами имеющейся у вас оболочки, может быть, альтернативная
оболочка проявит себя лучше?
16 Мощь редактирования
Выше уже говорилось об инструментах, которые являются продолжением вашей
руки. Это положение применимо к текстовым редакторам в большей степени, нежели
к любому другому инструменту. Необходимо, чтобы вы затрачивали минимальные
усилия на обработку текста, поскольку последний является основным "сырьем" при
программировании. Рассмотрим некоторые общие характеристики и функции, кото­
рые помогают использовать ваш текстовый редактор с максимальным КПД.
Один-единственный редактор
Мы полагаем, что лучше овладеть одним-единственным редактором, но в совершенст­
ве, и использовать его для всех задач, связанных с редактированием: работа с текстом
программ, документацией, записками, системное администрирование и т. д. Не имея
под рукой хотя бы одного редактора, можно оказаться в ситуации, аналогичной вави­
лонскому смешению языков, но уже на современный манер. При написании текстов
программ может понадобиться встроенный редактор ИСР (для каждого языка), для

72
Глава 3
создания документации — универсальный офисный редактор, а может быть, и еще
один встроенный редактор для отправки сообщений по электронной почте. Различаться
могут даже клавиатурные команды, используемые вами для редактирования командных
строк в оболочке

## Трудно быть экспертом в любой из этих программных сред, если в


каждой из них имеется свой набор команд и соглашений при редактировании.
Но экспертом быть необходимо. Мало набирать символы построчно и использо­
вать мышь для вырезания и вставки фрагментов. Работая подобным образом, вы не
достигнете того уровня производительности, который возможен при наличии мощно­
го текстового редактора. Десятикратное нажатие клавиши <- или Backspace для пе­
ремещения курсора влево к началу строки не столь эффективно, как простая клавиа­
турная команда, например Ctrl+A, Home или 0.
Подсказка 22
Используйте один текстовый редактор, но по максимуму
Выберите какой-либо редактор, тщательно изучите его и используйте во всех за­
дачах, связанных с редактированием текста. Если вы пользуетесь одним редактором
(или набором функциональных клавиш) для всех работ, связанным с редактировани­
ем текста, то вам не придется останавливаться и обдумывать, как осуществить ту или
иную обработку текста: нажатие нужных клавиатурных команд становится рефлек­
сом, редактор — продолжением вашей руки: клавиши поют свою песню, перемеща­
ясь по тексту сквозь череду мыслей. Это и есть цель!
Убедитесь, что выбранный вами редактор поддерживается всеми платформами, с
которыми вы работаете. Редакторы Emacs, vi, CRISP, Brief и ряддругих поддержива­
ются несколькими платформами, часто в двух версиях — в графической и неграфиче­
ской (текстовый режим).
Средства редактирования
Помимо тех средств, которые вы считаете особенно полезными и удобными, имеется
ряд основных возможностей, которыми, по нашему мнению, должен обладать любой
приличный редактор. Если в вашем редакторе отсутствует любая из этих возможно­
стей, то, вероятно, настало время поразмыслить о переходе к более продвинутому ре­
дактору.
•
Настраиваемость. Все свойства редактора должны настраиваться по ва­
шему пожеланию, включая шрифты, цвета, размеры окон и клавиатурные
привязки (команды, исполняемые при нажатии той или иной клавиши).
Применение только клавиатурных сочетаний в ходе обычных операций ре­
дактирования является более эффективным по сравнению с мышью или
командами в меню, поскольку руки не отрываются от клавиатуры.
В идеальном случае используемая оболочка должна иметь те же клавиатурные привязки,
что и редактор. Например, Bash поддерживает клавиатурные привязки редакторов vi и
emacs.

Походный набор инструментов
73
•
Расширяемость. Редактор не должен устаревать только потому, что появля­
ется новый язык программирования. Он должен обладать способностью ин­
тегрироваться в любую компиляторную среду, используемую вами в данный
момент. Вы должны "обучить" его нюансам любого нового языка програм­
мирования или текстового формата (XML, HTML версии 9 и т. д.).
•
Программируемое™. Вы должны располагать возможностью программи­
рования редактора для осуществления сложных многоступенчатых опера­
ций. Это может осуществляться при помощи макросов или встроенного язы­
ка программирования сценариев (к примеру, редактор Emacs использует
вариант языка Lisp).
В дополнение к этому многие редакторы поддерживают средства, которые свойст­
венны конкретному языку программирования:
•
Выделение синтаксических конструкций
•
Автоматическое завершение
•
Автоматический отступ
•
Библиотека исходных стандартных текстов или документов
•
Принудительная справка, выдаваемая системой
•
Средства, подобные ИСР (компиляция, отладка и т. д.).
import Java.util.Vector
import Java.util.Stack;
import Java.net.URL;
import java.awt.*;
emacs: M-x sort-lines
v i :
:.,+3!sort
import java.awt.*;
import Java. net.URL;
import Java.util.Stack;
import Java. util.Vector;
Рис. 3.1.
Упорядочение строк в редакторе
Такое средство, как выделение синтаксических конструкций, может показаться
необязательной фривольностью, но в реальности оно весьма полезно и улучшит вашу
производительность. Вы быстро привыкнете к тому, что ключевые слова отобража­
ются разным цветом или шрифтом, а неправильно набранное ключевое слово, кото­
рое отображается по-другому, бежит на вас как зверь на ловца, задолго до того, как
вы запустите компилятор.
Возможность компиляции и обнаружения ошибок непосредственно в среде редак­
тирования является весьма удобным при работе над большим проектами. Привер­
женцем подобного стиля взаимодействия является, в частности, редактор Emacs.
Производительность
Удивительно, но многие люди, с которыми нам довелось встречаться, используют для
редактирования исходных текстов программ утилиту notepad, входящую в систему
Windows. Это сильно напоминает использование чайной ложечки вместо совковой

74
Глава 3
лопаты — примитивный набор текста и использование основных команд ("вырезать-
вставить"), активизируемых с помощью мыши, явно недостаточны.
Какие же процедуры могут потребовать от вас большего, чем примитивные дейст­
вия, описанные выше?
Начнем с перемещения курсора. Некоторые клавиатурные команды, перемещаю­
щие вас по словам, строкам, блокам или функциям, являются более эффективными
по сравнению с повторным нажатием одной и той же клавиши, перемещающей кур­
сор от символа к символу или от строки к строке.
Или предположим, что вы пишете программу на языке Java. Вам нравится поддер­
живать ваши операторы import в алфавитном порядке, но кто-то чужой зарегистриро­
вал несколько файлов, не отвечающих этому стандарту. Вы хотели бы пробежать по
нескольким файлам и упорядочить некоторую их часть. Это легко сделать при работе
с редакторами типа vi и Emacs (см. рис. 3.1). А попробуйте сделать то же самое в ре­
дакторе notepad!
Некоторые редакторы могут помочь в усовершенствовании обычных операций.
Например, когда вы создаете новый файл на определенном языке программирования,
редактор может подобрать для вас нужный шаблон. Он может включать в себя:
•
Наименование создаваемого класса или модуля (определенного из имени
файла)
•
Ваше имя и/или знак авторского права
•
"Скелеты" конструкций на данном языке (например, описания конструктора
или деструктора)
Другим полезным средством является автоматический отступ. В нужный момент
редактор автоматически делает отступы (например, при вводе открывающей скобки),
и не нужно проделывать ту же операцию вручную (используя пробел или табуляцию).
Преимуществом этого средства является то, что вы можете использовать редактор
для обеспечения постоянства стиля отступа в вашем проекте
1.
Куда же направиться?
Советы подобного рода особенно трудно формулировать, поскольку практически все
читатели находятся на различных уровнях владения редактором (или редакторами),
которым они пользуются в данный момент, и имеют различный опыт работы с ним.
Поэтому, чтобы подвести итог и сформулировать некоторые указания относительно
того, куда же двигаться дальше, отыщите то, что соответствует вам, в левом столбце
таблицы, а затем, чтобы узнать наше мнение обо всем этом, взгляните на правый
столбец.
Подобным образом разработано ядро Linux. В данном случае имеются разработчики, раз­
бросанные географически, многие из которых работают над одними и теми же фрагмента­
ми текста. Опубликован перечень установочных параметров (в данном случае для редакто­
ра Emacs), содержащий описание требуемого стиля отступов.

Походный набор инструментов
75
Если это похоже на вас:
Я пользуюсь
только
основными
средствами
многих
разнообраз­
ных
редакторов.
У меня есть любимый
редактор,
но я не использую все его
средства
У меня есть любимый
редактор
и я использую
его везде,
где
только
возможно.
Я думаю, что вы говорите
ерун­
ду. Notepad является
самым луч­
шим редактором
из
когда-либо
созданных.
Тогда задумайтесь о следующем:
Выберите мощный редактор и изучите его хо­
рошенько.
Изучите эти средства. Сократите число ис­
пользуемых клавиатурных команд.
Постарайтесь расширить свои познания и ис­
пользуйте его для большего числа задач, по
сравнению тем, что вы используете сегодня.
Пока вы счастливы и продуктивны, используй­
те notepad! Но если вы окажетесь подвержены
чувству "редакторской зависти", возможно,
что вы пересмотрите свою позицию.
Какой же редактор выбрать?
Советуем освоить приличный редактор, но какой же именно? Уклонимся от ответа
на этот вопрос: выбор редактора является личным делом каждого (некоторые даже
скажут, что выбор редактора связан с вероисповеданием!). В приложении А приведен
список популярных редакторов и мест, откуда их можно загрузить.
Вопросы для обсуждения
•
Некоторые редакторы используют полномасштабные языки для настройки и
создания сценариев. Например, в редакторе Emacs используется язык про­
граммирования Lisp. В качестве одного из новых языков, который вы наме­
тили изучить в этом году, изучите язык, используемый вашим редактором.
Разработайте набор макросов (или эквивалентных им средств) для всех опе­
раций, которые вам приходится осуществлять повторно.
•
А знаете ли вы все, на что способен ваш редактор? Попытайтесь подзадорить
ваших коллег, которые работают с тем же редактором. Попробуйте выпол­
нить любое задание, связанное с редактированием, используя как можно
меньшее число клавиатурных команд.
17 Управление исходным текстом
программ
Прогресс не проявляется
лишь в
изменениях
и зависит
от цепкости
памяти.
Те, кто не
учится
на своих ошибках,
обречены повторять
их.
Джордж Сантаяна, Жизнь
разума
Одним из наиболее важных свойств, которые интересуют нас в интерфейсе поль­
зователя, является кнопка UNDO — единственная кнопка, которая прощает нам

76
Глава 3
наши ошибки. Еще лучше, если графическая среда поддерживает многоуровневый от­
кат и повтор так, что можно вернуться назад и восстановить статус-кво, существовав­
ший за несколько минут до этого. Но как быть, если ошибка произошла на прошлой
неделе и за прошедшее время компьютер включался и выключался раз десять? Это и
является одним из многих преимуществ системы управления исходным текстом про­
грамм: она является своего рода гигантской клавишей UNDO — машиной времени,
работающей в масштабах проекта, которая способна вернуть вас к безмятежным
дням на прошлой неделе, когда программа реально компилировалась и запускалась.
Системы управления исходным текстом (или в более широком смысле системы
управления конфигурацией) отслеживают любые изменения, которое вносятся в ис­
ходный текст и документацию. Лучшие системы также могут отслеживать версии ком­
пилятора и операционной системы. С помощью системы управления исходным тек­
стом, сконфигурированной
надлежащим
образом,
всегда
можно
вернуться
к
предыдущей версии вашей программы.
Но система управления исходным текстом (английская аббревиатура SCCS
1) дает
много больше, чем просто отмену ошибочных действий. Хорошая система позволяет
отслеживать изменения и дает ответы на характерные вопросы: "Кто внес изменения
в данную строку текста? В чем состоит разница между версией, существующей на
данный момент, и версией, существовавшей на прошлой неделе? Сколько строк тек­
ста программы были изменены в данной версии? Какие файлы изменяются чаще все­
го?" Подобная информация бесценна при отслеживании ошибок, аудите, оценке про­
изводительности и качества.
Система управления также позволяет проводить идентификацию версий програм­
мы. После идентификации вы всегда сможете вернуться к нужной версии и восстано­
вить ее, независимо от более поздних изменений.
Системы управления часто используются для управления ответвлениями в древо­
видной схеме разработки. Например, после выпуска некоторой программы обычно
возникает желание продолжить ее разработку и выпустить новую версию. Но при
этом приходится работать над ошибками в текущей версии и передавать заказчикам
исправления. Фрагменты с устраненными ошибками должны перейти (если это при­
емлемо) в последующую версию, но незаконченная программа не должна попасть к
заказчикам. Всякий раз, когда вы генерируете версию в целом, при помощи системы
управления можно сгенерировать и ответвления в древовидной схеме разработки.
Ошибки, имеющиеся в ответвлении, устраняются с одновременным продолжением
работ по усовершенствованию ствола. Так как устраняемые ошибки могут иметь от­
ношение и к стволу, то некоторые системы управления позволяют автоматически рас­
пространить определенные изменения, сделанные в ответвлении, обратно на ствол
древовидной схемы.
Системы управления могут сохранять поддерживаемые ими файлы в централизо­
ванной БД проекта — лучшем кандидате на архивирование.
В книге используется английская аббревиатура SCCS (заглавные буквы), которая обозна­
чает системы управления исходным текстом вообще. Помимо этого, существует также осо­
бая система управления, обозначаемая sees (строчные буквы), изначально выпущенная
фирмой AT&T вместе с Unix System V.

Походный набор инструментов
77
И наконец, некоторые программные продукты позволяют двум и более пользова­
телям работать одновременно с одним и тем же набором файлов и даже вносить изме­
нения в один и тот же файл одновременно. Затем система управляет слиянием этих
изменений при возвращении этих файлов в централизованную БД проекта. При всей
кажущейся рискованности, на практике подобные системы полезны в работе с проек­
тами различного масштаба.
Подсказка 23
Всегда используйте управление исходным текстом
программы
Всегда. Даже если ваша команда состоит из одного человека и продолжительность
проекта составляет одну неделю. Даже если это есть прототип на выброс. Даже если
материал, с которым вы работаете, не является исходным текстом программы. Убеди­
тесь, что все находится под контролем — документация, номера телефонов, записки
поставщикам, сборочные файлы, процедуры сборки и выпуска, крохотный сценарий
(в оболочке), прожигающий эталонный компакт-диск, словом — все. Обычно мы ис­
пользуем управление исходным текстом в отношении всего того, что мы набираем
(включая текст данной книги). И даже если мы не работаем над проектом, каждоднев­
ная работа надежно сохраняется в централизованной БД.
Сборки и управление исходным
текстом
Если весь проект находится под защитой системы управления исходным текстом, то
он обладает огромным скрытым преимуществом: вы может создавать сборки про­
граммы, которые являются автоматическими и воспроизводимыми.
Механизм сборки проекта может автоматически извлекать последнюю версию ис­
ходного текста из централизованной БД. Этот механизм может запускаться среди
ночи, после того как все сотрудники (будем надеяться на это) уйдут домой. Вы можете
автоматически прогонять регрессионные тесты для гарантии того, что исходные тек­
сты, созданные в течение рабочего дня, ничего не нарушили. Автоматизация сборки
обеспечивает согласованность — отсутствуют ручные процедуры, и вам не нужно,
чтобы разработчики помнили о копировании созданного ими текста в специальную
сборочную область.
Сборка является воспроизводимой, так как вы всегда можете заново собрать ис­
ходный текст в том виде, в каком он существовал на указанную календарную дату.
Команда, в которой я работаю, не использует
систему управления исходным текстом
Как же им не стыдно! Звучит как перспектива провести очередную Реформацию! Од­
нако, пока вы дождетесь, когда они увидят свет во тьме, стоит попробовать внедрить
свою, частную систему управления. Воспользуйтесь одним из бесплатных инструмен­
тальных средств, указанных в приложении А, и обратите особое внимание на то, что­
бы результаты вашей личной работы были надежно сохранены в централизованной

78
Глава 3
БД. Хоть это и может показаться двойной работой, мы с уверенностью можем ска­
зать, что эта процедура сбережет ваши нервы (и сэкономит деньги, отпущенные на
проект) в тот момент, когда вам впервые придется ответить на вопросы типа "Что ты
натворил с модулем xyz?" и "Кто разрушил сборку?" Подобный подход поможет вам
убедить руководство в том, что система управления исходным текстом действительно
работает.
Не забывайте, что система управления в равной степени применима и к тому, с
чем вы имеете дело помимо основной работы.
Программы управления исходным текстом
В приложении А приведены интернет-ссылки (URL) на типичные системы управле­
ния исходным текстом — некоторые из них являются коммерческим продуктами, дру­
гие же распространяются бесплатно. Имеются и другие программные продукты —
обратите внимание на ссылки на часто задаваемые вопросы (FAQ) по управлению
конфигурацией.
Другие разделы, относящиеся к данной теме:
•
Ортогональность
•
Преимущество простого текста
•
Все эти сочинения
Вопросы для обсуждения
•
Даже если у вас нет возможности использовать систему управления исход­
ным текстом на работе, установите RCS или CVS на личный компьютер.
Воспользуйтесь ей для управления вашими домашними проектами, докумен­
тами, которые вы составляете, и (возможно) изменениями в конфигурации
самой компьютерной системы.
•
Обратите внимание на некоторые из проектов с открытыми исходными текста­
ми, архивы которых доступны в сети Интернет (например, Mozilla [URL 51],
KDE [URL 54] и Gimp [URL 55]). Каким образом вы получаете обновления ис­
ходного текста? Как вы вносите изменения — сам проект регулирует доступ,
или же разрешает внесение изменений?
18 Отладка
Смотреть
себя, зреть муки
свои,
Зная, что сам ты виновник
мук, —
Вот истинное
страданье
Софокл, Аякс
Английское слово bug (ошибка) используется для описания "объекта, вызываю­
щего ужас" уже начиная с XIV в. Контр-адмирал д-р Грэйс Хоппер (создатель языка
COBOL) оказался первым, кто наблюдал компьютерного "жучка", буквально —

Походный набор инструментов
79
моли, попавшей в одно из электромеханических реле, из которых состояли первые
вычислительные системы. Когда техника просили объяснить, почему машина ведет
себя не так, как надо, он сообщал, что в системе "завелся жучок", и в соответствии со
своими должностными обязанностями приклеивал его клейкой лентой вместе с кры­
лышками и всем остальным в рабочий журнал.
К сожалению, мы до сих пор встречаемся с "жучкамг." в системе, хотя и не из рода
перепончатокрылых. Но значение этого слова, принятое в XIV в., — привидение —
возможно, более применимо сейчас, нежели тогда. Изъяны в программном обеспече­
нии проявляют себя по-разному — от превратно истолкованных требований до оши­
бок в написании исходных текстов. К сожалению, возможности современных компью­
терных систем все еще ограничены исполнением только того, что мы им прикажем, не
обязательно тем, что мы хотим, чтобы они сделали.
Никто не создает совершенное программное обеспечение, так что примите как
данность тот факт, что отладка будет занимать большую часть вашего рабочего дня.
Рассмотрим некоторые аспекты, вовлеченные в процесс отладки, и некоторые уни­
версальные стратегии поиска неуловимых ошибок.
Психология процесса отладки
Сама по себе отладка является щепетильным и нервирующим моментом для многих
разработчиков. Вместо того, чтобы наброситься на нее, как на головоломку, которая
должна быть решена, вы можете встретиться с отрицанием, неубедительными отго­
ворками и просто апатией.
Воспользуйтесь тем фактом, что отладка представляет собой не что иное, как ре­
шение задачи, и атакуйте ее именно с этой позиции.
Обнаружив чью-то ошибку, вы можете тратить время и силы на обвинения мерз­
кого преступника, ее допустившего. В некоторых сферах деятельности это является
частью культуры и обладает свойством катарсиса. Однако в технической сфере вы хо­
тите сконцентрироваться на устранении проблемы, а не на снятии обвинений.
Подсказка 24
Занимайтесь устранением проблемы, а не снятием обвинений
На самом деле, не важно, кто виноват в ошибке — вы или кто-то другой. Это все
равно остается вашей проблемой.
Умонастроение отладки
Обманывать
самого себя легче
всего.
Эдвард Булвер-Литтон,
Отвергнутый
Перед тем как начать отладку, важно настроиться. Необходимо отключить многие
средства безопасности, которые вы ежедневно используете для защиты собственного
"я", сбросить проектный прессинг, под которым вы можете находиться, и успокоить­
ся. Прежде всего, помните первое правило отладки:

80
Глава 3
С чего начать?
Перед тем как взглянуть на ошибку, убедитесь, что вы работаете над программой, ко­
торая прошла стадию компиляции чисто — без предупреждений. Обычно мы уста­
навливаем уровни предупреждения компиляторов максимально высокими. Нет смыс­
ла тратить время в попытках найти проблему, которую не смог найти и компилятор!
Необходимо сосредоточиться на более сложных насущных проблемах.
Пытаясь решить любую проблему, нужно собрать все относящиеся к делу дан­
ные. К сожалению, отчеты об ошибках не являются точной наукой. Легко впасть в
заблуждение из-за совпадений, а вы не можете позволить себе тратить время на ис­
следование причин совпадений. Необходимо быть точным в ваших наблюдениях из­
начально.
Точность отчетов об ошибках снижается еще больше, когда их просматривает тре­
тья сторона — в реальности может оказаться, что вам придется наблюдать за дейст­
виями пользователя, который сообщил об ошибке, чтобы добиться достаточного
уровня детализации.
Однажды один из авторов книги (Энди Хант) работал над большим графическим
приложением. Дело уже шло к выпуску готовой версии, когда тестировщики сообщи­
ли о том, что приложение "падало" всякий раз, когда они проводили черту при помо­
щи конкретной кисти. Программист начал оспаривать это утверждение, говоря о том,
что все в порядке: он сам пытался выполнять аналогичную прорисовку, и все работа­
ло превосходно. Обмен "любезностями" продолжался в течение нескольких дней, по­
сле чего напряженность резко возросла.
В конце концов все собрались в одной комнате. Тестировщик выбрал нужный ин­
струмент (кисть) и провел черту из ПРАВОГО ВЕРХНЕГО угла к НИЖНЕМУ
ЛЕВОМУ углу. Приложение "упало"! Программист тихонько охнул, а затем виновато
Подсказка 25
Не паникуйте
Легко впасть в панику, особенно если вы связаны контрольными сроками или ра­
ботаете с нервным руководителем или заказчиком, стоящим у вас наддушой в то вре­
мя, когда вы пытаетесь найти причину ошибки. Но очень важно сделать шаг назад и
подумать над тем, что же на самом деле является первопричиной симптомов, которые,
по вашему убеждению, являются ошибкой.
Если ваша первая реакция после обнаружения ошибки или просмотра отчета об
ошибках сводится к восклицанию "это невозможно!", то вы явно ошиблись. Не стоит
тратить ни одного нейрона на цепочку умозаключений, начинающуюся с фразы "но
этого не может быть!", потому что совершенно ясно, что может, и это произошло.
Остерегайтесь близорукости во время отладки. Воспротивьтесь желанию устра­
нить лишь те признаки, которые видны невооруженным глазом: скорее всего, дейст­
вительная причина может находиться в нескольких шагах от того, что вы наблюдаете,
и может включать ряд сопутствующих проблем. Всегда пытайтесь обнаружить глу­
бинную причину проблемы, а не ее частное проявление.

Походный набор инструментов
81
проблеял, что при тестировании он проводил черту только из НИЖНЕГО ЛЕВОГО
угла к ВЕРХНЕМУ ПРАВОМУ углу, и при этом ошибка никак не выявлялась.
В этой истории есть два момента, заслуживающих внимания:
•
Может возникнуть необходимость в опросе пользователя, который сообщил
о присутствии ошибки, для того чтобы собрать больше данных, чем было
дано изначально.
•
Искусственные тесты (такие, как одна-единственная черта, проведенная
"кистью" снизу вверх) недостаточны для испытания приложения. Необходи­
мо осуществлять тестирование обоих граничных условий и реалистических
шаблонов действия конечного пользователя. Это нужно делать систематиче­
ски (см. "Безжалостное тестирование").
Стратегии отладки
Если вы уверены, что знаете, в чем дело, пора выяснить, как сама программа относит­
ся к происходящему.
Воспроизведение ошибок
Нет, наши ошибки н а с а м о м д е л е не размножаются (хотя некоторые из них,
возможна достаточно стары, чтобы делать это уже на законных основаниях).
Мы говорим о другом с п о с о б е
размножения.
Начать устранение ошибки лучше всего с придания ей свойства воспроизво­
димости. В конце концов, е с л и вы не можете воспроизвести е е , то как узнать,
что она вообще у с т р а н е н а ?
Но нам нужно нечто большее, чем ошибка, которая воспроизводится с помо­
щью некоторой последовательности операций; нам нужна ошибка, которую
можно воспроизвести при помощи одной-единственной
команды.
Процеду­
р а устранения ошибки многократно усложняется, когда вам приходится вы­
полнять 15 операций, чтобы д о б р а т ь с я д о м е с т а , где э т а ошибка выявляется.
В ряде случаев вы можете интуитивно понять, как можно устранить ошибку,
заставив с е б я абстрагироваться от тех обстоятельств е е проявления.
Другие идеи, к а с а ю щ и е с я
вышеприведенного,
представлены
в р а з д е л е
" В е з д е с у щ а я автоматизация".
Сделайте ваши данные наглядными
Пристальный взгляд на данные, с которыми работает программа, во многих случаях
является лучшим способом увидеть то, что же она делает (или собирается делать).
Простейшим примером этого является прямолинейный подход типа "переменная =
значение", который может быть реализован в виде печатного текста или в виде полей
диалогового окна (списка) графического интерфейса.

82
Глава 3
Но вы можете проникнуть в суть данных намного глубже, используя отладчик, кото­
рый позволяет визуализировать данные и все существующие отношения между ними.
Существуют отладчики, которые могут представить ваши данные с высоты полета над
трехмерным ландшафтом виртуальной реальности или в виде трехмерного временного
графика сигналов, или же просто в виде обычных блок-схем, как показано на рис. 3.2.
По мере того, как вы перемещаетесь шаг за шагом по вашей программе, рисунки, по­
добные этим, могут оказаться ценнее, чем тысячи слов, если ошибка, за которой вы
охотились, неожиданно выпрыгивает на вас, как зверь на ловца.
Даже если отладчик имеет ограниченную поддержку визуализации данных, вы все
равно можете проводить визуализацию сами — либо вручную, с карандашом и бума­
гой, либо с помощью внешних программ построения графиков.
В отладчике DDD имеются некоторые средства визуализации и распространяется
бесплатно (см. [URL 19]). Интересно заметить, что отладчик DDD работает со многи­
ми языками, включая Ada, С, С + + , Fortran, Java, Modula, Pascal, Perl и Python (явно
ортогональная конструкция).
1:
l i s t
( L i s t
*)
0x804db40
value = 86
self = 0x804db50
next = 0x804db40
Рис. 3.2.
Пример отладочной схемы циркулярного связанного
списка.
Стрелки указывают на узлы
Трассировка
Отладчики обычно сосредоточены на состоянии программ в данный момент. В ряде
случаев вам необходимо нечто большее — отследить состояние программы или
структуры данных через какое-то время. Если посмотреть на трассировку стека, то
можно лишь сделать вывод, как попасть в эту точку напрямую. Это не дает информа­
ции о том, что вы делали до этой последовательности обращений, что особенно важно
для систем, основанных на событиях.
Операторы трассировки представляют собой небольшие диагностическими сооб­
щениями, которые выводятся на экран или в файл и говорят о том, что "это здесь" и
"х = 2". Это примитивная методика, сравнимая с отладчиками в стиле ИСР, но она
особенно эффективна при диагностировании некоторых классов ошибок, с которыми
отладчики справиться не могут. Трассировка имеет большое значение в любой систе­
ме, где время само по себе является фактором: в одновременных процессах, системах
реального времени и приложениях, основанных на событиях.
Вы можете использовать операторы трассировки для того, чтобы "вбуравиться" в
текст. То есть вы можете добавлять элементы трассировки по мере продвижения вниз
по дереву обращений.
value = 85
self = 0x804db40
next = 0x804db50

Походный набор инструментов
83
Трассировочные сообщения должны быть представлены в регулярном, согласо­
ванном формате; возможно, вам захочется провести их синтаксический анализ в авто­
матическом режиме. Например, если вам необходимо отследить утечку ресурсов (не­
сбалансированные операции открытия и закрытия файлов), вы можете трассировать
каждый из операторов open и close в файле журнала. Обрабатывая файл журнала с
помощью программы на языке Perl, вы легко обнаружите, где встречался оператор-
нарушитель open.
Искаженные переменные? Проверьте их окружение
Иногда вы и с с л е д у е т е переменную, ожидая увидеть небольшое целое зна­
чение, а вместо этого получаете нечто вроде 0x6e696614d. П е р е д тем как з а ­
сучив рукава всерьез приняться з а отладку, стоит посмотреть на память во­
круг искаженного значения. Часто это д а е т вам ключ к пониманию. В данном
с л у ч а е изучение окружающей памяти в символьном виде д а е т следующую
картину:
20333231 6e69614d 2с745320 746f4e0a
1 2 3
M a i n
S t , \ n N о t
2c6e776f 2058580a 31323433
ОООООаЗЗ
о w n ,\n X X
3 4 2 1
3 \ n \ 0 \ 0
Похоже, что кто-то указал а д р е с поверх счетчика цикла. Теперь мы знаем
где искать.
Рассказ о резиновом утенке
Очень простая, но весьма полезная методика поиска причины проблемы, состоит в
том, чтобы разъяснить ее кому-либо. Ваш собеседник должен заглянуть через ваше
плечо на экран монитора, и время от времени утвердительно кивать головой (подобно
резиновому утенку
1, ныряющем и выныривающему в ванне). Ему не нужно говорить
ни слова; простое, последовательное объяснение того, что же должна делать ваша
программа, часто приводит к тому, что проблема выпрыгивает из монитора и объяв­
ляет во всеуслышанье: "А вот и я!".
Это звучит просто, но, разъясняя проблему вашему собеседнику, вы должны явно
заявить о тех вещах, которые считаете само собой разумеющимися при просмотре
текста вашей программы. Поскольку вам приходится озвучивать некоторых из этих
положений, то вы можете по-новому взглянуть на суть данной проблемы — неожи­
данно для самого себя.
Почему "резиновый утенок"? Один из авторов книги, Дэйв Хант, учился в лондонском
Империал-колледже, и много работал совместно с аспирантом, которого звали Грег Паг и
которого Д. Хант считает одним из лучших известных ему разработчиков. На протяжении
нескольких месяцев Грег носил при себе крохотного желтого резинового утенка, которого
он ставил на край дисплея во время работы. Прошло некоторое время, пока Дэйв отважил­
ся спросить...

84
Глава 3
Процесс
исключения
В большинстве проектов отлаживаемая вами программа может представлять собой
смесь прикладных программ, написанных лично вами и другими сотрудниками вашей
проектной команды, а также программные продукты, созданные независимыми про­
изводителями (база данных, обеспечение связи, графические библиотеки, специали­
зированные протоколы связи или алгоритмы и т.д.) и платформенное окружение (опе­
рационная система, системные библиотеки и компиляторы).
Вероятно, ошибка кроется в операционной системе, компиляторе или продукте
независимого производителя — но это не должно быть первой мыслью, приходящей
вам на ум. Скорее всего, ошибка существует в тексте разрабатываемого приложения.
Обычно более выгодно полагать, что прикладная программа некорректно обращается
к библиотеке, нежели то, что нарушена сама библиотека. Даже если проблема заклю­
чается в продукте независимого производителя, то, перед тем как представлять отчет
об ошибках, вам в любом случае надлежит исключить ошибки в вашей собственной
программе.
Однажды мы работали над проектом, и старший инженер был уверен, что в систе­
ме Solaris имелось нарушение системного вызова select. Никакие убеждения или ло­
гические построения не могли изменить сложившегося у него мнения (тот факт, что
все другие сетевые приложения работали прекрасно, не принимался во внимание).
Неделями он составлял программы обхода этого вызова, которые, по какой-то стран­
ной причине, не способствовали решению проблемы. И когда, в конце концов он был
вынужден сесть за стол и прочесть документацию по вызову select, он обнаружил, в
чем заключалась проблема, и исправил ее за несколько минут. Теперь мы используем
выражение "вызов select нарушен" как деликатное напоминание, когда один из нас
начинает обвинять систему в наличии ошибки, которая, скорее всего, является его
собственной.
Подсказка 26
Ищите ошибки вне пределов операционной системы
Помните: увидев следы копыт, думайте о лошадях, а не о зебрах. Скорее всего,
операционная система не нарушена. Да и база данных находится в прекрасном со­
стоянии.
Если вы "внесли всего одно изменение" и система перестала работать, то скорее
всего именно оно, прямо или косвенно, несет ответственность за случившееся, каким
бы притянутым за уши ни казалось это утверждение. Иногда то, что изменяется, нахо­
дится вне вашего управления: новые версии операционной системы, компилятора,
базы данных или программы независимых производителей могут вызывать проблемы
и с изначально корректной программой. В ней могут обнаружиться новые ошибки.
Ошибки, которые были устранены с помощью программы обхода, преодолевают дей­
ствие этой программы. Если изменяются API, то изменяются и функциональные воз­
можности; короче говоря, это уже новая история, и вам надлежит провести повторное
тестирование системы в новых сложившихся условиях. Так что не спускайте глаз с

Походный набор инструментов
85
графика выполнения проекта, если собираетесь провести модернизацию; может
быть, придется подождать до выпуска новой версии.
Однако если вы не знаете, с чего начать, то всегда можете положиться на старый
добрый двоичный поиск. Обратите внимание, не проявляются ли симптомы в одной из
двух точек в тексте программы, находящихся далеко друг от друга. Затем посмотрите
на точку, расположенную между ними. При наличии проблемы ошибка "сидит" между
начальной и срединной точкой; в противном случае она "сидит" между срединной и
конечной точками. Продолжая действовать в этом ключе, вы сужаете область поиска
до того, пока не выявите ошибку.
Элемент удивления
Если ошибка вызвала у вас удивление (до того, что вы еле слышно бормочете "это­
го не может быть"), стоит провести переоценку истин, дорогих вашему сердцу.
А все ли граничные условия вы протестировали в подпрограмме связанного спи­
ска — той, которую вы считали непробиваемой и которая, по всей вероятности, не
могла стать причиной этой ошибки? А другой фрагмент текста программы, кото­
рый вы использовали в течение нескольких лет, — не мог ли он все еще таить в
себе ошибку?
Конечно, мог. То удивление, которое вы испытываете, когда что-то идет не так
как надо, прямо пропорционально уровню доверия и веры в правильность прогоняе­
мой программы. Поэтому, столкнувшись с "удивительным" отказом в работе про­
граммы, вы должны осознать, что одно или более ваших предположений неверны.
Не приукрашивайте подпрограмму или фрагмент текста программы, вызвавшего
ошибку, только потому, что "знаете", что он работает нормально. Вначале докажите
это. Докажите это в реальном контексте, с реальными данными, с реальными гра­
ничными условиями.
подсказка 27
Не предполагайте — доказывайте
Столкнувшись с удивительной ошибкой, помимо простого ее устранения, необхо­
димо определить, а почему этот сбой не был выявлен раньше. Подумайте, не стоит ли
внести поправки в модульные или иные тесты с тем, чтобы они могли выявить эту
ошибку.
Кроме того, если ошибка является результатом неправильных данных, которые
распространились по нескольким уровням, перед тем как вызвать взрыв, посмотрите,
может быть, более усовершенствованная процедура проверки параметров в этих под­
программах смогла бы помешать ее распространению (см. обсуждение процедур дос­
рочного сбоя и утверждений в разделе "Мертвые программы не лгут").
Пока вы собираетесь заняться этим, выясните, есть ли в программе другие
фрагменты, подверженные воздействию той же ошибки? Пришло время отыскать
их и устранить. Убедитесь: что бы ни произошло, вы будете знать, произойдет ли
это снова.

86
Глава 3
Если устранение этой ошибки заняло много времени, спросите себя, а почему?
Можете ли вы сделать что-нибудь, чтобы облегчить устранение этой ошибки в сле­
дующий раз? Возможно, вы можете встроить усовершенствованные обработчики
прерываний (для тестирования) или написать программу-анализатор файла журнала?
И наконец, если ошибка является результатом чьего-то неправильного предполо­
жения, обсудите проблему со всей командой: если имеется недопонимание со стороны
одного сотрудника, то, возможно, он не одинок в этом.
Проделайте все это, и наверняка в следующий раз вы будете избавлены от подоб­
ных сюрпризов.
Контрольные вопросы при отладке
•
Является ли проблема прямым результатом фундаментальной ошибки или
просто ее признаком?
•
Ошибка действительно "сидит" в компиляторе? В операционной системе?
Или в вашей собственной программе?
•
Если бы вам пришлось подробно объяснить вашему коллеге, в чем состоит
проблема, то что бы вы ему сказали?
•
Если подозрительная программа проходит модульное тестирование, то явля­
ется ли оно достаточно полным? Что произойдет, если вы прогоняете мо­
дульный тест с реальными данными?
•
Существуют ли условия, вызвавшие данную ошибку, где-либо еще в сис­
теме?
Другие разделы, относящиеся к данной теме:
•
Программирование на основе утверждений
•
Программирование в расчете на совпадение
•
Вездесущая автоматизация
•
Безжалостное тестирование
Вопросы для обсуждения
•
Отладка сама по себе является вопросом.
19 Обработка текста
Прагматики обрабатывают тексты программ подобно тому, как столяры придают
форму деревянным заготовкам. В предыдущих разделах обсуждались некоторые
специфические инструментальные средства — оболочки, редакторы, отладчи­
ки — те, что мы используем в работе. Они подобны столярным долотам, ножовкам
и рубанкам — инструментам, которые предназначены для выполнения одной или
двух конкретных работ. Однако время от времени нам приходится выполнять неко­
торые преобразования, которые не могут быть осуществлены с помощью походно-

Походный набор инструментов
87
го инструментария. Нам необходим универсальный инструмент для обработки тек­
ста.
Языки, предназначенные для обработки текста, играют в программировании ту же
роль, что станки
1 в столярном деле. Они издают шум, неуклюжи и представляют со­
бой грубую силу. Если при работе с ними вы совершаете ошибку, то разрушенными
могут оказаться целые фрагменты. Некоторые клятвенно уверяют, что этим средст­
вам нет места в инструментарии. Но в хороших руках и станки, и языки обработки
текста могут быть невероятно мощными и гибкими. Вы можете быстро придать форму
материалу, делать стыки и вырезать по дереву. При надлежащем использовании эти
инструменты обладают удивительной тонкостью и ловкостью. Но для овладения ими
требуется время.
Число хороших языков обработки текста постоянно увеличивается. Разработчики
программ для Unix часто любят использовать мощь их командных оболочек, усилен­
ных инструментальными средствами типа awk и sed. Тем, кто предпочитает более
структурированные средства, по душе объектно-ориентированный характер языка
Python [URL 9]. У некоторые выбор падает на Tel [URL 23]. Случается и мы предпо­
читаем язык Perl [URL 8] для написания коротких сценариев.
Эти языки являются важными узаконивающими технологиями. Используя их, вы
можете быстро решить все проблемы с утилитами и создать прототипы идей — при
работе с обычными языками на это потребовалось бы раз в пять-десять раз больше
времени. И этот умножающий коэффициент кардинально важен для экспериментов,
которые мы проводим. Потратить 30 минут на воплощение сумасшедшей идеи намно­
го лучше, чем потратить на то же пять часов. Потратить один день на автоматизацию
важных составляющих проекта — нормально, потратить неделю — может быть, и
нет. В книге "The Practice of Programming" [KP99] Керниган и Пайк реализовали одну
и ту же программу на пяти различных языках. Самой короткой оказалась версия на
языке Perl (17 строк по сравнению со 150 строками на языке С). Работая с языком
Perl, вы можете обрабатывать текст, взаимодействовать с другими программами, пе­
редавать данные по сетям, управлять web-страницами, производить арифметические
действия с произвольной точностью и писать программы, которые выглядят наподо­
бие клятвы Снупи.
Подсказка 28
Изучите язык обработки текстов
Чтобы продемонстрировать широту области применения языков обработки тек­
ста, в качестве примера мы приводим некоторые приложения, разработанные нами на
протяжении последних нескольких лет:
•
Сопровождение схемы базы данных. Набор сценариев на языке Perl обра­
батывал файл с простым текстом, содержащий определение схемы базы дан­
ных и генерировал из него:
В оригинале router обозначает не маршрутизатор ЛВС, а фрезерный станок.

Глава 3
— Инструкции SQL для создания БД
— Плоские файлы данных для заполнения словаря данных
— Библиотеки программ на языке С для доступа к БД
— Сценарии для проверки целостности БД
— Web-страницы, содержащие спецификации и диаграммы БД
— XML версию схемы
Доступ к свойству Java. Хорошим тоном в объектно-ориентированном про­
граммировании является ограничение доступа к свойствам объекта, вынуж­
дая внешние классы получать и устанавливать их через методы. Однако в об­
щем случае, когда свойство представлено внутри класса при помощи
простого поля, создание метода get и set для каждой переменной представля­
ет собой утомительную механическую процедуру. У нас имеется сценарий
Perl, который изменяет исходные файлы и вставляет правильные определе­
ния метода для всех переменных, помеченных соответствующим образом.
Генерирование тестовых данных. Унас имелись десятки тысяч записей, со­
держащих тестовые данные, рассеянных по нескольким различных файлов
различного формата, которые нуждались в соединении и преобразовании в
некую форму, пригодную для загрузки в реляционную БД. Программа на Perl
справилась с этим за пару часов (и в процессе обнаружила пару ошибок из-
за несовместимости в исходных данных).
Написание книг. Мы придаем важность тому факту, что любая программа,
представленная в книге, вначале должна быть протестирована. Большин­
ство программ, приведенных в этой книге, были протестированы. Однако,
используя принцип DRY (см. "Пороки дублирования"), мы не хотели копи­
ровать и вставлять строки текста из протестированных программ в книгу.
Это означало бы, что текст дублируется, поэтому велика вероятность, что
мы забудем обновить пример, когда соответствующая программа изменит­
ся. В некоторых примерах нам также не хотелось утомлять вас наличием
"скелета" программы, необходимым для компиляции и прогона нашего
примера. Мы обратились к языку Perl. При форматировании книги вызы­
вался относительно простой сценарий — он извлекал именованный сег­
мент исходного файла, выделял синтаксические конструкции и преобразо­
вывал
результат в язык,
который мы используем для подготовки
типографского макета книг.
Интерфейс между языками С и Object Pascal. У заказчика имеется команда
разработчиков, пишущих программы на языке Object Pascal, реализованном
на персональных компьютерах. Требуется осуществить сопряжение их про­
граммы с телом программы, написанной на языке С. Был разработан корот­
кий сценарий на языке Perl, который проводил синтаксический анализ фай­
лов заголовков С, выделяя определения всех экспортированных функций и
используемых ими структур данных. Затем были сгенерированы модули
Object Pascal с записями Pascal для всех структур С и произведен импорт оп­
ределений процедур для всех функций С. Этот процесс генерирования стал

Походный набор инструментов
89
частью сборки, так что при любых изменениях заголовка С происходит авто­
матическое конструирование нового модуля Object Pascal.
•
Генерирование интернет-документации. Многие команды разработчиков
публикуют свою документацию на внутренних интернет-сайтах. Авторами
написано много программ на языке Perl, которые анализируют схемы баз
данных, исходные файлы на С и С + + , сборочные файлы и другие исходные
тексты проекта для производства требуемой HTML-документации. Авторы
также использовали язык Perl для верстки документов со стандартными
верхними и нижними колонтитулами и передачи их на интернет-сайт.
Языки обработки текстов используются почти ежедневно. Многие из идей, опи­
санных в данной книге, могут реализовываться на этих языках проще, чем на любом
другом известном языке. Эти языки облегчают написание генераторов текстов про­
грамм, которые будут рассмотрены далее.
Другие разделы, относящиеся к данной теме:
•
Пороки дублирования
Упражнения

## В вашей программе на языке С для представления одного из 100 состояний


используется перечислимый тип данных. В целях отладки вам хотелось бы
иметь возможность вывода состояния на печать » виде строки (в отличие от
числа). Напишите сценарий, который осуществляет считывание со стан­
дартного устройства файла следующего содержания (Ответ см. в Приложе­
нии В):
name
state_a
state_b
Создайте файл name.h, содержащий следующие строки:
extern const char * NAME_names[]
typedef enum {
state_a,
state_b,
} NAME;
а также файл name, с, содержащий следующие строки:
const char * NAME_names[] = {
"state_a",
"state_b",
}

90
Глава 3

## Дописав эту книгу до середины, авторы обнаружили, что не поместили дирек­


тиву use s t r i c t во многие из примеров на языке Perl. Напишите сценарий,
который просматривает все файлы типа *. pi в некотором каталоге и добав­
ляет директиву use s t r i c t в конец начального блока комментариев ко всем
файлам, в которых это не было сделано ранее. Не забудьте сохранить резерв­
ную копию всех файлов, в которые внесены изменения. (Ответ см. в Прило­
жении В.)
20 Генераторы текстов программ
Если столярам приходится снова и снова изготавливать одну и ту же деталь, они идут
на хитрость. Они делают для себя шаблон. Если они сделают шаблон один раз, то вре­
мя от времени они могут воссоздавать некоторый фрагмент работы. Шаблон избавля­
ет столяров от излишней сложности и снижает вероятность ошибки, позволяя ремес­
леннику сосредоточиться на качестве работы.
Программисты часто оказываются в аналогичном положении. От них требуется
достижения той же функциональности, но в различных контекстах. Информация
должна быть воспроизведена в различных местах. А иногда, экономя на повторном
наборе текста, мы просто защищаем самих себя от болей в запястье.
Подобно столяру, вкладывающему свое время в шаблон, программист может по­
строить генератор текста. Его можно использовать всю оставшуюся жизнь проекта
практически бесплатно.
Подсказка 29
Пишите текст программы, которая пишет текст программы
Существует два основных типа генераторов текста:
1.
Пассивные генераторы текста запускаются один раз для достижения результа­
та. Начиная с этого момента результат становится независимым — он отделя­
ется от генератора текста. Мастера, обсуждаемые в разделе "Злые волшебни­
ки", вместе с некоторыми средствами CASE являются примерами пассивных
генераторов текста.
2.
Активные генераторы текста используются всякий раз, когда возникает не­
обходимость в результатах их работы. Этот результат создается по принци­
пу "выбросить и забыть" — он всегда может быть воспроизведен с помо­
щью
генератора
текста.
Зачастую
активные
генераторы
считывают
некоторую форму сценария или управляющего файла для получения конеч­
ного результата.
Пассивные генераторы
Пассивные генераторы текста экономят время, необходимое на набор текста. Как
только результат получен, он становится полностью приспособленным для использо-

Походный набор инструментов
91
вания в качестве исходного файла в данном проекте; он должен быть отредактирован,
скомпилирован и передан системе управления исходным текстом, как и любой другой
файл. О его происхождении никто и не вспомнит.
Пассивные генераторы текста применяются во многих случаях:
•
Создание
новых исходных
файлов.
Пассивный генератор текста может
создавать шаблоны, директивы управления исходным текстом, сведения об
авторских правах и стандартные блоки комментариев для каждого нового
файла в некотором проекте. Мы настроили наши редакторы на выполнение
этого действия всякий раз при создании нового файла: при редактировании
новой программы на языке Java в новом буфере редактора автоматически
окажутся уже заполненные блок комментариев, директива пакета и описа­
ние структурного класса.
•
Осуществление
двоичных
преобразований
в языках
программирова­
ния. Мы начали писать эту книгу, используя систему troff, но после пятна­
дцатого раздела перешли на LATgX. Мы написали генератор текста, который
считывал исходный текст из troff, и преобразовывали его в формат LAT^X.
Точность составила 90%; остальное мы делали вручную. Это является инте­
ресной особенностью пассивных генераторов текста: они не должны отли­
чаться абсолютной точностью. Вы выбираете, какое усилие необходимо вло­
жить в генератор, в сравнении с энергией, которую вы тратите на устранение
ошибок в выходной информации.
•
Создание таблиц
поиска и других ресурсов, вычисление
которых
явля­
ется дорогой операцией.
Вместо того, чтобы вычислять тригонометриче­
ские функции, во многих старых графических системах использовались таб­
лицы синусов и косинусов. Обычно эти таблицы создавались пассивным
генератором текста и затем копировались в исходный текст программы.
Активные генераторы текста
Пассивные генераторы текста являются не более чем удобством, но их активные род­
ственники являются необходимостью, если вы хотите следовать принципу DRY. С по­
мощью активного генератора текста вы можете использовать представление некото­
рого фрагмента знания и преобразовать его во все формы, которые необходимы
вашему приложению. Это не является дублированием, поскольку эти формы являют­
ся расходным материалом и создаются по мере необходимости генератором текста
(отсюда термин "активный").
Когда бы вам ни приходилось организовывать совместную работу двух совершенно
разных сред, стоит подумать об использовании активных генераторов текста.
Допустим, вы разрабатываете приложение БД. В этом случае вы имеете дело с
двумя средами — базой данных и языком программирования, который используется
для доступа к БД. У вас имеется схема, и вам необходимо определить низкоуровневые
конструкции, отражающие компоновку определенных таблиц БД. Вы могли бы про­
сто запрограммировать их напрямую, но при этом нарушается принцип DRY: знание
схемы было бы выражено дважды. Если схема меняется, вам необходимо помнить и о

92
Глава 3
соответствующем изменении текста программы. Если из таблицы удаляется столбец,
а база текста программы не меняется, то может статься, что ошибка не проявится
даже при компиляции. Первый раз вы узнаете об этом во время тестирования, когда
начнутся сбои (или же от пользователя).
С
х
е "
а
_
struct EmployeeRow
• таблица employee
активный
'—
• таблица employer
•
генератор
• struct EmployerRow
• таблица benefit
текста
...
struct BenefitRow
Рис. 3.3.
Активный генератор создает текст программы из схемы базы
данных
Альтернативой этому является использование активного генератора текста —
берется схема и используется для генерации исходного текста конструкций, как по­
казано на рис. 3.3. Теперь при любом изменении схемы будет происходить и автома­
тическое изменение программы, используемой для доступа к ней. При удалении
столбца исчезает и соответствующее поле в конструкции, и любая высокоуровневая
программа, использующая этот столбец, не пройдет компиляцию. Ошибку удалось
заметить во время компиляции, а не в процессе сборки. Конечно, эта схема работает
только в том случае, если вы сделаете генерацию текста частью самого процесса
сборки
1.
Другим примером слияния сред с помощью генераторов текста является случай,
когда в одном и том же приложении использованы различные языки программиро­
вания. Для того чтобы общаться, каждой программной базе необходима некоторая
общая информация — например структуры данных, форматы сообщений и имена
полей. Вместо того, чтобы дублировать эту информацию, используйте генератор
текста. В ряде случаев можно проводить синтаксический анализ информации из ис­
ходных файлов на одном языке и использовать ее для генерации текста на другом.
Хотя зачастую легче выразить ее более простым, независимым от языка представ­
лением и сгенерировать программу для обоих языков, как показано на рис. 3.4. Так­
же можно посмотреть ответ к упражнению 13 (см. Приложение В) в качестве при­
мера того, как отделить синтаксический анализ представления плоского файла от
генерации текста.
Как насчет создания текста из схемы БД? Существует несколько способов. Если схема
содержится в плоском файле (например, операторы create statements), то синтаксиче­
ский анализ и генерацию исходного текста можно провести при помощи относительно не­
сложного сценария. В качестве альтернативного способа предлагается следующий: при
использовании инструментального средства для создания схемы непосредственно в са­
мой БД необходимо иметь возможность извлечения нужной информации непосредствен­
но из словаря БД. В языке Perl имеются библиотеки, обеспечивающие доступ к большин­
ству основных БД.

Походный набор инструментов
93
Генераторы текста не должны быть
слишком сложными
Весь этот разговор об активном "этом" и пассивном "том" может создать у вас впе­
чатление, что генераторы текста — сложные звери. Им не надо быть сложными.
Обычно самой сложной частью является синтаксический анализатор, который обра­
батывает входной файл. Не усложняйте входной формат, и генератор текста станет
простым. Обратите внимание на ответ к упражнению 13 (см. Приложение В): в ре­
альности генерация текста представляет собой в основном операторы print.
# Add a
product
# to the
'on-order'
list
M AddProduct
F id
int
F name char[30]
F order_code
int
E
/*
Add a product
*/
I*
to the
'on-order'
list
*/
typedef struct {
int
i d ;
char
name[30]
int
order_code
} AddProductMsg;
{ Add a product
}
{ to the
'on-order'
list
}
AddProductmsg = packed record
i d :
Longlnt;
name:
a r r a y [ 0 . . 2 9 ]
of char;
order_code: Longlnt;
end;
Рис. 3.4.
Генерирование текста из представления, независимого
от языка.
Строки во входном файле, начинающиеся
с буквы М, означают
начало определения сообщения, буква F означает строки
с определениями
полей, а буква Е — конец
сообщения
Генераторы текста не всегда генерируют
тексты программ
Хотя многие из примеров, приведенных в этом разделе, демонстрируют генерато­
ры текстов программ, которые производят исходные тексты программ, это не всегда
так. Вы может применять генераторы текстов для создания выходного файла в любом
формате: HTML, XML, простой текст — любого текста, который является входной
информацией в какой-либо части вашего проекта.
Другие разделы, относящиеся к данной теме:
•
Пороки дублирования

94
Глава 3
•
Преимущество простого текста
•
Злые волшебники
•
Вездесущая автоматизация
Упражнения

## Напишите генератор текста, который обрабатывает входной файл, изобра­


женный на рис. 3.4, и генерирует выходной файл на двух языках по вашему
выбору. Попытайтесь упростить добавление новых языков. (Ответ см. в При­
ложении В)

Глава 4
Прагматическая
паранойя
Подсказка 30
Невозможно написать совершенную программу
Ваши чувства задеты? Не стоит принимать эту подсказку близко к сердцу. Примите ее
как жизненную аксиому. Заключите ее в объятья. Восславьте ее. Поскольку совер­
шенных программ в природе не существует. За всю краткую историю информатики
никому не удалось написать ни одного совершенного фрагмента программы. Малове­
роятно, что вы станете первым. И когда вы примете это как существующий факт, то
перестанете тратить время и энергию впустую в погоне за призрачной мечтой.
Каким же образом, учитывая эту гнетущую реальность, может прагматик обратить
ее себе на пользу? Это и является темой данной главы.
Каждый из этих людей знает, что лично он — лучший водитель на планете Земля.
Остальному человечеству далеко до него, проезжающего под запрещающие знаки,
мотающегося из ряда в ряд, не подающего сигналы поворота, разговаривающего по
телефону, читающего за рулем газету и просто не живущего по общепринятым нор­
мам. Так что мы ездим осторожно. Мы обнаруживаем неприятность до того, как она
происходит, ожидаем непредвиденное и никогда оказываемся в положении, из кото­
рого не сможем выпутаться сами.
Аналогия с написанием программ весьма очевидна. Мы постоянно взаимодейству­
ем с программами, написанными другими людьми, программами, которые не отвеча­
ют нашим высоким требованиям, и имеем дело с входными параметрами, которые яв­
ляются или не являются допустимыми. Нас учат программировать с осторожностью.
При наличии любого рода сомнений мы проверяем правильность всей поступающей к
нам информации. Мы использугм утверждения для обнаружения неверных данных.
Мы проверяем непротиворечивость, устанавливаем ограничения на столбцы базы
данных и вообще высоко ценим самих себя.

96
Глава 4
Но прагматики идут дальше. Они не доверяют даже самим себе. Зная, что никто не
пишет совершенных программ, включая их самих, прагматики пишут программы, за­
щищаясь от собственных ошибок. Первый рубеж обороны описан в разделе "Проек­
тирование по контракту": клиенты и поставщики должны договориться о правах и
обязанностях.
В разделе "Мертвые программы не лгут" говорится о гарантиях того, что процеду­
ра устранения ошибок не нанесет вреда. Поэтому мы попытаемся чаще проверять
нашу программу и завершать ее аварийно, если она работает не так, как надо.
В разделе "Программирование с применением утверждений" описан простой метод
проверки "на ходу" — программа, которая активно проверяет ваши предположения.
Исключения, как и любая другая методика, может причинить больше вреда, чем
пользы, если ее применять неправильно. Мы обсудим эти аспекты в разделе "Случаи,
когда необходимо использовать исключения".
По мере того как ваши программы приобретают большую динамику, вы начинаете
жонглировать системными ресурсами — памятью, файлами, устройствами и т.п.
В разделе "Балансировка ресурсов" предлагаются способы того, как не ронять те
предметы, которыми вы жонглируете.
Поэтому будем осторожными в этом мире несовершенных систем, устаревших вре­
менных масштабов, смешных инструментальных средств и невыполнимых требований.
Если все общество
отклоняется
от
нормы,
чтобы понять
вас, скорее всего, это
паранойя.
Вуди Аллен
21 Проектирование по контракту
Ничто не ошеломляет
людей так
сильно,
как здравый смысл и честная
сделка.
Ральф Уолдо Эмерсон, Эссе
Работать с компьютерными системами всегда непросто. Работать с людьми еще
сложнее. И поскольку мы (как биологический вид) развиваемся достаточно долго, то у
нас явно было больше времени на выяснение природы человеческих взаимоотноше­
ний. Некоторые из тех решений, к которым мы пришли в течение нескольких послед­
них тысячелетий, могут быть применены и к созданию программного обеспечения.
Одним из лучших способов, с помощью которого можно удостовериться в честности
заключаемой сделки, является контракт.
В контракте определены ваши права и обязанности, а также права и обязанности
другой стороны. В дополнение к этому существует соглашение, касающееся юридиче­
ских последствий, возникающих в том случае, если какая-либо из сторон окажется не
в состоянии соблюдать условия контракта.
Допустим, у вас имеется контракт на работу, в котором определены количество от­
рабатываемых часов и правила поведения, которым вы обязаны следовать. В ответ
фирма платит вам заработную плату и предоставляет другие льготы. Каждая из сто­
рон выполняет свои обязательства, а в результате выигрывают все.

Прагматическая паранойя
97
Эта идея используется во всем мире — и формальным, и неформальным обра­
зом — для того, чтобы помочь людям во взаимодействии. Можем ли мы применить
этот же принцип, чтобы способствовать взаимодействию программных модулей? От­
вет на этот вопрос положительный.
Проектирование по контракту
Бертран Мейер [Меу97Ь] разработал концепцию проектирования по контракту для
языка Eiffel

## Это простая, но мощная методика, сосредоточенная на документирова­


нии (и согласовании) прав и обязанностей программных модулей в целях обеспечения
корректности программы. Так что же означает "корректная программа"? Это та про­
грамма, которая делает не более и не менее того, на что она претендует. Документи­
рование и подтверждение указанных претензий лежит в основе принципа проектиро­
вания по контракту (в дальнейшем, для краткости, будем называть его ППК).
Каждая функция и метод в программной системе осуществляет некоторое дейст­
вие. До того как подпрограмма начнет выполнять это действие, она может иметь не­
кие виды на состояние окружающего мира, а также может констатировать состояние
окружающего мира на момент завершения работы. Б. Мейер описывает эти виды и
претензии следующим образом:
•
Предусловия. Требования подпрограммы — то, что обязано быть истинным
для того, чтобы подпрограмма могла вызываться. Если предусловия наруше­
ны, программа не должна вызываться ни в коем случае. Ответственность за
передачу качественных данных лежит на вызывающей программе (см. врез­
ку ниже "Кто несет ответственность?").
•
Постусловия. Состояние окружающего мира на момент завершения работы
подпрограммы — то, что гарантируется подпрограммой. Сам факт того, что
в ней имеется постусловие, подразумевает, что подпрограмма завершит
свою работу: бесконечные циклы не допускаются.
•
Инварианты класса. Класс гарантирует, что данное условие всегда истинно
с точки зрения вызывающей программы. Во время внутренней обработки
подпрограммы инвариант может и не выполняться, но к моменту выхода из
подпрограммы и передачи управления обратно к вызывающей программе,
инвариант обязан быть истинным. (Следует заметить, что класс не может да­
вать неограниченное право доступа для записи к любому элементу данных,
участвующему в инварианте.)
Рассмотрим контракт на создание программы, которая осуществляет вставку зна­
чения данных в упорядоченный список уникальных данных. При работе с iContract
(препроцессором для языка Java, который можно загрузить с [URL 17]), этот кон­
тракт может быть реализован следующим образом:
Частично основан на ранней работе Дейкстры, Флойда, Хоара, Вирта и др. Более под­
робная информация о самом языке Eiffel содержится в сети Интернет, см. [URL 10] и
[URL 11].

98
Глава 4
I * *
ППК и параметры-константы
Во многих случаях постусловие будет использовать параметры,
переданные
в метод, для проверки правильности поведения. Но е с л и подпрограмме раз­
р е ш е н о изменять переданный параметр, то у в а с есть возможность обойти
условия контракта. Язык Eiffel не позволяет подобных действий, в отличие от
языка J a v a . В данном с л у ч а е для указания наших намерений, сводящихся к
неизменяемости
п а р а м е т р а в п р е д е л а х
метода, используется
ключевое
слово final (из языка J a v a ) . Э т о не является "защитой от д у р а к а " — подклас­
с ы не имеют ограничений при повторном определении п а р а м е т р а как не яв­
ляющегося окончательным.
В качестве альтернативы можно
использовать
синтаксис variable@pre (принятый в iContract), чтобы получить исходное зна­
чение переменной, существовавшее н а момент входа в метод.
Следовательно, в контракте между подпрограммой и любой потенциально вызы­
вающей ее программой может быть записано следующее:
"Если вызывающая программа выполняет все предусловия
подпрограм­
мы, то подпрограмма гарантирует,
что по завершении ее работы все
постусловия и инварианты будут
истинными".
*
©invariant f o r a l l Node n in elements() |
*
n.prev()
!= n u l l
*
implies
*
n.value().compareTo(n.prev().value())
> 0
• /
public class DBC_list {
/ * *
*
@pre contains(aNode) == f a l s e
*
©post contains(aNode) == true
4
public void insertNode(final Node aNode) {
/ / . . .
Здесь стоит сказать, что элементы в списке всегда должны располагаться в поряд­
ке возрастания. При вставке нового элемента этот порядок уже может быть нарушен,
и мы гарантируем, что элемент будет обнаружен после того, как он был вставлен в
список.
Вы формулируете эти предусловия, постусловия и инварианты на целевом языке
программирования, возможно, с некоторыми расширениями. Например, iContract
предоставляет операторы логики предикатов — forall, exists и implies, дополняя
обычные конструкции языка Java. Ваши утверждения могут сделать запрос о состоя­
нии любого объекта, к которому имеется доступ со стороны метода, но удостоверь­
тесь, что запрос не окажет никакого побочного воздействия (см. ниже врезку "Утвер­
ждения и побочные эффекты").

Прагматическая паранойя
99
Если одна из сторон нарушает условия контракта, то применяется предварительно
согласованная мера — например, возбуждается исключение или происходит завер­
шение работы программы. Что бы ни происходило, вы не ошибетесь, утверждая, что
нарушение условий контракта есть ошибка. Это происходит далеко не всегда, и по­
этому предусловия не должны использоваться для осуществления таких процедур, как
проверка правильности данных, вводимых пользователем.
Подсказка 31
Проектируйте в соответствии с контрактами
В разделе "Ортогональность" рекомендуется создавать "скромные" программы.
В данном случае упор делается на "ленивую" программу: проявите строгость в том,
что вы принимаете до начала работы, и обещайте как можно меньше взамен. Следует
помнить, что если в контракте указано, что вы принимаете все условия, а взамен обе­
щаете весь мир, то вам придется написать ... ну очень большую программу!
Наследование и полиморфизм являются краеугольными камнями объектно-ориен­
тированных языков программирования и представляют собой область, в которой прин­
цип программирования по контракту может проявиться особенно ярко. Предположим,
что вы используете наследование при создании связи типа "это-схоже-с тем", где один
класс "схож-с-тем" (другим) классом. Вероятно, вы действуете в соответствии с прин­
ципом замещения, изложенным в книге [Lis88]:
"Использование
подклассов
должно
осуществляться
через
интерфейс
базового
класса, но при этом пользователь
не обязан
знать,
в чем со­
стоит различие
между
ними".
Другими словами, вы хотите убедиться в том, что вновь созданный подтип действи­
тельно "схож-с-тем" (базовым) типом — что он поддерживает те же самые методы и
эти методы имеют тот же смысл. Этого можно добиться при помощи контрактов. Кон­
тракт необходимо определить единожды (в базовом классе) с тем, чтобы он применялся
к вновь создаваемым подклассам автоматически. Подкласс может (необязательно) ис­
пользовать более широкий диапазон входных значений или же предоставлять более же­
сткие гарантии. Но, по крайней мере, подкласс должен использовать тот же интервал и
предоставлять те же гарантии, что и родительский класс.
Рассмотрим базовый класс Java, именуемый Java. AWT. Component. Вы можете об­
рабатывать любой визуальный элемент в AWT или Swing как тип Component и не знать
того, чем является подкласс в действительности — кнопкой, подложкой, меню или
чем-то другим. Каждый отдельный элемент может предоставлять дополнительные,
специфические функциональные возможности, но, по крайней мере, он должен пре­
доставлять базовые средства, определенные типом Component. Но ничто не может по­
мешать вам создать для типа Component подтип, который предоставляет методы с пра­
вильными названиями, приводящие к неправильным результатам. Вы легко может
создать метод paint, который ничего не закрашивает, или же метод setFont, который
не устанавливает шрифт. AWT не обладает контрактами, которые способны обнару­
жить факт нарушения вами соглашения.

100
Глава 4
При отсутствии контракта, все, на что способен компилятор, — это дать гарантию
того, что подкласс соответствует определенной сигнатуре метода. Но если мы составим
контракт для базового класса, то можем гарантировать следующее: любой будущий
подкласс не сможет изменять значения
наших методов. Например, вы составляете
контракт для метода setFont (подобный указанному ниже), который гарантирует, что
вы получите именно тот шрифт, который установили:
I * *
* @pre
f ! == null
* ©post getFont() == f
*/
public void setFont(final Font f) {
/ / ...
Реализация принципа ППК
Самая большая польза от использования принципа ППК состоит в том, что он ста­
вит вопросы требований и гарантий во главу угла. В период работы над проектом
простое перечисление факторов — каков диапазон входных значений, каковы гра­
ничные условия, что можно ожидать от работы подпрограммы (или, что важнее,
чего от нее ожидать нельзя), — является громадным шагом вперед в написании
лучших программ. Не обозначив эти позиции, вы скатываетесь к программирова­
нию в расчете
на совпадение
(см. раздел "Программирование в расчете на сте­
чение обстоятельств"), на чем многие проекты начинаются, заканчиваются и тер­
пят крах.
В языках программирования, которые не поддерживают в программах принцип
ППК, на этом можно было бы и остановиться — и это неплохо. В конце концов,
принцип ППК относится к методикам проектирования. Даже без автоматической
проверки вы можете помещать контракт в текст программы (как комментарий) и
все равно получить от этого реальную выгоду. По меньшей мере, закомментиро­
ванные контракты дают вам отправную точку для поиска в случае возникновения
неприятностей.
Утверждения
Документирование этих предположений уже само по себе неплохо, но вы можете из­
влечь из этого еще большую пользу, если заставите компилятор проверять имеющий­
ся контракт. Отчасти вы можете эмулировать эту проверку на некоторых языках про­
граммирования, применяя так называемые утверждения (см. "Программирование
утверждений"). Но почему лишь отчасти? Разве вы не можете использовать утвер­
ждения для всего того, на что способен принцип ППК?
К сожалению, ответ на этот вопрос отрицательный. Для начала, не существует
средств, поддерживающих распространение действия утверждений вниз по иерархии
наследования. Это означает, что если вы отменяете метод базового класса, у которого
имеется свой контракт, то утверждения, реализующие этот контракт, не будут вызы­
ваться корректно (если только вы не продублируете их вручную во вновь написанной
программе). Не забывайте, что, прежде чем выйти из любого метода, необходимо

Прагматическая паранойя
101
вручную вызвать инвариант класса (и все инварианты базового класса). Основная
проблема состоит в том, что контракт не соблюдается автоматически.
Кроме того, отсутствует встроенный механизм "старых" значений; то есть значе­
ний, которые существовали на момент входа в метод. При использовании утвержде­
ний, обеспечивающих соблюдение условий контрактов, к предусловию необходимо
добавить программу, позволяющую сохранить любую информацию, которую вы на­
мерены использовать в постусловии. Сравним это с iContract, где постусловие может
просто ссылаться на "variable@pre", или с языком Eiffel, который поддерживает
принцип "old expression".
И наконец, исполняющая система и библиотеки не предназначены для поддержки
контрактов, так что эти вызовы не проверяются. Это является серьезным недостат­
ком, поскольку большинство проблем обнаруживается именно на стыке между вашей
программой и библиотеками, которые она использует (более детально этот вопрос
обсуждается в разделе "Мертвые программы не лгут").
Поддержка
ППК в языках
программирования
Языки программирования, в которых имеется встроенная поддержка ППК (напри­
мер, Eiffel и Sather[URL 12]) осуществляют автоматическую проверку предусловий и
постусловий в компиляторе и исполняющей системе. В этом случае вы оказываетесь
в самом выгодном положении, поскольку все базовые элементы программы (включая
библиотеки) должны выполнять условия соответствующих контрактов.
Но как быть, если вы работаете с более популярными языками типа С, С + + и
Java? Для этих языков существуют препроцессоры, которые обрабатывают контрак­
ты, инкапсулированные в первоначальный исходный текст как особые комментарии.
Препроцессор разворачивает эти комментарии, преобразуя их в программу, которая
контролирует утверждения.
Если вы работаете с языками С и С + + , то попробуйте изучить Nana [URL 18].
Nana не осуществляет обработку наследования, но использует отладчик во время вы­
полнения программы для отслеживания утверждений новаторским методом.
Для языка Java существует средство iContract [URL 17]. Оно обрабатывает ком­
ментарии (в формате JavaDoc) и генерирует новый исходный файл, содержащий логи­
ку утверждений.
Препроцессоры уступают встроенным средствам. Они довольно муторно интегри­
руются в проект, а другие используемые вами библиотеки останутся без контрактов.
И тем не менее, они могут принести большую пользу; когда проблема обнаруживает­
ся подобным способом, — в особенности та, которую по-другому найти просто невоз­
можно, — и это уже сродни работе волшебника.
ППК и аварийное завершение работы программы
ППК прекрасно сочетается с нашим принципом аварийного завершения работы про­
граммы (см. "Мертвые программы не лгут"). Предположим, что имеется метод, вы-

102
Глава 4
числяющий квадратные корни (подобный классу DOUBLE в языке Eiffel). Этот метод
требует наличия предусловия, которое ограничивает область действия положитель­
ными числами. Предусловие в языке Eiffel объявляется с помощью ключевого слова
require, а постусловие объявляется с помощью ключевого слова ensure, так что мож­
но записать:
Sqrt: DOUBLE is
--
Подпрограмма вычисления
квадратного
корня
require
sqrt_arg_must_be_positive: Current >= 0;
—
здесь происходит вычисление квадратного корня
ensure
((Result*Result) -- Current).abs >= epsilon*Current.abs;
-- Результат должен находиться в пределах погрешности
end;
Кто несет ответственность?
Кто н е с е т ответственность з а проверку предусловия, вызывающей
про­
граммы или вызываемой подпрограммы?
Если э т а проверка
р е а л и з о в а н а
как часть с а м о г о языка программирования,
то никто: п р е д у с л о в и е тести­
р у е т с я " з а к у л и с а м и " п о с л е того, как вызывающая п р о г р а м м а
о б р а щ а е т ­
с я к подпрограмме,
но д о входа в с а м у подпрограмму.
С л е д о в а т е л ь н о ,
е с л и необходимо явным о б р а з о м проверить п а р а м е т р ы , это должно быть
выполнено вызывающей программой, потому что п о д п р о г р а м м а с а м а ни­
когда не с м о ж е т увидеть п а р а м е т р ы , которые н а р у ш а ю т е е п р е д у с л о в и е .
(В языках б е з встроенной поддержки вам пришлось бы окружить вызывае­
мую подпрограмму
п р е а м б у л о й и/или заключением, которые
проверяет
эти
утверждения).
Р а с с м о т р и м программу, которая считывает с устройства ввода номер, из­
влекает из него квадратный корень (вызывая функцию sqrt) и выводит резуль­
тат на печать. Функция sqrt имеет предусловие — е е аргумент не должен
быть отрицательным числом. Если пользователь вводит отрицательное число,
то именно вызывающая программа должна гарантировать, что это число не
будет п е р е д а н о к функции sqrt. Вызывающая программа может воспользо­
ваться многими вариантами: она может завершить работу, выдать предупре­
ждение и начать считывать другое число, она также может
преобразовать
число в положительное и добавить к результату, выданному функцией sqrt,
мнимую единицу. Какой бы вариант ни использовался, э т а проблема опре­
деленно не связана с функцией sqrt.
В ы р а ж а я о б л а с т ь значений функции извлечения квадратного корня в пре­
д у с л о в и и подпрограммы sqrt, вы п е р е к л а д ы в а е т е ответственность з а п р а ­
вильность н а вызывающую программу, которой о н а принадлежит. З а т е м вы

Прагматическая паранойя
103
можете спокойно продолжать р а з р а б о т к у подпрограммы sqrt, зная, что е е
входные параметры не выйдут з а пределы соответствующей области.
ЕСЛИ ваш алгоритм извлечения квадратного корня не работает (или выходит за
пределы погрешности), вы получите сообщение об ошибке и трассировку стека, ука­
зывающую на цепочку вызовов.
Если вы передаете sqrt отрицательный параметр, рабочая среда Eiffel выводит на
печать ошибку "sqrt _arg_must_be_positive" (аргумент функции sqrt должен быть
положительным) наряду с трассировкой стека. Этот вариант реализован лучше, чем
его аналогия в рабочих средах типа Java, С, и С + + , где при передаче отрицательного
числа в sqrt выдается специальное значение NaN (Not a Number — не число). Далее
по ходу программы, когда вы попытаетесь произвести со значением NaN некие мате­
матические действия, результаты этого будут поистине удивительными.
Проблему намного проще найти и диагностировать "не сходя с места", при ава­
рийном завершении работы программы.
Другие случаи применения инвариантов
До этого момента мы обсуждали предусловия и постусловия, которые применимы к
отдельным методам и инварианты, которые применимы ко всем методам в пределах
класса, но есть и другие полезные способы применения инвариантов.
Инварианты цикла
Понимание граничных условий для нетривиального цикла может оказаться проблема­
тичным. Циклы испытывают воздействие "проблемы банана" (я знаю, как записать
по буквам слово "банан", но не знаю, в какой момент нужно остановиться), ошибки
"постов охраны" (путаница в том, что подсчитывать: сами посты, или интервалы меж­
ду ними) и вездесущая ошибка завышения (занижения) [URL 52].
В подобных ситуациях инварианты могут быть полезными: инвариант цикла пред­
ставляет собой оператор возможной цели цикла, но он обобщен таким образом, что
также истинен перед тем, как цикл выполняется и при каждой итерации, осуществ­
ляемой с помощью цикла. Его можно считать контрактом в миниатюре. Классическим
примером является подпрограмма поиска максимального элемента в массиве.
int m = arr[0];
// пример предполагает, что длина массива > 0
int i = 1;
// Инвариант цикла: m = max(arr[0:i-1])
while (i < arr.length) {
m = Math.max(m, arr[i]);
i = i + 1;
}
(arr [m:n] — принятое обозначение фрагмента массива, элементы которого имеют
индексы от m до п). Инвариант должен быть истинным до начала выполнения цикла, а
тело цикла должно гарантировать, что инвариант будет оставаться истинным во вре-

104
Глава 4
мя выполнения цикла. Таким образом, нам известно, что инвариант истинен после
выполнения цикла, и, следовательно, наш результат является достоверным. Инвари­
анты цикла могут быть запрограммированы в явном виде (как утверждения); они так­
же полезны при проектировании и документировании.
Семантические инварианты
Вы можете использовать семантические инварианты для выражения неизменных тре­
бований при составлении своего рода "философского контракта".
Однажды авторы книги написали программу обработки транзакций для дебетовых
банковских карт. Главное требование заключалось в том, что пользователь дебетовой
карты не должен проводить на своем счете одну и ту же транзакцию. Другими слова­
ми, ошибка скорее повлечет за собой отмену обработки транзакции, чем инициирует
обработку дублированной транзакции — независимо от характера сбоя в системе.
Это простое правило, исходящее непосредственно из требований, доказало свою
полезность при отсеивании сложных сценариев исправления ошибок и является ру­
ководством при детальном проектировании и реализации во многих областях.
Но убедитесь в том, что вы не смешиваете требования, которые представляют со­
бой жесткие, неизменные законы с теми, которые являются не более чем политикой,
которая может измениться вместе с правящим режимом. Именно поэтому мы исполь­
зуем термин "семантические инварианты" — он должен занимать главенствующее
место при определении сути предмета и не подчиняться прихотям политики (для ко­
торой предназначаются более динамичные правила ведения бизнеса).
Если вы обнаруживаете подходящее требование, убедитесь, что оно становится
неотъемлемой частью любой создаваемой вами документации — будь то маркирован­
ный список в требованиях, которые подписываются в трех экземплярах, или большое
объявление на обычной лекционной доске, которое не заметит разве что слепой. По­
старайтесь сформулировать его четко и однозначно. Например, в случае с дебетовой
картой можно было бы записать:
ERR IN FAVOR OF THE CONSUMER (ОШИБКА В ПОЛЬЗУ КЛИЕНТА)
Это и есть четкая, сжатая, однозначная формулировка, которая применима к раз­
личным областям системы. Это наш контракт со всеми пользователями системы,
наша гарантия ее поведения.
Динамические контракты и агенты
До сих пор мы говорили о контрактах как о неких фиксированных, раз и навсегда уста­
новленных спецификациях. Но случае с автономными агентами этого быть не должно.
Из определения "автономных" агентов следует, что они могут отвергать запросы, ко­
торые они не хотят выполнять. Они могут обговаривать условия контракта — "я не
могу предоставить то-то и то-то, но если вы дадите мне вот это, тогда я смогу предос­
тавить что-то другое".

Прагматическая паранойя
105
Конечно, любая система, которая полагается на технологию агентов, обладает
критической зависимостью от положений контракта, даже если они генерируются ди­
намически.
Только представьте себе: при достаточном количестве элементов и агентов, кото­
рые для достижения конечной цели могут обговаривать свои собственные контракты
между собой, можно было бы просто выйти из кризисной ситуации, связанной с про­
изводительностью, позволив программам решать проблемы за нас.
Но если мы не можем использовать контракты "вручную", то мы не сможем ис­
пользовать их и автоматически. Поэтому в следующий раз, когда вы будете проекти­
ровать фрагмент программы, проектируйте и его контракт.
Другие разделы, относящиеся к данной теме:
•
Ортогональность
•
Мертвые программы не лгут
•
Программирование утверждений
•
Балансировка ресурсов
•
Несвязанность и закон Деметера
•
Временное связывание
Программирование в расчете на совпадение
Программа, которую легко тестировать
Команды прагматиков
•
•
Вопросы для обсуждения
•
Информация к размышлению: Если принцип ППК является столь мощным,
почему бы не применять его более широко? Насколько сложно выйти на
контракт? Заставляет ли он вас думать о вещах, которые в данный момент
лучше проигнорировать? Заставляет ли он вас ДУМАТЬ? Это явно небезо­
пасный принцип!
Упражнения

## Из чего получается удачный контракт? Можно добавлять любые предусло­


вия и постусловия, но есть ли от них толк? Не могут ли они принести больше
вреда, чем пользы? Определите, какими являются контракты в примере
ниже и упражнениях 15 и 16: удачными, неудачными, уродливыми, и объяс­
ните, почему.
Рассмотрим вначале пример, написанный на языке Eiffel. Имеется программа
для добавления STRING к двунаправленному циклическому списку (следует
помнить, что предусловия обозначены require, а постусловия — ensure).
-- Добавляем
элемент в двунаправленный
список,
и возвращаем вновь созданный
узел
(MODE).
add_item (item : STRING) : NODE i s

106
Глава 4
require
item /= Void
'/='
означает 'не
равно'.
Абстрактный базовый
класс.
deferred
ensure
result.next.previous = result
result.previous.next = result
find_item(item) = result
Проверка связей
вновь
вновь добавленного
узла.
Должен найти его.
end

## Теперь рассмотрим пример на языке Java — нечто подобное примеру, рас­


смотренному в упражнении 14. Оператор InsertNumbeг вставляет целое число
в упорядоченный список. Предусловия и постусловия обозначены в соответст­
вии с сайтом iContract (см. [URL 17]). (Ответ см. в Приложении В.)
private int data[];
J * *
* @post data[index-l]
< data[index]
&&
* data[index]
== aValue
*/
public Node insertNumber (final int aValue)
{
int index = findPlaceToInsert(aValue);

## Фрагмент стекового класса на языке Java. Можно ли назвать этот контракт


удачным? (Ответ см. в Приложении В.)
/ * *
* §pre
anltem
!= null
//
Требует реальных данных
* @post рор() == anltem //
Проверяет их наличие
* //
в стеке
*/
public void push(final String anltem)

## В классических примерах использования принципа ППК (см. упражне­


ния 14—16) реализуется абстрактный тип данных — обычно это стек, или оче­
редь. Но немногие действительно создают подобные разновидности низко­
уровневых классов.
В данном упражнении требуется спроектировать интерфейс кухонного смеси­
теля для коктейлей. Этот смеситель должен основываться на web-технологии,
включаться по сети Интернет и использовать технологию CORBA, но в дан­
ный момент необходим лишь интерфейс управления. Смеситель имеет десять
скоростей (0 означает отключение). Смеситель не может работать вхолостую
а его скорость может единовременно изменяться на одну ступень (т.е. с 0 до 1
или с 1 до 2, но не сразу с 0 до 2).
Методы указаны ниже. Добавьте соответствующие предусловия постусловия,
а также инвариант. (Ответ см. в Приложении В.)
int getSpeedQ
void setSpeed(int x )

Прагматическая паранойя
107
booolean isFull()
void f i l l ( )
void empty()

## Сколько чисел содержится в ряду 0, 5, 10, 15..., 100? (Ответ см. в Приложе­


нии В.)
22 Мертвые программы не лгут
Приходилось ли вам замечать, что иногда, еще до того, как вы осознаете проблему,
ее признаки обнаруживают посторонние люди? То же самое применимо и к про­
граммам других разработчиков. Если в одной из наших программ что-то начинает
идти не так, как надо, в ряде случаев первой это "заметит" библиотечная подпро­
грамма. Возможно, паразитный указатель заставил нас записать в дескриптор фай­
ла какие-то бессмысленные символы. При следующем обращении к read это будет
обнаружено. Возможно, что переполнение буфера привело к уничтожению счетчи­
ка, который мы собирались использовать для определения объема назначаемой па­
мяти. Возможно, причиной сбоя окажется raalloc. Логическая ошибка в одном из
нескольких миллионов операторов, находящихся в тексте перед оператором выбора,
означает, что его селектор больше не примет значение 1, 2, или 3. Мы берем случай
default (который является одной из причин того, что почему любой оператор выбо­
ра должен иметь значение по умолчанию — мы хотим знать, в какой момент про­
изошло невозможное).
Легко стать приверженцем ментальности "этого не может быть, потому что не мо­
жет быть никогда". Большинство из нас создавало программы, которые не проверя­
ют, успешно ли завершилась операция закрытия файла и правильно ли записан опе­
ратор трассировки. И все сводилось к одному (к тому, что мы и так знали) —
рассматриваемая программа не откажет, если будет работать в нормальных условиях.
Но мы пишем программы с осторожностью. Мы ищем инородные указатели в других
частях нашей программы, очищая стек. Мы выясняем, какие версии библиотек со­
вместного пользования загружались в действительности.
Все ошибки дают вам информацию. Вы могли внушить себе, что ошибка произой­
ти не может, и проигнорировать эту информацию. В отличие от вас, прагматики гово­
рят себе, что если ошибка имеет место, то произошло что-то очень скверное.
Подсказка 32
Пусть аварийное завершение работы программы произойдет
как можно раньше
Аварийное завершение не означает
"отправить в корзину для мусора"
Одним из преимуществ скорейшего обнаружения проблем является то, что сбой про­
исходит как можно раньше. И во многих случаях такое завершение программы — это

108
Глава 4
лучший выход из положения. Альтернативой может быть продолжение работы, за­
пись поврежденных данных в жизненно важную базу данных или команда стиральной
машине на проведение двадцатого по счету цикла отжима.
Эта философия воплощена в языке и библиотеках Java. Когда в системе выпол­
нения происходит что-то непредвиденное, происходит возбуждение исключения
RuntimeException. Если это исключение не перехвачено, оно будет двигаться на
верхний уровень программы и заставит ее прекратить работу, отобразив трасси­
ровку стека.
То же самое можно реализовать и на других языках программирования. Если ме­
ханизм исключения отсутствует или библиотеки не возбуждают исключения, то убе­
дитесь в том, что можете обрабатывать ошибки самостоятельно. В языке С для этого
весьма полезны макрокоманды:
#define СНЕСК(LINE, EXPECTED) \
< int гс = LINE; \
if (гс != EXPECTED) \
ut_abort(
FILE__,
LINE
#LINE, гс, EXPECTED); }
void ut_abort(char *file, int In, char *line, int rc, int exp) {
fprintf(stderr, "%s line %d\n'%s': expected %d, got %d\n",
file, In, line, exp, rc);
exit(1);
}
Тогда вы можете инкапсулировать вызовы, которые никогда подведут, с помощью
строки:
CHECK(statC'/tmp", &stat_buff), 0);
Если бы это не удалось, то вы получаете сообщение, записанное в stderr:
source.с line 19
'stat("/tmp", &stat_buff)': expected 0, got -1
Ясно, что в ряде случаев выход из выполняющейся программы просто не уме­
стен. Возможно, вы претендуете на ресурсы, которые не освобождены, или же вам
необходимо записать сообщения в журнал, завершить открытые транзакции или
взаимодействовать с другими процессами. Здесь будут полезны методики, которые
обсуждаются в разделе "Случаи, когда необходимо использовать исключения". Од­
нако основной принцип остается тем же — если ваша программа обнаруживает, что
произошло событие, которое считалось невозможным, программа теряет жизнеспо­
собность. Начиная с этого момента, все действия, которые она совершает, попадают
под подозрение, так что выполнение программы необходимо прервать как можно
быстрее. В большинстве случаев мертвая программа приносит намного меньше вре­
да, чем испорченная.
Другие разделы, относящиеся к данной теме:
•
Проектирование по контракту
•
Когда использовать исключения

Прагматическая паранойя
109
23 Программирование утверждений
В самобичевании
есть своего рода
сладострастие.
И когда мы сами себя виним, мы
чувствуем,
что никто другой не вправе более винить
нас.
Оскар Уайльд, Портрет
Дориана
Грея
В самом начале своей профессиональной карьеры каждый программист обязан вы­
учить некую мантру. Она представляет собой фундаментальную основу компьютер­
ных вычислений, основное вероучение, которое мы учимся применять к требованиям,
конструкциям, самим программам, комментариям — словом, всему, что мы делаем.
Она звучит так:
"Это никогда не может случиться..."
И далее: "Через 30 лет эта программа использоваться не будет, так что для обо­
значения года хватит и двух разрядов". "Нужна ли интернационализация, если это
приложение не будет использоваться за рубежом?" "Счетчик не может принимать от­
рицательное значение". "Этот оператор printf не дает сбоев".
Не стоит заниматься подобного рода самообманом, особенно при написании про­
грамм.
Подсказка 33
Если что-либо не может произойти, воспользуйтесь
утверждениями, которые гарантируют, что это не произойдет
вовсе
Всякий раз, когда вы начинаете думать: "Ну конечно, такого просто не может про­
изойти", проверяйте это высказывание с помощью программы. Самый простой спо­
соб осуществить это — использовать утверждения. В большинстве реализаций язы­
ков С и С + + имеется некоторая разновидность макроса assert или _assert, который
осуществляет проверку логического условия. Эти макрокоманды могут представлять
огромную ценность. Если указатель, передаваемый к вашей процедуре, ни в коем слу­
чае не должен принимать значение NULL, то проверьте выполнение этого условия:
void writeString(char *string) {
assert(string ! = NULL);
Утверждения представляют собой весьма полезное средство проверки работы ал­
горитма. Например, вы написали умный алгоритм сортировки. Проверьте, работает
ли он:
For (int i = 0; i < num_entries-1; i++) {
assert(sorted[i] <= sorted[i+1]);
)

110
Глава 4
Конечно, условие, переданное утверждению, не должно оказывать побочного воз­
действия (см. врезку "Утверждения и побочные эффекты"). Необходимо также пом­
нить, что утверждения могут отключаться во время компиляции — не помещайте в
макрос assert программу, которая должна быть выполнена. Утверждения не должны
использоваться вместо реальной обработки ошибок. Они лишь осуществляют про­
верку того, что никогда не должно произойти: вы же не хотите писать программу, по­
добную приведенной ниже:
printf("Enter
'Y' or 'N': ");
ch = getchar()
assert((ch == "Y") || (ch == 'N')); /* дурной тон! */
И поскольку имеющаяся макрокоманда assert вызывает exit, если утверждение
ложно, нет никаких оснований для того, чтобы этого не могли сделать создаваемые
вами версии программы.. Если вам приходится освобождать ресурсы, сделайте так,
чтобы невыполнение утверждения возбуждало исключение или осуществляло пере­
ход long jump к точке выхода, или же вызывало обработчик ошибки. Убедитесь в том,
что программа, исполняемая в течение миллисекунд, не использует информацию, ко­
торая привела к невыполнению утверждений.
Не отключайте утверждения
Существует расхожее недопонимание утверждений, которое провозгласили те, кто
разрабатывает компиляторы и языковые среды. Оно формулируется примерное так:
"Утверждения
являются
лишним
бременем
для программы.
Поскольку
они проверяют
то, что никогда
не должно случиться,
их действие
ини­
циируется
только ошибкой
в тексте
программы. Как только
программа
проверена
и отправлена
заказчику,
необходимость
в них отпадает
и их
надо отключить
для ускорения
работы
программы.
Утверждения
нуж­
ны лишь во время
отладки".
В этом высказывании имеется два явно неправильных предположения. Первое —
авторы высказывания полагают, что при тестировании обнаруживаются все ошибки.
В действительности маловероятно, что процедура тестирования любой сложной про­
граммы всегда будет происходить по единому сценарию, даже при минимальном про­
центе перестановок в тексте программы (см. "Безжалостное тестирование"). Вто­
рое — эти оптимисты забывают, что ваша программа выполняется в опасном мире.
Весьма вероятно, что во время тестирования крысы не будут прогрызать кабели, ни­
кто не будет забивать память, запуская игрушку, а файлы журналов не переполнят
жесткий диск. Все это может происходить, если ваша программа выполняется в ре­
альных условиях. Ваш первый оборонительный рубеж — проверка наличия любой
вероятной ошибки, а второй — использование утверждений для обнаружения тех
ошибок, которые прошли первый рубеж.
Отключение утверждений при доставке программы заказчику сродни хождению по
канату без страховочной сетки на том основании, что когда-то вы уже так делали.
Сумма страховки велика, но получить ее в случае падения довольно сложно.

Прагматическая паранойя
111
Даже при наличии некоторых проблем с производительностью, отключите только
те утверждения, которые действительно оказывают серьезное воздействие. Пример с
программой сортировки, представленный выше, может быть критической частью ва­
шего приложения и, наверное, должен работать быстро. Добавление процедуры про­
верки означает новое считывание данных, что может быть неприемлемо. Сделайте эту
конкретную процедуру проверки необязательной', но оставьте в покое все остальные.
Утверждения и побочные эффекты
Становится как то неловко, е с л и программа, добавляемая для обнаружения
ошибок, в результате с о з д а е т новые. Это может происходить с утверждения­
ми в том с л у ч а е , е с л и вычисление условия имеет побочные эффекты. Напри­
мер, было бы дурным тоном написать на языке J a v a нечто вроде:
while (iter.hasMoreElements()) {
Test.ASSERT(iter.nextElement() != null);
Object obj = i t e r . nextElement();
/ /
. . . .
}
Вызов .nextElement 0 в ASSERT о б л а д а е т побочным эффектом, заключающим­
с я в перемещении указателя цикла за выбираемый элемент, так что цикл об­
рабатывает лишь половину элементов совокупности. Лучше было бы запи­
сать:
while (iter.hasMoreElements()) {
Object obj = i t e r . nextElement();
Test.ASSERT(obj != null);
/ / . . . .
}
Э т а п р о б л е м а являются разновидностью так называемого "Heisenbug" —
п р о ц е с с а
отладки,
изменяющего
поведение
отлаживаемой
системы
(см. (URL 52)).
Другие разделы, относящиеся к данной теме:
•
Отладка
•
Проектирование по контракту
В языках программирования, имеющих своей основой язык С, можно использовать пре­
процессор или конструкцию с условными операторами с тем, чтобы указанные утвержде­
ния не носили обязательный характер. Во многих разработках происходит отключение ге­
нерации текста программы для макроса assert при установленном (или сброшенном)
флажке этапа компиляции. Можно также поместить текст программы в пределах условно­
го оператора if с постоянным условием, которое многие компиляторы (включая наиболее
распространенные Java-системы) отбросят в ходе оптимизации.

112
Глава 4
•
Балансировка ресурсов
•
Программирование в расчете на совпадение
Упражнения

## Быстрый тест на ощущение реальности. Какие из перечисленных "невозмож­


ных" событий могут случаться в реальности? (Ответ см. в Приложении В.)

## s t a t ( " . " ,


&sb) ==-1 (т. е. невозможно обращение к текущему каталогу)

## В языке Java: (а + 1) <= а


20.
Разработайте несложный класс Java для проверки утверждений (Ответ см.
в Приложении В.)
24 Случаи, в которых используются
исключения
В разделе "Мертвые программы не лгут" высказано предложение считать хорошим
тоном проверку всех возможных ошибок, в особенности тех, которые возникают не­
ожиданно. Однако на практике это может привести к тому, что программа станет
уродливой; нормальная логика вашей программы может сойти на нет из-за ее затума­
нивания процедурами обработки ошибок, особенно если вы являетесь приверженцем
школы программирования, девиз которой звучит так: "В подпрограмме должен
иметься один-единственный оператор return" (авторы не являются приверженцами
указанной школы). Нам приходилось видеть текст программы, выглядевший следую­
щим образом:
retcode = OK;
i f
(socket.read(name)
!= OK) {
retcode = BAD_READ;
}
else
processName(name);
i f
(socket.read(address)
!= OK) {
retcode = BAD_READ;
}
else {
processAddress(address);
i f
(socket.read(telNo)
! = 0 K )
{
retcode= BAD_READ
>

Прагматическая паранойя
113
else {
/ / etc,
e t c . . .
}
}
}
return retcode;
Но если язык программирования (по счастливой случайности) поддерживает ис­
ключения, то эту программу можно написана намного изящнее:
retcode = OK;
try {
socket.read(name);
process(name);
socket.read(address);
processAddress(address);
socket.read(telNo);
/ / etc,
e t c . . .
>
catch (IOException e) {
retcode = BAD_READ;
Logger. log( "Error
reading
individual;
" + e. getMessage());
}
return retcode;
Теперь схема управления отличается ясностью — вся обработка ошибок сосредо­
точена в одном-единственном месте.
Что является исключительным?
Одна из проблем, связанных с исключениями, заключается в том, что необходимо
знать, когда их можно использовать. Мы полагаем, что не стоит злоупотреблять ис­
ключениями для нормального хода выполнения программы; они должны быть заре­
зервированы для нештатных ситуаций. Предположим, что неперехваченное исключе­
ние прекратит работу вашей программы и спросите себя: "А будет ли эта программа
исполняться, если удалить все обработчики исключений?" Если ответ отрицатель­
ный, то вполне возможно, что исключения используются в обстоятельствах, их не
требующих.
Например, если ваша программа пытается открыть файл для чтения, а этот файл
не существует, нужно ли возбуждать исключение?
Мы отвечаем следующим образом: "Это зависит от конкретного случая". Если
файл должен был там находиться, то исключение гарантировано. Произошло что-то
непредвиденное — файл, который вы считали существующим, похоже, исчез. С дру­
гой стороны, если вы понятия не имеете, должен ли этот файл существовать или нет,
то его отсутствие уже не кажется столь исключительным и возвращение ошибки
вполне уместно.
Рассмотрим пример с первой ситуацией. Представленная ниже программа откры­
вает файл /etc/passwd, который обязан существовать во всех системах Unix. Если

114
Глава 4
файл не открывается, происходит передача исключения FileNotFoundException к вы­
зывающей программе.
public void open_passwd() throws FileNotFoundException {
/ / При этом может возбуждаться FileNotFoundException...
ipstream = new
FileInputStream("/etc/passwd");
/ /
. . .
}
Однако во второй ситуации может происходить открытие файла, указанного поль­
зователем в командной строке. Здесь возбуждение исключения не гарантируется, и
программа выглядит по-другому:
public boolean open_user_file(String name)
throws FileNotFoundException {
F i l e f = new File(name):
i f ( I f . e x i s t s O ) {
return false;
}
ipstream = new F i l e I n p u t S t r e a m ( f ) ;
return true;
}
Обратите внимание на то, что вызов FilelnputStream все еще способен генериро­
вать исключение, передаваемое подпрограммой. Но при этом исключение будет сге­
нерировано лишь в действительно исключительных обстоятельствах; простая попыт­
ка открыть несуществующий файл сгенерирует обычное возвращение ошибки.
Подсказка 34
Пользуйтесь исключениями только в исключительных
случаях
Почему мы предлагаем подобный подход к исключениям? Конечно, исключение
представляет собой мгновенную нелокальную передачу управления — своего рода
многоуровневый оператор goto. Программы, использующие исключения в своей
обычной работе, испытывают те же проблемы с удобочитаемостью и сопровожде­
нием, которые свойственны классическим неструктурированным программам. Эти
программы нарушают инкапсуляцию: подпрограммы и их вызывающие программы
отличаются более сильной связанностью за счет обработки исключений.
Обработчики ошибок как альтернатива
исключению
Обработчик ошибок представляет собой подпрограмму, которая вызывается при об­
наружении ошибки. Вы можете зарегистрировать подпрограмму для обработки опре-

Прагматическая паранойя
115
деленной категории ошибок. При возникновении одной из этих ошибок происходит
вызов обработчика.
Возникают ситуации, когда вам захочется применить обработчики ошибок вместо
исключений или же одновременно с ними. Понятно, что, если вы работаете с язы­
ком С, не поддерживающим исключения, это один из нескольких возможных вариан­
тов (см. Вопросы для обсуждения ниже). Но иногда обработчики ошибки могут ис­
пользоваться даже в языках (типа Java), обладающих хорошей встроенной схемой
обработки исключений.
Рассмотрим реализацию приложения "клиент—сервер" с использованием средства
RMI (удаленный вызов метода) в языке Java. Поскольку RMI реализован определен­
ным способом, то каждое обращение к удаленной подпрограмме должно быть подго­
товлено, с тем чтобы обработать ситуацию RemoteException. Добавление программы
обработки этих исключений может представлять собой утомительную процедуру и оз­
начает сложность написания программы, которая могла бы работать как с локальными,
так и с удаленными подпрограммами. Обойти эту трудность возможно путем инкапсу­
лирования удаленных объектов в класс, не являющийся удаленным. Тогда этот класс
сможет реализовать интерфейс обработчика ошибок, позволяя программе клиента ре­
гистрировать подпрограмму, обращение к которой происходит при обнаружении уда­
ленной исключительной ситуации.
Другие разделы, относящиеся к данной теме:
•
Мертвые программы не лгут
Вопросы для обсуждения
•
В языках программирования, не поддерживающих исключительные ситуа­
ции, часто используется иной (нелокальный) способ передачи механизма
управления (например, в языке С существует средство
longjmp/setjmp).
Подумайте, как можно реализовать некий "суррогатный" механизм исклю­
чения, используя указанные средства. В чем состоят преимущества и опас­
ности? Какие специальные меры необходимо предпринять для гарантии
того, что эти ресурсы не "осиротеют"? Есть ли смысл использовать подобное
решение всякий раз, когда вы пишете программу на языке С?
Упражнения

## При проектировании нового класса контейнера имеются три возможных со­


стояния ошибки:

## Указатель null передан к подпрограмме add.


Каким образом необходимо обрабатывать каждую из этих ошибок? Нужна ли
генерация ошибки, возбуждение исключительной ситуации, или же это со­
стояние должно игнорироваться? (Ответ см. в Приложении В.)

116
Глава 4
25 Балансировка ресурсов
"Я привел
тебя в этот мир, — сказал бы мой
отец,
— я же могу и отправить
тебя
обратно.
Мне это без разницы.
Я сделаю
еще
одного такого,
как
ты".
БИЛЛ Косби,
Отцовство
При написании программ всем нам приходится управлять ресурсами: памятью,
транзакциями, потоками, файлами, таймерами — словом, всеми типами объектов,
доступность которых ограничена. Большую часть времени использование ресурса
следует предсказуемой схеме: ресурс назначается, используется, а затем освобож­
дается.
Однако многие разработчики не имеют сколько-нибудь завершенного плана, ка­
сающегося распределения и освобождения ресурсов. Поэтому предлагается простая
подсказка:
Подсказка 35
Доводите до конца то, что начинаете
В большинстве случаев эту подсказку применить несложно. Она всего лишь озна­
чает, что подпрограмма или объект, который назначает ресурс, должен нести ответст­
венность за освобождение этого ресурса. Использование указанной подсказки можно
рассмотреть на примере неудачной программы — приложения, открывающего файл,
считывающего из него информацию о заказчике, обновляющего поле и записываю­
щего результат обратно в файл. Чтобы сделать пример более наглядным, мы опусти­
ли процедуру обработки ошибок.
void readCustomer(const char *fName, Customer *cRec) {
c F i l e = fopen(fName,
" r + " ) ;
fread(cRec,
sizeof(*cRec), 1, c F i l e ) ;
}
void writeCustomer(Customer
*cRec) {
r e w i n d ( c F i l e ) ;
fwrite(cRec,
s i z e o f ( * c R e c ) , 1, c F i l e ) ;
f c l o s e ( c F i l e ) ;
>
void updateCustomer(const char *fName, double newBalance) {
Customer cRec;
readCustomer(fName,
&cRec);
cRec.balance = newBalance;
writeCustomer(&cRec);
}
На первый взгляд, подпрограмма updateCustomer выглядит довольно прилично.
Похоже, что она реализует нужную нам логику — считывает запись, обновляет ба-

Прагматическая паранойя
117
ланс и осуществляет запись обратно в файл. Однако за внешним приличием и скры­
вается главная проблема. Подпрограммы readCustomer и writeCustomer тесно связа­
ны между собой
1 — они совместно используют глобальную переменную cFile.
Подпрограмма readCustomer открывает файл и сохраняет указатель файла в перемен­
ной cFile, a noflnporpaMMf'wrTteCustomer использует сохраненный указатель, для за­
крытия файла по окончании работы. Эта глобальная переменная даже не появляется
в подпрограмме updateCustomer.
Почему эту программу можно считать неудачной? Представим несчастную даму-
программистку из службы сопровождения, которой сказали, что спецификация изме­
нилась — баланс должен обновляться только в том случае, если его новое значение
неотрицательное. Дама открывает файл с исходным текстом и изменяет подпрограм­
му updateCustomer:
void updateCustomer(const char *fName, double newBalance) {
Customer cRec;
readCustomer(fName, ScRec);
if (newBalance >= 0.0) {
cRec.balance = newBalance;
writeCustomer(&cRec);
}
}
Во время испытания все выглядит замечательно. Однако, когда программа вводит­
ся в эксплуатацию, она "падает" через несколько часов, выдавая сообщение "Слиш­
ком много открытых файлов". Поскольку подпрограмма writeBalance в ряде случаев
не вызывается, то и файл не закрывается.
У этой проблемы есть весьма неудачное решение — использовать специальный
оператор выбора в подпрограмме updateCustomer:
void updateCustomer(const char *fName, double newBalance) {
Customer cRec;
readCustomer(fName, &cRec);
if (newBalance >= 0.0) {
cRec.balance = newBalance;
writeCustomer(ScRec);
}
else
fclose(cFile);
}
Это устраняет проблему — теперь файл закроется независимо от нового значения
баланса, но эта процедура означает, что теперь связанными оказываются три под­
программы (через глобальную переменную cFile). Мы попадаем в ловушку, и если
мы продолжаем действовать в том же духе, то все полетит под откос.
Опасности, возникающие из-за связанности в программе, обсуждаются в разделе "Несвя­
занность и закон Деметера".

118
Глава 4
Подсказка "Доводите до конца то, что начинаете" говорит нам о том, что в идеале
подпрограмма, которая назначает ресурс, обязана его и освобождать. Мы можем
применить ее в данном случае, осуществляя небольшую реорганизацию программы:
void readCustomer(FILE * c F i l e ,
Customer *cRec) {
fread(cRec, s i z e o f ( * c R e c ) , 1, c F i l e ) ;
}
void writeCustomer(FILE * c F i l e ,
Customer *cRec) {
r e w i n d ( c F i l e ) ;
fwrite(cRec,
s i z e o f ( * c R e c ) , 1, c F i l e ) ;
}
void updateCustomer(const char *fName, double newBalance) {
FILE
* c F i l e ;
Customer
cRec;
c F i l e = fopen(fName, " r + " ) ;
/ /
>---
readCustomer(cFile,
ScRec);
/ /
|
i f
(newBalance >= 0.0)
{
/ /
|
cRec.balance = newBalance;
/ /
|
writeCustomer(cFile,
ScRec);
/ /
|
>
/ /
I
F c l o s e ( c F i l e ) ;
/ /
<---
}
Теперь всю ответственность за файл несет подпрограмма updateCustomer. Она от­
крывает файл и (заканчивая то, что уже начала) закрывает его перед выходом. Под­
программа осуществляет балансировку использования файла: открытие и закрытие
происходят на одном и том же месте, и очевидно, что каждой процедуре открытия бу­
дет соответствовать процедура закрытия. Реорганизация также позволяет избавиться
от уродливой глобальной переменной.
Вложенное распределение
ресурса
Базовая схема распределения ресурсов может быть распространена на подпрограм­
мы, которым одновременно необходимо более одного ресурса. Поэтому есть еще два
предложения:
1.
Освобождайте ресурсы в последовательности, обратной той, в которой проис­
ходило их распределение. При этом можно избежать появления "осиротев­
ших" ресурсов, если один из них содержит ссылки на другой.
2.
При распределении одного и того же набора ресурсов в различных местах про­
граммы необходимо осуществлять эту операцию в одном и том же порядке. Это
уменьшает
вероятность
взаимоблокировки.
(Если
процесс
А требует
resourcel и собирается затребовать resource2, тогда как процесс В затребо­
вал resource2 и пытается заполучить resourcel, то два процесса окажутся в
состоянии вечного ожидания.)
Неважно, какой тип ресурсов используется — транзакции, память, файлы, пото­
ки, окна, к ним применима общая схема: кто бы ни назначал ресурс, он обязан нести

Прагматическая паранойя
119
ответственность за его освобождение. Однако эта концепция может получить даль­
нейшее развитие при работе с рядом языком программирования.
Объекты и исключения
Равновесие между распределениями ресурсов и их освобождениями напоминает о
равновесии конструктора и деструктора класса. Класс представляет ресурс, конструк­
тор создает для вас конкретный этого типа ресурса, а деструктор удаляет его из вашей
области действия.
Если вы программируете на объектно-ориентированном языке, то упаковка ре­
сурсов в классы может принести пользу. Всякий раз, когда вам необходим конкрет­
ный тип ресурса, вы создаете экземпляр объекта указанного класса. Если объект вы­
ходит из области действия или повторно запрашивается сборщиком мусора, то
деструктор объекта освобождает инкапсулированный ресурс.
Этот подход обладает определенными преимуществами при работе с языками про­
граммирования типа С + + , где исключения могут входить в противоречие с освобож­
дением ресурсов.
Балансировка и исключения
Языки, которые поддерживают исключения, могут сделать процедуру освобождения
ресурса нетривиальной. Как удостовериться, что все ресурсы, назначенные до возбу­
ждения исключения, освобождены надлежащим образом? В некоторой степени ответ
зависит от языка программирования.
Балансировка ресурсов в исключениях языка С++
Язык С + + поддерживает механизм исключений типа t r y . . . catch. К сожалению, это
означает, что всегда существует, по крайней мере, два возможных варианта выхода из
подпрограммы, которая перехватывает, а затем повторно возбуждает исключение:
void doSomething(void) {
Node *n = new Node;
try {
/ / do something
}
catch ( . . . ) {
delete n;
throw;
}
delete n;
}
Заметим, что созданный нами узел освобождается дважды — один раз во время
нормального выхода из подпрограммы, а второй раз в обработчике исключений. Это
явное нарушение принципа DRY и проблема в сопровождении, которая может воз­
никнуть в любой момент.

120
Глава 4
Однако в наших интересах воспользоваться семантикой языка С + + . Локаль­
ные объекты автоматически разрушаются при выходе из блока, в котором они на­
ходятся. Это дает нам несколько вариантов. Если обстоятельства позволяют, мож­
но поменять п: он обозначает не указатель, а реальный объект Node в стеке:
void doSomethingl(void) {
Node n;
t r y
{
/ / делаем что-либо
}
catch ( . . . ) {
throw;
}
}
В этом случае мы используем С + + для автоматического разрушения объекта Node
независимо от того, возбуждено исключение или нет.
В том случае, если замена указателя на объект невозможна, тот же самый эффект
достигается при инкапсулировании ресурса (речь идет об указателе Node) в пределах
другого класса.
//
Класс оболочки для ресурсов
Node
class NodeResource {
Node *n;
public:
NodeResource() { n = new Node; >
"NodeResource() { delete n; }
Node *operator->() { return n; }
} ;
void doSomething2(void) {
NodeResource n;
t r y
{
//
do
something
)
catch ( . . . ) {
throw;
}
}
Теперь класс-оболочка NodeResource выступает гарантом того, что при разруше­
нии его объектов происходит и разрушение соответствующих узлов. Для удобства
класс оболочка предоставляет оператор разыменования ->, с тем чтобы пользователи
могли обращаться к полям в инкапсулированном объекте Node напрямую.
И поскольку эта методика столь полезна, в стандартной библиотеке С + + имеется
шаблонный класс auto_ptr, обеспечивающий автоматические оболочки для динами­
чески размещаемых объектов.
void doSomething3(void) {
auto_ptr"Node" р (new Node);

Прагматическая паранойя
121
//
Обращение к узлу Node как
р->...
/1 В конце узел
автоматически
удаляется
}
Балансировка ресурсов в языке Java
В отличие от С + + язык Java реализует "ленивую" форму автоматического разруше­
ния объекта. Объекты, ссылки на которые отсутствуют, считаются кандидатами на
попадание в "мусор", и их метод f i n a l i z e будет вызываться в любой момент, когда
процедура сборки мусора будет претендовать на эти объекты. Представляя собой
удобство для разработчиков, которым больше не приходится жаловаться на утечки
памяти, в то же время он усложняет реализацию процедуры очистки ресурсов по схе­
ме С + + . К счастью, разработчики языка Java глубокомысленно ввели компенсирую­
щую языковую функцию — предложение f i n a l l y . Если блок t r y содержит предложе­
ние
f i n a l l y ,
то
часть
программы,
относящаяся
к
этому
предложению,
гарантированно исполняется только в том случае, если исполняется любая инструк­
ция в блоке try. Неважно, возбуждается при этом исключение или нет (и даже при
выполнении оператора return программой в блоке t r y ) — программа, относящаяся
к предложению f i n a l l y , будет выполнена. Это означает, что использование ресурса
может быть сбалансировано с помощью программы типа:
public void doSomething() throws IOException {
F i l e tmpFile = new File(tmpFileName);
F i l e W r i t e r
tmp = new
F i l e W r i t e r ( t m p F i l e ) ;
try {
/ / do some work
}
f i n a l l y {
t m p F i l e . d e l e t e ( ) ;
}
}
Подпрограмма использует промежуточный файл, который мы хотим удалить, не­
зависимо оттого, как подпрограмма заканчивает свою работу. Блок f i n a l l y позволя­
ет нам выразить это в сжатой форме.
Случаи, при которых балансировка
ресурсов
невозможна
Возникают моменты, когда основная схема распределения ресурсов просто не годит­
ся. Обычно это происходит в программах, которые используют динамические структу­
ры данных. Одна подпрограмма выделяет область в памяти и связывает ее в структуру
большего размера, где она и находится в течение некоторого времени.
Хитрость здесь состоит в установлении семантического инварианта для выделения
памяти. Необходимо решить, кто несет ответственность за данные в составной струк­
туре. Что произойдет при освобождении структуры верхнего уровня? Есть три основ­
ных варианта развития событий:

122
Глава 4
1.
Структура верхнего уровня также несет ответственность за освобождение лю­
бых входящих в нее подструктур. Затем эти структуры рекурсивно удалят дан­
ные, содержащиеся в них, и т.д.
2.
Структура верхнего уровня просто освобождается. Любые структуры, на ко­
торые она указывает (и на которые нет других ссылок), становятся "осиро­
тевшими".
3.
Структура верхнего уровня отказывается освобождать себя, если в нее входят
какие-либо подструктуры.
В этом случае выбор зависит от условий, в которых находится каждая, взятая в от­
дельности структура данных. Однако этот выбор должен быть явным для каждого слу­
чая, и ваше решение должно реализовываться последовательно. Реализация любого
из представленных вариантов на процедурном языке программирования типа С мо­
жет представлять проблему: структуры данных сами по себе не являются активными.
В этих условиях для каждой из основных структур предпочтительнее написать модуль,
обеспечивающий стандартные средства распределения и освобождения. (Этот модуль
также обеспечивает распечатку результатов отладки, преобразования в последова­
тельную и параллельную формы и средства обхода.)
И наконец, если отслеживание ресурсов становится слишком хитрой процедурой,
можно создать собственную форму ограниченной автоматической сборки "мусора",
реализуя схему подсчета ссылок для ваших динамически распределенных объектов.
В книге "More Effective С+ + " [Меу96] этой теме посвящен целый раздел.
Проверка баланса
Поскольку прагматики не доверяют никому, включая авторов книги, то мы полага­
ем, что во всех случаях неплохо было бы написать такую программу, которая осу­
ществляла бы реальную проверку того, освобождены ли ресурсы надлежащим об­
разом. Для большинства приложений это обычно означает создание оболочек для
каждого типа ресурса и их использование для отслеживания всех распределений и
освобождений. В некоторых точках программы логика диктует, что ресурсы нахо­
дятся в определенном состоянии; для проверки этого и необходимо использовать
оболочки.
Например, в программе, выполняемой на протяжении длительного времени и об­
служивающей запросы, наверняка есть одна-единственная точка в начале основного
цикла обработки, в которой происходит ожидание прихода следующего запроса.
Именно в этой точке можно получить подтверждение тому, что с момента последнего
выполнения цикла использование ресурсов не увеличилось.
При работе на более низком (но не менее полезном) уровне можно потратиться на
инструментальные средства, которые (помимо всего прочего) проверяют выполняе­
мые программы на наличие утечек памяти (регулярного неосвобождения области па­
мяти). Весьма
популярными являются Purify (www.rational.com) и Insure + +
(www. parasoft. com).

Прагматическая паранойя
123
Другие разделы, относящиеся к данной теме:
•
Проектирование по контракту
•
Программирование утверждений
•
Несвязанность и закон Деметера
Вопросы для обсуждения
•
Несмотря на то, что не существует надежных способов удостовериться в том,
что вы освободили ресурсы, в этом могут помочь некоторые технологии про­
ектирования, если их применять последовательно. В данной главе обсужда­
лось, как установить семантический инвариант с тем, чтобы основные струк­
туры данных могли управлять освобождением памяти. Подумайте, как с
помощью принципа "Проектирование по контракту" можно было бы усовер­
шенствовать эту идею.
Упражнения

## Некоторые разработчики программ на С и С+ + обращают особое внимание


на необходимость установки указателя в NULL после освобождения области
памяти, на которую он ссылается. Почему это можно считать удачной идеей?
(Ответ см. в Приложении В)

## Некоторые разработчики программ на языке Java обращают особое внимание


на необходимость установки объектной переменной в NULL после окончания
использования объекта. Почему это можно считать удачной идеей? (Ответ см.
в Приложении В)


Глава 5
Гибкость против хрупкости
Жизнь не стоит не месте.
Не могут стоять на месте и программы, которые мы пишем. Чтобы не отставать от
сегодняшнего, близкого к кошмару, темпа изменений, нам необходимо приложить все
усилия для написания программ слабосвязанных и гибких, насколько это возможно.
В противном случае мы придем к тому, что наша программа быстро устареет или ста­
нет слишком хрупкой, что не позволит устранять ошибки, и может в конечном итоге
оказаться в хвосте сумасшедшей гонки в будущее.
В разделе "Обратимость" говорится об опасностях необратимых решений. В этой
главе мы расскажем вам, как принимать обратимые решения так, чтобы ваша програм­
ма оставалась гибкой и адаптируемой перед лицом нашего неопределенного мира.
Вначале необходимо рассмотреть связывание — взаимозависимость между моду­
лями программы. В разделе "Несвязанность и закон Деметера" будет показано, как
сохранить отдельные концепции и уменьшить связывание.
Хороший способ сохранить гибкость — это писать программы меньшего размера.
Изменение кода открывает перед вами возможность внесения новых дефектов. В раз­
деле "Метапрограммирование" объясняется, как полностью вывести из текста про­
граммы подробности в то место, где их можно изменить безопаснее и проще.
В разделе "Временное связывание".рассматриваются два временных аспекта при­
менительно к связыванию. Зависите ли вы от того обстоятельства, что "тик" наступа­
ет раньше, чем "так"? Если вы хотите сохранить гибкость, то нет!
Ключевым принципом в создании гибкой программы является отделение модели дан­
ных от их визуального представления, или воспроизведения. Несвязанность модели и ее
визуального представления описана в разделе "Всего лишь визуальное представление".
И наконец, существует методика несвязанности модулей в еще большей степени
за счет предоставления "места встречи", где модули могут обмениваться данными
анонимно и асинхронно. Эта тема освещена в разделе "Доски объявлений".
Взяв эти методики на вооружение, вы можете написать программу, которая будет
энергично вращаться, — как в рок-н-ролле.

126
Глава 5
26 Несвязанность и закон Деметера
Хорошая изгородь
— добрые
соседи.
Роберт Фрост, Подготовка
к
выборам
В разделах "Ортогональность" и "Проектирование по контракту" мы высказали пред­
положение, что выгодно писать "скромные" программы. Но эта "скромность" работа­
ет в двух направлениях: не раскрывайте себя перед другими и не общайтесь со слиш­
ком многими людьми.
Шпионы, диссиденты, революционеры и им подобные часто организованы в не­
большие группы, называемые ячейками. Хотя отдельные личности в каждой ячейки
могут знать друг о друге, они не знают ничего об участниках других ячеек. Если одна
ячейка раскрыта, то никакое количество "сыворотки правды" неспособно выбить из
ее участников информацию об их сподвижниках вне пределов ячейки. Устранение
взаимодействий между ячейками убережет всех.
Мы полагаем, что этот принцип хорошо бы применить и к написанию программ.
Разбейте вашу программу на ячейки (модули) и ограничьте взаимодействие между
ними. Если один модуль находится под угрозой и должен быть заменен, то другие мо­
дули должны быть способны продолжить работу.
Сведение связанности к минимуму
Что произойдет, если появятся модули, которые знают друг о друге. В принципе ни­
чего — вы не должны впадать в паранойю, как шпионы или диссиденты. Однако вам
необходимо внимательно следить за тем, со сколькими другими модулями вы взаимо­
действуете. Это важнее, чем то, каким образом вы пришли к взаимодействию с ними.
Предположим, что вы занимаетесь перепланировкой своего дома или строите дом
с нуля. Обычная организация включает "генерального подрядчика". Вы нанимаете
подрядчика для выполнения работ, но подрядчик выполняет или не выполняет эти ра­
боты сам; работа может быть предложена разнообразным субподрядчикам. Но, буду­
чи клиентом, вы не имеете дело с субподрядчиками напрямую, генеральный подряд­
чик берет от вашего имени эту головную боль на себя.
Нам бы хотелось воспользоваться той же моделью в программном обеспечении.
Когда мы запрашиваем у объекта определенную услугу, то мы хотим, что бы эта услу­
га оказывалась от нашего имени. Мы не хотим, чтобы данный объект предоставлял
нам еще какой-то объект, подготовленный третьей стороной, с которым нам придется
иметь дело для получения необходимой услуги.
Предположим, что вы пишете класс, который генерирует график поданным на­
учного прибора. Научные приборы рассеяны по всему миру, каждый объект-
прибор содержит объект-местоположение, который дает информацию о его распо­
ложении и часовом поясе. Вы хотите, чтобы ваши пользователи могли выбирать
прибор и наносить его данные на график с отметкой часового пояса. Вы можете
записать

Гибкость против хрупкости
127
public void plotOate(Date aDate, Selection aSelection) {
TimeZone tz =
ASelection.getRecorder().getLocation().getTimeZone();
}
Но теперь подпрограмма построения графика без особой надобности связана с
тремя классами — Selection, Recorder и Location. Этот стиль программирования
резко увеличивает число классов, от которых зависит наш класс. Почему это нехоро­
шо? Потому что при этом увеличивается риск того, что внесение несвязанного изме­
нения в другой части системы затронет вашу программу. Например, если сотрудник
по имени Фред вносит изменение в класс Location так, что он непосредственно более
не содержит TimeZone, то вам придется внести изменения и в свою программу.
Вместо того чтобы продираться через иерархию самостоятельно, просто спросите
напрямую о том, что вам нужно:
public void plotOate(Date aDate, TimeZone aTz) {
}
plotOate(someDate,
someSelection.getTimeZone());
Мы добавили метод к классу Selection, чтобы получить часовой пояс от своего
имени; подпрограмме построения графика неважно, передается ли часовой пояс не­
посредственно из класса Recorder, от некоего объекта, содержащегося в Recorder,
или же класс Selection сам составляет другой часовой пояс. В свою очередь, подпро­
грамма выбора должна запросить прибор о его часовом поясе, оставив прибору право
получить его значение из содержащегося в нем объекта Location.
Непосредственное пересечение отношений между объектами может быстро при­
вести к комбинаторному взрыву
1 отношений зависимости. Признаки этого явления
можно наблюдать в ряде случаев:
1.
В крупномасштабных проектах на языках С или С+ + , где команда компоновки
процедуры тестирования длиннее, чем сама программа тестирования
2.
"Простые" изменения в одном модуле, которые распространяются в системе
через модули, не имеющие связей
3.
Разработчики, которые боятся изменить программу, поскольку они не увере­
ны, как и на чем скажется это изменение
Системы, в которых имеется большое число ненужных зависимостей, отличаются
большой сложностью (и высокими затратами) при сопровождении и в большинстве
случае весьма нестабильны. Для того чтобы поддерживать число зависимостей на ми­
нимальном уровне, мы воспользуемся законом
Деметера
при проектировании на­
ших методов и функций.
1
Если п объектов знают друг о друге всё, то при изменении одного-единственного объекта
возникает потребность в изменении оставшихся п — 1 объектов.

128
Глава 5
Закон Деметера для функций
Закон Деметера для функций [LH89] пытается свести к минимуму связывание между
модулями в любой программе. Он пытается удержать вас от проникновения в объект
для получения доступа к методам третьего объекта. Краткое содержание данного за­
кона представлено на рис. 5.1.
Создавая "скромную" программу, в которой закон Деметера соблюдается в макси­
мально возможной степени, мы можем добиться цели, выраженной в следующей под­
сказке:
Оказывает ли следование закону Деметера (каким бы хорошим он ни был с точки
зрения теории) реальную помощь в создании программ, более простых в сопровож­
дении?
Исследования [ВВМ96] показали, что классы в языке С+ + с большими совокуп­
ностями откликов менее ошибкоустойчивы, чем классы с небольшими совокупностя­
ми (совокупность откликов представляет собой число функций, непосредственно вы­
зываемых методами конкретного класса).
class Demeter {
Подсказка 36
Минимизируйте связывание между модулями
А не все ли равно?
private:
А*а;
i
int func()
г.
public:
о
//...
п
void example(B& b);
}
void Demeter::example(B& b) {
С с;
Закон Деметера для функций
гласит, что любой метод некоторого
объекта должен обращаться только к методам
принадлежащим:
int f = [func();h
самим себе
b.invertQ;
любым параметрам, переданным в метод
а = new А();
ja->setActiveQ;
любым создаваемым им объектам
Ic.printQ; f
любым непосредственно содержащимся объектам компонентов
Рис. 5.1.
Закон Деметера для функций
Поскольку следование закону Деметера уменьшает размер совокупности отклика
в вызывающем отклике, то классы, спроектированные данным образом, также будут

Гибкость против хрупкости
129
менее склонны к наличию ошибок (см. [URL 56], где приводится более подробная ин­
формация о статьях и других источниках по проекту Деметера).
Использование закона Деметера сделает вашу программу более адаптируемой и ус­
тойчивой, но не бесплатно: будучи "генеральным подрядчиком", ваша программа должна
непосредственно делегировать полномочия и управлять всеми существующими субпод­
рядчиками, не привлекая к этому клиентов вашего модуля. На практике это означает, что
вы будете создавать большое количество методов-оболочек, которые просто направляют
запрос далее к делегату. Эти методы-оболочки влекут за собой расходы во время испол­
нения и накладные расходы дискового пространства, которые могут оказаться весьма
значительными, а для некоторых приложений даже запредельными.
Как и при использовании любой методики, вы должны взвесить все "за" и "про­
тив" для вашего конкретного приложения. В проекте схемы базы данных обычной
практикой является "денормализация" схемы для улучшения производительности:
нарушение правил нормализации в обмен на скорость выполнения. Подобного же
компромисса можно достичь и в этом случае. На самом деле, обращая закон Деметера
и плотно связывая несколько модулей, вы можете получить существенный выигрыш в
производительности. Ваша конструкция работает прекрасно, пока она известна и
приемлема для этих связываемых модулей.
Физическая несвязанность
В данном р а з д е л е мы много говорим о сохранении логической несвязанно­
сти между элементами проектируемой системы. О д н а к о существует взаимо­
зависимость другого р о д а , которая становится весьма существенной с уве­
личением м а с ш т а б а с и с т е м . В своей книге "Large-Scale С++ Software Design"
(Lak96) Джон Л а к о с о б р а щ а е т с я к вопросам, к а с а ю щ и м с я отношений меж­
д у файлами, каталогами в и библиотеками, составляющими систему. Игно­
рирование этих проблем физического проектирования в крупномасштабных
проектах приводит, помимо прочих проблем, к тому, что цикл с б о р к и может
растягиваться н а несколько дней, а процедуры модульного
тестирования
могут сорвать с р о к и готовности всей системы. Г-н Л а к о с приводит убеди­
тельные доказательство того, что логическое и физическое проеюгирования
должны осуществляться в т а н д е м е и что устранение повреждений в большом
фрагменте программы, нанесенных ему циклическими зависимостями, пред­
ставляется чрезвычайно трудным делом. Мы рекомендуем вам прочесть эту
книгу, е с л и вы участвуете в разработке крупномасштабных проектов, д а ж е
е с л и вы осуществляете реализацию на языке, отличном от С++.
В противном случае вы можете оказаться на пути к хрупкому, негибкому будуще­
му. Или вообще оказаться без будущего.
Другие разделы, относящиеся к данной теме:
•
Ортогональность
•
Обратимость

130
Глава 5
•
Проектирование по контракту
•
Балансировка ресурсов
•
Всего лишь визуальное представление
•
Команды прагматиков
•
Безжалостное тестирование
Вопросы для обсуждения
•
Мы обсудили, как делегирование полномочий облегчает соблюдение закона
Деметера и, следовательно, уменьшает связывание. Однако написание всех
методов, необходимых для пересылки вызовов к делегированным классам,
является утомительной процедурой, чреватой ошибками. Каковы преиму­
щества и недостатки написания препроцессора, который автоматически ге­
нерирует эти вызовы? Должен ли этот препроцессор запускаться только
единожды, или же он должен применяться как составная часть процесса
сборки?
Упражнения

## Мы обсудили концепцию физической несвязанности в последней врезке. Ка­


кой из указанных ниже файлов заголовка в языке С+ + характеризуется более
сильным связыванием с остальной системой? (Ответ см. в Приложении В.)
personl.
h
person2.h

## В данном примере и примерах, входящих в упражнения 26 и 27, определите, яв­


ляются ли показанные вызовы метода допустимыми с точки зрения закона Де­
метера. Первый пример написан на языке Java. (Ответ см. в Приложении В.)
public void showBalance(BankAccount acct) {
Money amt = acct.getBalance();
printToScreen(amt.printFormat());
}

## Этот пример также написан на языке Java. (Ответ см. в Приложении В.)


public class Colada {
private Blender myBlender;
private Vector myStuff;
public ColadaO {
myBlender = new BlenderO;
#include
"date.h"
class Personl {
private:
class Date;
class Person2 {
private:
Date myBirthdate;
public:
DaTe *myBirthdate;
public:
Personl(Date &birthDate);
// ...

Гибкость против хрупкости
131
myStuff = new V e c t o r O ;
}
private void doSomething()
{
myBlender.addIngredients(myStuff.
elements());
}
}

## Этот пример написан на языке С+ + . (Ответ см. в Приложении В.)


void processTransaction(BankAccount acct, int)
{
Person *who;
Money amt;
amt.setValue(123.45);
acct.setBalance(amt);
who = acct.getOwnerQ;
markWorkflow(who->name(),
SET_BALANCE);
}
27 Метапрограммирование
Никакая
гениальность
не
спасает
от любви
к
подробностям.
Восьмой закон Леви
Подробности смешивают все в нашей первоначальной программе — особенно если
эти подробности часто меняются. Каждый раз, когда нам приходится входить в про­
грамму и вносить в нее изменения для того, чтобы привести ее в соответствие с изме­
нившейся бизнес-логикой, законодательством или вкусами руководства, мы рискуем
нарушить систему, т.е. внести в нее новый дефект.
Поэтому мы говорим: "долой подробности!" Уберите их из программы. В этом слу­
чае мы можем сделать нашу программу гибкой при настройке и легко адаптирующей­
ся к изменениям.
Динамическая конфигурация
Прежде всего мы хотим сделать наши системы гибкими при настройке. Это касается
не только цвета экрана и текста, но и более глубоких вещей, таких как выбор алгорит­
мов, программ баз данных, технологии связующего программного обеспечения и сти­
ля пользовательского интерфейса. Эти пункты должны реализовываться в виде вари­
антов конфигурации, а не за счет интеграции или технологии.
Подсказка 37
Осуществляйте настройку, а не интеграцию
Используйте метаданные
для спецификации вариантов настройки приложения:
подгонки параметров, глобальных параметров пользователя, каталога, в который
производится установка приложения, и т.д.

132
Глава 5
Так что же такое метаданные? Строго говоря, метаданные — это данные о дан­
ных. Наиболее распространенным примером, вероятно, является схема базы дан­
ных или словарь данных. Схема содержит данные, которые описывают поля (столб­
цы) в терминах имен, длины и других атрибутов. Вы должны иметь возможность
доступа к этой информации и ее обработки, так как если бы это были любые другие
данные в этой базе.
Мы используем этот термин в самом широком смысле. Метаданные — это любые
данные, которые описывают приложение, — как оно выполняется, какие ресурсы
обязано использовать и т.д. Обычно, доступ к данным и их использование на этапе
выполнения, а не компиляции. Вы используете метаданные все время, по крайней
мере, делают ваши программы. Предположим, вы щелкаете мышью для того, чтобы
скрыть панель инструментов в интернет-браузере. Браузер будет сохранять эти гло­
бальные параметры как метаданные в своего рода внутренней базе данных.
Эта база данных может быть сформирована в собственном формате или может
воспользоваться стандартным механизмом. При работе в операционной системе
Windows таким механизмом является либо файл инициализации (используется суф­
фикс . ini), либо записи в системном реестре. При работе с Unix подобная функцио­
нальная возможность обеспечивается системой X Window с помощью файлов
Application Default. Java использует файлы Property. Во всех этих средах для извлече­
ния значения вы указываете ключ. В других, более мощных и гибких реализациях ме­
таданных используется встроенный язык сценариев (см. "Языки, отражающие специ­
фику предметной области").
При реализации этих глобальных параметров в браузере Netscape фактически
использованы обе эти технологии. В версии 3 параметры сохранялись в виде пар
"ключ—значение":
SH0W_T00LBAR: False
В версии 4 параметры больше напоминали JavaScript:
user_pref("custtoolbar.Browser.Navigation_Toolbar.open",
f a l s e ) ;
Приложения, управляемые метаданными
Но мы хотим большего, нежели использовать метаданные для простых глобальных
параметров. Мы хотим настраивать и управлять приложением через метаданные —
насколько этом возможно. Наша цель — думать описательно (обозначая, что должно
быть сделано, а не как это должно быть сделано) и создавать высокодинамичные и
адаптируемые программы. Это можно сделать, придерживаясь общего правила: про­
граммировать для общего случая и помещать всю специфику в другое место — за
пределы компилируемого ядра программы.
Подсказка 38
Помещайте абстракции в текст программы, а подробности —
в область метаданных

Гибкость против хрупкости
133
Этот подход характеризуется несколькими преимуществами:
•
Он вынуждает вас делать конструкцию несвязанной, что приводит к созда­
нию более гибкой и адаптируемой программы.
•
Он заставляет вас создавать более устойчивую, абстрактную конструкцию,
за счет отнесения подробностей, выводя все подробности за пределы про­
граммы.
•
Вы можете настроить приложение, не прибегая к его перекомпиляции. Вы
также можете использовать это уровень настройки для обеспечения обход­
ных путей при критических дефектах систем, находящихся в эксплуатации.
•
Метаданные могут быть выражены способом, который находится намного
ближе к предметной области, по сравнению с универсальным языком про­
граммирования (см. "Языки, отражающую специфику конкретной области").
•
Вы даже сможете реализовывать несколько различных проектов, используя
то же самое ядро приложения, но с различными метаданными.
До последнего момента мы хотели отложить определение большинства подроб­
ностей и оставить их как можно менее сложными для изменения. Создавая реше­
ние, позволяющее нам вносить изменения быстро, мы можем лучше справляться с
потоком направленных сдвигов, которые погубили многие проекты (см. "Обрати­
мость").
Бизнес-логика
Итак, вы выбрали механизм базы данных в качестве опции настройки и предусмотре­
ли метаданные для определения стиля пользовательского интерфейса. Можем ли мы
сделать большее? Несомненно.
Поскольку изменение стратегии и бизнес-правил более вероятно в сравнении с
любым другим аспектом проекта, есть смысл поддерживать их в очень гибком фор­
мате.
Например, ваше приложение, автоматизирующее процесс закупок, может вклю­
чать в себя различные корпоративные стратегии. Может быть, вы производите опла­
ту небольшим фирмам-поставщикам через 45 дней, а большим — через 90 дней. Сде­
лайте настраиваемыми определения типов поставщиков, а также самих периодов
времени. Используйте возможность обобщения.
Возможно, вы создаете систему с ужасающими требованиями к последователь­
ности операций. Действия начинаются и заканчиваются согласно сложным (и изме­
няющимся) бизнес-правилам. Подумайте об их реализации в виде некой системы на
основе правил (или экспертной системы), встроенной в ваше приложение. Тем са­
мым вы осуществите его настройку за счет написания правил, а не программы.
Менее сложная логика может быть выражена при помощи мини-языка, что де­
лает необязательным повторную компиляцию и развертывание при изменении
среды. Пример приведен в разделе "Языки, отражающие специфику предметной
области".

134
Глава 5
Когда осуществлять настройку
Как было упомянуто в р а з д е л е "Преимущество простого текста", рекоменду­
е т с я представлять метаданные о настройке в формате простого текста —
это д е л а е т жизнь проще.
Но когда
программа должна
осуществлять считывание
этой
настройки?
Многие программы осуществляют просмотр только при неудачном
запуске.
Если вам необходимо изменить настройку, то это вынуждает в а с п е р е з а п у с ­
кать приложение. Более гибким подходом является написание программ, ко­
торые могут перезагружать свои настройки во время выполнения. Но э т а гиб­
кость обходится недешево: она б о л е е сложна в реализации.
Р а с с м о т р и м , как будет использоваться н а ш е приложение: е с л и это про­
должительный серверный
п р о ц е с с , то вам понадобится некий
механизм
для повторного считывания и применения метаданных в х о д е
выполнения
программы. Для небольшого
клиентского приложения с графическим
ин­
т е р ф е й с о м , которое п е р е з а п у с к а е т с я достаточно быстро, это может и не
понадобиться.
Д а н н о е явление не ограничивается прикладными программами. В с е мы раз­
д р а ж а е м с я , е с л и операционные системы заставляют н а с проводить пере­
загрузку
при установке
простых приложений или изменении
совершенно
безвредного
п а р а м е т р а .
Пример: пакет Enterprise Java Beans
Пакет EJB (Enterprise Java Beans) является интегрированной средой, предназна­
ченной для упрощения программирования в распределенной среде, основанной на
транзакциях. Этот пакет упоминается в связи с тем, что он иллюстрирует использо­
вание метаданных для настройки приложений и упрощения процедуры написания
программы.
Предположим, что вы хотите создать, некоторую программу на языке Java, кото­
рая будет принимать участие в транзакциях на различных машинах, с базами данных
от различных производителей и с разными моделями потоков и распределения на­
грузки.
Хорошая новость: вам не нужно беспокоиться обо всем этом. Вы пишете так
называемый bean-элемент — отдельный объект, который следует определенным
соглашениям, и помещаете его в контейнер bean-элементов, управляющий многи­
ми низкоуровневыми средствами от вашего имени. Вы можете писать программу
для bean-элемента, не включая какие-либо транзакционные операции или управ­
ление потоками; пакет EJB использует метаданные для указания способа обработ­
ки транзакций.
Назначение потока и распределение нагрузки указываются как метаданные для
основной службы транзакций, используемой контейнером. Это разделение допускает
большую гибкость при динамической настройке среды во время работы.

Гибкость против хрупкости
135
Контейнер bean-элемента может управлять транзакциями от имени
bean-
элемента одним из нескольких различных способов (включая вариант управления
собственными обновлениями и отменой транзакций). Все параметры, которые воз­
действуют на поведение bean-элемента, указаны в описателе развертывания послед­
него — объекте, преобразованном в последовательную форму и содержащем нужные
метаданные.
Распределенные системы, подобные EJB, прокладывают путь в новый мир — мир
настраиваемых, динамичных систем.
Совместная
настройка
Уже говорилось о пользователях и разработчиках, настраивающих динамические
приложения. Но что происходит, если вы позволяете приложениям настраивать друг
друга? Речь идет о программах, которые адаптируются к операционной среде. Неза­
планированная, импровизированная настройка существующего программного обес­
печения является мощной концепцией.
Операционные системы уже способны подстраивать себя при загрузке под аппа­
ратное обеспечение, а web-браузеры автоматически обновляются, инсталлируя но­
вые компоненты.
Большие приложения, с которыми вы работаете, уже имеют проблемы с управле­
нием различными версиями данных и различными версиями библиотек и операцион­
ных систем. Возможно, здесь будет полезен более динамичный подход.
Не пишите нежизнеспособных программ
В отсутствие метаданных ваша программа не является столь адаптируемой или
гибкой, какой она могла бы стать в противном случае. Плохо ли это? В реальном мире
виды, которые не могут адаптироваться, умирают.
Птицы додо не смогли приспособиться к присутствию людей и домашних живот­
ных на острове Маврикий и быстро вымерли'. Это было первое документально под­
твержденное исчезновение вида от рук человека.
Не дайте вашему проекту (или карьере) повторить судьбу птицы додо.
Другие разделы, относящиеся к данной теме:
•
Ортогональность
•
Обратимость
•
Языки, отражающие специфику предметной области
•
Преимущество простого текста
Вопросы для обсуждения
•
Работая над текущим проектом, подумайте о следующем: какая часть про­
граммы может быть убрана из нее и перемещена в область метаданных? Как
На мирных (читай глупых) птиц додо не действовало даже то, что поселенцы забивали их до
смерти спортивными битами.

136
Глава 5
в итоге будет выглядеть "ядро" программы? Сможете ли вы повторно ис­
пользовать этот ядро в контексте иного приложения?
Упражнения

## Что из нижеследующего лучше представить в виде фрагмента программы, а что


лучше вывести за ее пределы в область метаданных?

## Поддержка выделения синтаксиса различных языков в программе редак­


тирования.

## Типовые значения и результаты, используемые в тестировании модулей


28 Временное связывание
Временное связывание — о чем это? — спросите вы. Это — о времени.
Время — аспект, который часто игнорируется в архитектуре программного обес­
печения. Единственный временной параметр, который занимает наш ум, — это время
выполнения проекта, время, оставшееся до отправки продукта заказчику, но здесь
разговор не об этом, а о роли временного фактора как элемента проектирования са­
мого программного обеспечения. Есть два временных аспекта, представляющих важ­
ность для нас: параллелизм (события, происходящие в одно и то же время) и упорядо­
чивание (относительное положение событий во времени).
Обычно мы не подходим к программированию, держа в голове тот или иной ас­
пект. Когда люди садятся за проектирование, разработку архитектуры или написание
программы, события стремятся к линейности. Это и есть способ мышления большин­
ства людей — сначала сделать "это", а потом сделать "то". Но этот способ мышления
приводит к связыванию во времени. Метод А всегда должен вызываться перед мето­
дом В; одновременно должен формироваться только один отчет; необходимо подож­
дать перерисовки экрана до получения отклика на щелчок мыши. "Тик" обязан проис­
ходить раньше, чем "так".
Этот подход не отличается большой гибкостью и реализмом.
Нам приходится учитывать параллелизм
1 и думать о несвязанности любых вре­
менных или упорядоченных зависимостей. При этом мы выигрываем в гибкости и
уменьшаем любые зависимости, основанные на времени во многих областях разра­
ботки: анализе последовательности операций, архитектуре, проектировании и раз­
вертывании.
В книге не рассматриваются подробности параллельного программирования; в хорошем
учебнике по информатике даются его основы, включая диспетчеризацию, взаимоблокиров­
ку, зависание процесса, взаимоисключение, семафоры и т.д.

Гибкость против хрупкости
137
Последовательность операций
При работе над многими проектами нам приходится моделировать и анализировать
последовательности операций пользователей, что является частью анализа требова­
ний. Мы хотели бы выяснить, что может происходить в то же время, а что — в стро­
гой последовательности. Одним из способов осуществить задуманное является созда­
ние диграммы последовательностей с помощью системы обозначений наподобие
языка UML (унифицированного языка моделирования)
1.
Диаграмма состоит из совокупности действий, изображенных в виде прямоуголь­
ников с закругленными уголками. Стрелка, выходящая из одной операции, идет либо
к другой операции (которая может начаться после того, как первая закончится) или к
жирной линии, называемой полосой синхронизации.
Как только все операции, на­
правленные к полосе синхронизации, завершаются, то вы можете перемещаться по
стрелкам, идущим от полосы синхронизации. Операция, на которую не указывают ни­
какие стрелки, может быть начата в любой момент.
Вы можете использовать диаграммы, чтобы добиться максимального параллелиз­
ма, определив те процессы, которые могли бы осуществляться параллельно, но не де­
лают этого.
Подсказка 39
Анализируйте последовательность операций для увеличения
параллелизма
Например, в проекте блендера для коктейлей (упражнение 17) пользователи мо­
гут вначале описать последовательность операций следующим образом:

## Подать


1
Более подробная информация обо всех типах диаграмм UML (унифицированного языка
моделирования) содержится в книге [FS97].

138
Глава 5
Хотя они описывают эти операции последовательно (и даже могут выполнять их
последовательно), заметим, что многие из них могли бы выполняться параллельно,
как показано на блок-схеме (см. рис. 5.2).
Это может открыть вам глаза на реально существующие зависимости. В этом слу­
чае задачи высшего уровня приоритета (1, 2, 4, 10, и 11) могут выполняться парал­
лельно, как бы авансом. Задачи 3, 5 и 6 могут выполняться параллельно, но позже.
Если бы вы участвовали в конкурсе по приготовлению коктейлей "Пинаколада",
эти оптимальные решения выгодно отличали бы вас от всех остальных.
•"2. Открыть упаковку\
со смесью
J
"ПинаКолада"
у

Рис. 5.2.
Диаграмма
на языке
UML: приготовление
коктейля
"Пинаколада"
Архитектура
Несколько лет назад мы написали систему оперативной обработки транзакций
(OLAP — on-line transaction processing). В простейшем варианте, все что должна
была сделать система, — это принять запрос и обработать транзакцию в сравне­
нии с БД. Но мы написали трехзвенное, многопроцессорное распределенное при­
ложение: каждый компонент представлял собой независимую единицу, которая
выполнялась параллельно со всеми другими компонентами. Хотя при этом возни-

Гибкость против хрупкости
139
кает впечатление большой работы, это не так: при написании этого приложения
мы использовали преимущество временной несвязанности. Рассмотрим этот про­
ект более подробно.
Система принимает запросы от большого числа каналов передачи данных и обра­
батывает транзакции в рамках БД.
Проект налагает следующие ограничения:
•
Операции с БД занимают сравнительно большое время.
•
При каждой транзакции мы не должны блокировать коммуникационные
службы в момент обработки транзакции БД.
•
Производительность базы ухудшается за счет слишком большого числа па­
раллельных сеансов.
•
Множественные транзакции осуществляются параллельно на каждой линии
передачи данных.
Решение, обеспечивающее наилучшую производительность и самый четкий ин­
терфейс, выглядит подобно представленному на рис. 5.3.
Входная
задача—#1
Входная
задача — # 2
Входная
задача — in
Рис. 5.3.
Общая схема архитектуры
системы
оперативной
обработки
транзакций
Очередь
приложения
Логика
приложения # 1
Логика
приложения # п
Очередь
III III
Обработчик
lllllll
БД
БД
Каждый прямоугольник обозначает отдельный процесс; процессы связываются
через очереди работ. Каждый входной процесс отслеживает состояние одного входно­
го канала связи и осуществляет запросы к серверу приложения. Все запросы являют­
ся асинхронными: как только входной процесс осуществляет текущий запрос, он сразу
же возвращается к отслеживанию канала на наличие трафика. Точно так же сервер
приложения осуществляет запросы процесса БД
1 и уведомляется в момент заверше­
ния отдельной транзакции.
Несмотря на то, что база данных показана как единое целое, это не так. Программное
обеспечение баз данных разделено на несколько процессов и клиентских потоков, но их об­
работка производится внутренними программами БД и не является частью примера, при­
веденного в книге.

140
Глава 5
На этом примере также демонстрируется способ быстрого и грубого распределе­
ния нагрузки между множественными потребительскими процессами: это так назы­
ваемая модель голодного потребителя.
В модели голодного потребителя центральный планировщик заменяется на не­
сколько независимых задач потребителя и централизованную очередь работ. Каждая
задача потребителя захватывает некий фрагмент очереди работ и продолжает зани­
маться своим делом — его обработкой. Как только задача заканчивает свою работу,
она возвращается к очереди за новой порцией. В этом случае, если выполнение
какой-либо задачи срывается, другие задачи могут "натянуть поводья" и каждый от­
дельный компонент может продолжаться в своем собственном темпе. Происходит
временная несвязанность компонента и других компонентов.
Подсказка 40
Проектируйте, используя службы
На самом деле вместо компонентов мы создали службы — независимые, па­
раллельные объекты скрытые за четко определенными, непротиворечивыми ин­
терфейсами.
Проектирование с использованием принципа
параллелизма
Поскольку Java все чаще принимается в качестве платформы, многих разработчики
перешли к многопоточному программированию. Но программирование с использова­
нием потоков налагает на конструкцию некоторые ограничения — и это хорошо. Эти
ограничения в действительности настолько полезны, что нам хотелось бы пребывать
под их благодатным покровом, когда бы мы ни занимались написанием программ. Это
поможет нам делать нашу программу несвязанной и бороться с так называемым про­
граммированием в расчете на стечение обстоятельств (см. ниже одноименный раздел).
При работе с линейной программой легко сделать предположения, которые в ко­
нечном итого приведут к небрежно написанным программам. Но параллелизм застав­
ляет вас задумываться о происходящем несколько глубже — вы больше не находи­
тесь в безвоздушном пространстве. Поскольку многие события могут теперь
происходить "в одно и то же время", вы можете внезапно столкнуться с зависимостя­
ми, основанными на факторе времени.
Прежде всего, необходимо защитить любые глобальные или статические пере­
менные от параллельного доступа. Теперь можно задать самому себе вопрос, зачем
нужна глобальная переменная на первом месте. Кроме того, необходимо убедиться в
том, что вы предоставляете непротиворечивую информацию о состоянии, независимо
от порядка вызовов. Например, в какой момент допускается опрашивание состояния
вашего объекта? Если ваш объект находится в недопустимом состоянии в период ме­
жду определенными вызовами, то вы, вероятно, полагаетесь на стечение обстоя­
тельств — никто не вызовет ваш объект в этот момент времени.
Предположим, что имеется подсистема работы с окнами, в которой интерфейс­
ные элементы вначале создаются, а затем отображаются на дисплее. Вам не разре-

Гибкость против хрупкости
141
шается задавать состояние в элементе, пока он не отобразится. В зависимости от
заданных параметров программы вы можете полагаться на то условие, что ни один
другой объект не может воспользоваться созданным элементом, пока вы не выведе­
те его на дисплей.
Но в параллельной системе это может и не выполняться. При вызове объекты
всегда обязаны находиться в допустимом состоянии, а они могут вызываться в самое
неподходящее время. Вы обязаны убедиться, что объект находится в допустимом со­
стоянии в любой момент, когда потенциально он может быть вызван. Зачастую эта
проблема проявляется с классами, которые определяют отдельные программы конст­
руктора и инициализации (где конструктор не оставляет объект в инициализирован­
ном состоянии). Используя инварианты класса, обсуждаемые в разделе "Проектиро­
вание по контракту", вы сможете избежать этой ловушки.
Четкие
интерфейсы
Размышления о параллелизме и зависимостях, упорядоченных во времени, могут
заставить вас проектировать более четкие интерфейсы. Рассмотрим библиотеч­
ную подпрограмму на языке С под названием strtok, которая расщепляет строку
на лексемы.
Конструкция strtok не является поточно-ориентированной
1, но это не самое пло­
хое, рассмотрим временную зависимость. Первый раз вы обязаны вызвать подпро­
грамму strtok с переменной, которую вы хотите проанализировать, а во всех после­
дующих вызовах использовать NULL вместо этой переменной. Не принимая во
внимание потоки, предположим, что вы собираетесь использовать strtok, для одно­
временного синтаксического анализа двух отдельных строк:
char buf1[BUFSIZ];
char buf2[BUFSIZ];
char *p, *q;
strcpy(buf1,
"это тестовая программа");
strcpy(buf2,
"которая не будет работать");
р = strtok(buf1,
" " ) ;
q = strtok(buf2,
" " ) ;
while (p && q) {
printf("%s %s\n", p, q);
p = strtok(NULL, " " ) ;
q = strtOk(NULL, " " ) ;
}
Представленная программа работать не будет: существует неявное состояние, со­
храняющееся в strtok между запросами. Вам придется использовать strtok одновре­
менно только с одним буфером.
Она использует статические данные для сохранения текущей позиции в буфере. Статиче­
ские данные не защищены от параллельного доступа, поэтому они не являются поточно-
ориентированными. Помимо этого, программа strtok затирает первый передаваемый па­
раметр, что может привести к весьма неприятным сюрпризам.

142
Г лава 5
Конструкция синтаксического анализатора строк на языке Java будет отличаться о
указанной выше. Она должна быть поточно-ориентированной и представлять непро­
тиворечивое состояние.
StringTokenizer
st1 = new S t n n g T o k e n i z e r ( " t h i s
i s a t e s t " ) ;
StringTokenizer
st2 = new S t r i n g T o k e n i z e r ( " t h i s
t e s t w i l l
work");
while (st1.hasMoreTokens() && st2.hasMoreTokens())
{
System.out.println(st1.nextToken());
System.out.println(st2.nextToken());
}
Программа StringTokenizer обладает более четким и простым в сопровождении
интерфейсом. Он на содержит в себе никаких сюрпризов и в будущем не приводит к
появлению таинственных дефектов, чего нельзя сказать о программе strtok.
Подсказка 41
При проектировании всегда есть место параллелизму
Развертывание
Как только вы спроектировали архитектуру с элементом параллельности, задача об
управлении многими параллельными службами упрощается: модель становится все­
объемлющей.
Теперь вы можете проявить гибкость относительно способа развертывания при­
ложения: по автономной модели, модели "клиент—сервер" или по я-звенной модели.
Создавая архитектуру вашей системы на основе независимых служб, вы также при­
даете динамизм процессу конфигурирования. Рассчитывая на параллелизм и разделяя
операции во времени, вы получаете все эти варианты, включая автономный вариант
развертывания, где вы можете отказаться от параллелизма.
Другой путь (попытка внести параллелизм в непараллельное приложение) пред­
ставляется намного сложнее. Если мы проектируем с учетом параллелизма, то со вре­
менем нам легче обеспечивать расширяемость и производительность, а если этот мо­
мент не настает, то мы все равно получаем выгоду от более четкого интерфейса.
Так, может быть, пора?
Другие разделы, относящиеся к данной теме:
•
Проектирование по контракту
•
Программирование в расчете на стечение обстоятельств
Вопросы для обсуждения
•
Сколько задач вы выполняете параллельно, готовясь к работе? Можете ли
выразить это с помощью диаграммы на языке UML? Может ли вы найти
иной, более быстрый способ подготовки к работе, придав своим действиям
больший параллелизм?

Гибкость против хрупкости
143
29 Всего лишь визуальное представление
Каждый смертный
все же слышит
Только то, что хочет
слышать,
Отметая
остальное.
Ля-ля-ля...
П. Саймон и А. Гарфункель, Боксер
Ранее нас учили не писать программы одним большим куском, а использовать прин­
цип "разделяй и властвуй" и разбивать программу на модули. Каждый модуль имеет
свои собственные обязанности; модуль (или класс) считается четко определенным,
если у него имеется одна четко определенная обязанность.
Но как только вы разбиваете программу на различные модули, основанные на
обязанностях, вы сталкиваетесь с новой проблемой. Каким образом объекты обща­
ются друг с другом на стадии выполнения программы? Как вы управляете логиче­
скими зависимостями между ними? Другими словами, как вы осуществляете син­
хронизацию изменений состояния (или обновление значений данных) различных
объектов? Этой работе должна быть присуща четкость и гибкость — мы не хотим,
чтобы они узнали друг о друге слишком много. Мы хотим, чтобы каждый модуль был
похож на персонажа из песни Саймона и Гарфункеля и видел только то, что хочет
увидеть.
Начнем с концепции события. Событие представляет собой специальное сообще­
ние, в котором говорится: "Только что случилось нечто интересное" (разумеется, с
точки зрения наблюдателя). Мы можем использовать события, чтобы сигнализиро­
вать об изменениях, произошедших с одним объектом, другому объекту, в которых
последний может быть заинтересован.
Подобное использование событий сводит к минимуму связывание между двумя
объектами — отправителю события не нужно обладать явной информацией о получа­
теле. На самом деле могут существовать и множественные получатели, каждый из них
сосредоточен на собственном перечне основных операций (отправитель же находится
в блаженном неведении относительно этого факта).
Однако при использовании событий необходимо соблюдать некоторую осторож­
ность. Например, в одной из ранних версий Java одна подпрограмма получила все со­
бытия, предназначенные для специфического приложения. Это не совсем подходит,
если вы хотите облегчить сопровождение или развитие программы.
Протокол "Публикация и подписка"
Почему считается дурным тоном пропускать все события через одну-единственную
программу? Потому что при этом нарушается инкапсулирование объекта — теперь
этой подпрограмме приходится получать сокровенную информацию о взаимодействии
между многими объектами. Это также способствует увеличению связывания, а мы
пытаемся его уменьшить.
Поскольку и самим объектам приходится получать инфор­
мацию об этих событиях, то, по всей вероятности, вы собираетесь нарушить принцип

144
Глава 5
DRY, принцип ортогональности и, может быть, некоторые разделы Женевской кон­
венции. Быть может, вам случалось видеть подобные программы — их доминантой
является огромный оператор case или многообразная конструкция if-then. Мы можем
сделать это изящнее.
Объекты должны иметь возможность регистрации только для приема событий,
которые им нужны, и никогда не должны посылать события, которые им не нужны.
Мы не хотим, чтобы наши объекты подверглись спаммингу! Вместо этого мы можем
воспользоваться протоколом типа "публикация и подписка", который представлен на
рис. 5.4 с помощью диаграммы
последовательностей
на языке UML'.
На блок-схеме последовательности показан поток сообщений между несколь­
кими объектами, которые располагаются по столбцам. Каждое сообщение обозна­
чено стрелкой с текстом, идущей от столбца отправителя к столбцу получателя.
Звездочка у стрелки означает, что возможна посылка более одного сообщения
данного типа.
Если нам интересны определенные события, которые генерируются объектом
Publisher (Издатель), то все, что нам нужно, — это зарегистрироваться. Объект
Publisher отслеживает все заинтересованные объекты Subscriber (Подписчик); ко­
гда объект Publisher генерирует событие, представляющее интерес, он, в свою оче­
редь, обращается к каждому объекту Subscriber, извещая их о том, что данное собы­
тие произошло.
Подписчик
Подписчик
И
з
д
а
т
е
л
ь
регистрация
извещение*
извещение*
регистрация
извещение*
отказ от подписки
извещение*
отказ от подписки
извещение*
Рис. 5.4.
Протокол "Публикация и подписка"
На эту тему существует несколько вариаций, отражающих другие стили обмена
данными. Объекты могут использовать протокол "Публикация и подписка" на одно-
Более подробная информация содержится в описании шаблона Observer в книге
[GHJV95].

Гибкость против хрупкости
145
ранговой основе (как мы видели выше); а также "программную шину", где централи­
зованный объект поддерживает базу данных "слушателей" и осуществляет соот­
ветствующую диспетчеризацию. Вы даже можете получить схему, в которой
критические события транслируются ко всем "слушателям" — как зарегистрирован­
ными, так и незарегистрированными. Одна из возможных реализаций событий в рас­
пределенной среде иллюстрируется службой сообщений CORBA, описанной во врез­
ке "Служба событий CORBA".
Вы можем использовать протокол "Публикация и подписка" для реализации очень
важного принципа проектирования: отделения самой модели от ее визуальных пред­
ставлений. Начнем с примера графического интерфейса, используя конструкцию на
языке Smalltalk, где зародилась данная концепция.
Принцип "модель-визуальное
представление-контроллер "
Предположим, что есть приложение — электронная таблица. В дополнение к числам,
расположенным в самой таблице, также имеется график, отображающий числа на
гистограмме и диалоговое окно суммы с накоплением, отображающим сумму чисел в
некотором столбце таблицы.
Служба событий CORBA
С л у ж б а событий C O R B A позволяет объектам-участникам отправлять и полу­
чать уведомления о событиях через общую шину, так называемый к а н а л с о ­
бытий. К а н а л событий принимает решение по обработке событий, а также
осуществляет резделение производителей и потребителей событий. Он р а ­
ботает в двух основных режимах: "проталкивание" и "вытягивание".
В режиме "проталкивания" поставщики событий информируют канал собы­
тий о том, что событие произошло. Затем канал автоматически
р а с п р о с т р а ­
няет это событие ко всем объектам-клиентам, которые зарегистрировались,
выражая свой интерес.
В режиме "вытягивания" клиенты периодически опрашивают к а н а л событий,
который, в свою очередь, опрашивает поставщика, который и предлагает
данные о событии, в соответствии с запросом.
Хотя с л у ж б а событий C O R B A может использоваться для р е а л и з а ц и и всех
событийных м о д е л е й , описанных в д а н н о м р а з д е л е , е е можно р а с с м а т р и ­
вать и в другом качестве. C O R B A облегчает связь между объектами, напи­
санными н а различных языках программирования и выполняющимися
на
географически р а с с р е д о т о ч е н н ы х машинах с различными
архитектурами.
Н а х о д я с ь на верхнем уровне C O R B A , с л у ж б а событий предоставляет вам
с п о с о б , отличающийся отсутствием связанности и позволяющий взаимо­
действовать с приложениями, р а з б р о с а н н ы м и
по всему миру и н а п и с а н -

146
Глава 5
ными людьми, которых вы никогда не встречали, и пишущими н а языках, о
которых вы и знать не знаете.
Очевидно, мы не хотим иметь три отдельных копии одних и тех же данных. Поэто­
му мы создаем модель — сами данные и обычные операции для их обработки. Затем
мы можем создать отдельные визуальные представления,
которые отображают дан­
ные различными способами: в виде электронной таблицы, графика или поля суммы с
накоплением. Каждое из этих визуальных представлений может располагать собст­
венными контроллерами.
Например, график может располагать неким контролле­
ром, позволяющим приближать и отдалять объекты, осуществлять панорамирование
относительно данных. Ни одно из этих средств не оказывает влияния на данные, толь­
ко на это представление.
Это и является ключевым принципом, на котором основана парадигма "модель—ви­
зуальное представление—контроллер": отделение модели от графического интерфейса,
ее представляющего, и средств управления визуальным представлением
1.
Действуя подобным образом, вы можете извлечь пользу из некоторых интересных
возможностей. Вы можете поддерживать множественные визуальные представления
для одной и той же модели данных. Вы можете использовать обычные средства про­
смотра со многими различными моделями данных. Вы даже можете поддерживать
множественные контроллеры для обеспечения нетрадиционных механизмов ввода
данных.
Подсказка 42
Отделяйте визуальные представления от моделей
Ослабляя связанность между моделью и ее визуальным представлением/контрол-
лером, вы приобретаете большую гибкость практически за бесценок. На самом деле,
эта методика является одним из важнейших способов сохранения обратимости
(см. "Обратимость").
Java: древовидное
визуальное
представление
Хорошим примером принципа "модель—визуальное представление—контроллер" яв­
ляется графический элемент в древовидной схеме Java. Элемент, который отобра­
жает обходимое дерево, активизируемое щелчком мыши, в действительности пред­
ставляет собой набор нескольких различных классов, организованных по шаблону
"модель—визуальное представление—контроллер".
Все, что вам нужно сделать для получения полнофункционального элемента де­
рева, — это обеспечить источник данных, который соответствует интерфейсу
TreeModel. Ваша программа теперь становится моделью дерева.
Представление и контроллер прочно связаны между собой, и в некоторых реализациях
МУС они являются единым целым.

Гибкость против хрупкости
147
Визуальное представление создается классами TreeCellRenderer и TreeCellEditor,
которые могут быть унаследованы и настроены для обеспечения различных цветов,
шрифтов и пиктограмм в графическом элементе. JTree действует в качестве контролле­
ра для элемента дерева и обеспечивает некоторую общую функциональную возмож­
ность просмотра.
Осуществив разделение модели и ее визуального представления, мы серьезно уп­
ростили процесс программирования. Вам не нужно беспокоиться об элементе дерева.
Вместо этого необходимо предоставить источник данных.
Предположим, к вам подходит вице-президент фирмы и высказывает пожелание,
чтобы вы быстро написали приложение, которое позволяет ему управлять структур­
ной схемой фирмы, содержащейся в унаследованной базе данных на мэйнфрейме.
Просто напишите оболочку, которая получает данные с мэйнфрейма, представляет
ее в виде TreeModel, и — "Вуаля!" — у вас имеется полнофункциональный элемент
дерева.
Теперь вы можете капризничать и начать использовать классы средств просмотра;
вы можете изменять представление узлов и использовать специальные пиктограммы,
шрифты или цвета. Когда вице-президент вернется к вам и скажет, что новые корпо­
ративные стандарты требуют использования для некоторых служащих пиктограммы
"Веселый Роджер", то вы можете внести изменения в TreeCellRenderer, не затраги­
вая любых других программ.
Отходя от графических интерфейсов
Хотя принцип "модель—визуальное представление—контроллер" обычно реализует­
ся в контексте графического интерфейса, на самом деле он является универсальной
методикой программирования. Визуальное представление — это некая интерпрета­
ция модели (возможно, подмножества), и она не обязана быть графической. Контрол­
лер в большей части является механизмом координации и не должен ассоциироваться
с устройством ввода любого типа.
•
Модель. Абстрактная модель данных, представляющая целевой объект. Мо­
дель не располагает непосредственной информацией о любых визуальных
представлениях или контроллерах.
•
Визуальное представление. Способ интерпретации модели. Оно подписы­
вается на изменения в модели и логические события, приходящие от кон­
троллера.
•
Контроллер. Способ контроля визуального представления и снабжения мо­
дели новыми данными. Он осуществляет публикацию событий для модели и
визуального представления.
Рассмотрим пример с текстовым интерфейсом.
Игра в бейсбол представляет собой уникальное явление. Где еще можно найти та­
кие пустяки, как "самый результативный матч, сыгранный во вторник под дождем,
при искусственном освещении между командами, названия которых начинаются с
гласной буквы"? Предположим, что нам поручили разработать программу для помо-

148
Глава 5
щи бесстрашным дикторам, которым по должности полагается сообщать счет, стати­
стику и прочие мелочи.
Ясно, что нам необходима информация о матче, который проходит в настоящее
время, — играющие между собой команды, условия, игрок, принимающий подачу,
счет и т.д. Эти факты образуют наши модели; они будут обновляться по мере поступ­
ления новой информации (смена подающего, выбывание игрока, начался дождь...).
Затем у нас появится ряд объектов — визуальных представлений, которые будут
использовать эти модели. Один объект должен наблюдать за набираемыми очками —
для обновления текущего счета. Другой объект может получать уведомления о новых
игроках, отбивающих мяч, и извлекать краткую справку об их статистических показа­
телях за год. Третий объект может просматривать данные и проверять, не установлен
ли мировой рекорд. Можно даже использовать средство просмотра "мелочей", кото­
рое несет ответственность за придумывание сверхъестественных и бесполезных фак­
тов, щекочущих нервы зрителей.
Результаты
матчей
Условия
Средство
сбора
результатов
Статистика
игроков,
отбивающих
мячи при подаче
Записи
Незначительные
события
Фильтрация
отображения
Генератор
внешнего
ТВ сигнала
Средство
форматиро­
вания
[Web-страницы
Телесуфлер
"подписывается на"
модель
•*
средство
просмотра
Рис.
5.5.
Комментирование бейсбольного м а т ч а . С р е д с т в а просмотра
я в л я ю т с я подписчиками модели
Но мы не хотим, чтобы несчастный диктор работал со всеми этими окнами непо­
средственно. Вместо этого мы сделаем так, чтобы каждое из окон генерировало изве­
щения об "интересных" событиях, и обеспечим возможность планирования показа с
помощью некоторого высокоуровневого объекта
1.
Тот факт, что самолет пролетает над головой, возможно, не представляет интереса, если
только это не сотый самолет за ночь.

Гибкость против хрупкости
149
Эти объекты (средства просмотра) внезапно стали моделями высокоуровневого
объекта, который сам по себе может стать моделью для различных форматирующих
средств просмотра. Одно такое средство просмотра могло бы создать сценарий для те­
лесуфлера, с которым работает диктор, второе могло бы генерировать заставки непо­
средственно на спутниковом канале, а третье могло бы осуществлять обновление web-
страниц телевизионной сети или бейсбольной команды (см. рис. 5.5).
Подобная сеть "модель—средство просмотра" является универсальной (и весьма
ценной) методикой проектирования. Каждый канал связи осуществляет отделение ис­
ходных данных от событий, их породивших; каждое новое средство просмотра есть не­
кая абстракция. И поскольку отношения представляют собой сеть (а не линейную
цепь), то мы обладаем большой гибкостью. Каждая модель может включать в себя
много средств просмотра, а одно средство просмотра может работать со многими мо­
делями.
В усовершенствованных системах, наподобие той, что описана выше, полезно
иметь окна отладки — специализированные окна, которые отображают подробности
модели. Дополнение системы средством трассировки отдельных событий также спо­
собствует существенной экономии времени.
Все такой же связанный
(после стольких лет)
Несмотря на то, что мы добились уменьшения связанности, прослушивающие про­
цессы и генераторы событий (подписчики и издатели) все равно обладают некоторой
информацией друг о друге. Например, в языке Java они обязаны прийти к соглашению
об общих определениях интерфейса и вызовах.
В следующем разделе мы рассмотрим способы дальнейшего уменьшения степени
связанности при помощи формы "публикация и подписка", в которой ни один из уча­
стников не должен знать друг о друге или обращаться напрямую друг к другу.
Другие разделы, относящиеся к данной теме:
•
Ортогональность
•
Обратимость
•
Несвязанность и закон Деметера
•
Доски объявлений
•
Все эти сочинения
Упражнения

## Открыть


блендер
Отмерить полчашки]
\ ^
белого рома
у
Засыпать смесьЧ
в блендер
J

блендер

## Добавить


2 чашки льда J

## Закрыть


блендер
I

## Перемешать


1

## Предположим, что имеется система бронирования авиабилетов, основанная


на следующем принципе формирования авиарейса:
public interface Flight {
//Return
false
if
flight
full.
public Boolean addPassenger(Passenger p);

150
Глава 5
public void addToWaitl_ist(Passenger p);
public int
g e t F l i g h t C a p a c i t y ( ) ;
public int getNumPassengers();
>
Если вы добавляете пассажира в лист ожидания авиарейса, то при появлении
вакантного места ему будет предложено воспользоваться этим рейсом авто­
матически.
Чтобы составить расписание дополнительных рейсов, требуется большая ра­
бота с отчетами, заключающаяся в выискивании рейсов, количество мест на
которые меньше или равно числу проданных билетов. Это срабатывает, но за­
нимает много времени.
Нам хотелось бы обладать большей гибкостью при обработке данных о пасса­
жирах в листе ожидания и как-то решить проблемы с этим огромным отче­
том — его формирование занимает слишком много времени. Воспользуйтесь
идеями, изложенными в данном разделе, чтобы спроектировать этот интер­
фейс по-новому.
30 Доски объявлений
На стене
написано...
Обычно вы не связываете понятие изящества с полицейскими детективами. Но рас­
смотрим пример того, как детективы используют доску объявлений для координации
действий и расследования убийства.
Предположим, что главный инспектор начинает с того, что устанавливает боль­
шую доску в комнате для заседаний. На ней он пишет один-единственный вопрос:
ШАЛТАЙ-БОЛТАЙ (ПОЛ: МУЖСКОЙ,
ЧЕЛОВЕК-ЯЙЦО):
НЕСЧАСТНЫЙ СЛУЧАЙ ИЛИ УБИЙСТВО?
Шалтай на самом деле упал, или его толкнули? Каждый детектив может внести
свою лепту в раскрытие тайны этого возможного убийства, добавляя факты, показа­
ния свидетелей, любые судебные доказательства и т.д. По мере накопления данных
детектив может заметить некую связь и также поместить на доску это наблюдение или
гипотезу. Этот процесс продолжается, передается от смены к смене, в нем участвуют
различные лица и агенты, пока дело не будет закрыто. Примерный вид доски пред­
ставлен на рис. 5.6.
Некоторые ключевые особенности подхода с применением доски объявлений:
•
Ни один из детективов не обязан знать о существовании какого-либо другого
детектива — они лишь смотрят на доску в поисках новой информации и по­
мещают на ней свои находки.
•
Детективы могут пройти подготовку по различным дисциплинам, могут обла­
дать различным уровнем образования и опыта и могут даже не работать на
той же территории. Их объединяет желание раскрыть дело и только.

Гибкость против хрупкости
151
Шалтай-Болтай (Пол: мужской, человек-яйцо):
Несчастный случай или убийство?
Фотографии
Королевская рать
Свидетели
Кусочки скорлупы
Распечатка телефонных разговоров
Карточные долги-*-^
Надписи на стенах
У жены — алиби
Детектив № 1
Детектив № 2
Детектив № 3
Рис. 5.6.
Кто-то
обнаружил
связь между карточными
долгами
Шалтая
и распечаткой
телефонных
разговоров.
Возможно,
ему
угрожали
по
телефону
•
Разные детективы могут приходить и уходить в ходе процесса, а также могут
работать в различных сменах.
м
На доску можно помещать все, что угодно. Это могут быть изображения,
тексты, вещественные доказательства и т.д.
Мы работали над несколькими проектами, которые включали в себя сбор распре­
деленных данных или данных о последовательности операций. Каждый проект, реше­
ние которого строилось на основе простой модели доски объявлений, давал нам на­
дежную метафору, с которой мы работаем: все вышеперечисленные
средства,
используемые детективами, также применимы к объектам и программным модулям.
Доска объявлений позволяет полностью отделять объекты друг от друга, обеспе­
чивая тем самым пространство, на котором потребители и производители информа­
ции могут обмениваться данными анонимно и в асинхронном режиме. Как вы могли
догадаться, это также позволяет уменьшить объем программ, которые нам приходит­
ся писать.
Реализация концепции доски объявлений
Изначально доски объявлений (на основе компьютеров) разрабатывались в системах
искусственного интеллекта для решения крупномасштабных и сложных задач — рас­
познавания речи, принятии решений на основе баз знаний и т.д.
Современные распределенные системы (подобные доскам объявлений), такие как
JavaSpaces и Т Spaces [URL 50, URL 25] основаны на модели пар "ключ—значение",
изначально пропагандировавшейся в системе Linda [CG90], где этот принцип был из­
вестен под именем "область кортежей".
При помощи этих систем можно сохранять активные объекты Java (а не только
данные) на доске объявлений и извлекать их при частичном соответствии полей (че­
рез шаблоны и трафаретные символы) или с использованием подтипов. Например,
предположим, что имеется тип Author, являющийся подтипом Person. Вы можете ис­
кать доску объявлений, содержащую объекты Person, используя шаблон Author, в ко-

152
Глава 5
тором параметру lastName присвоено значение "Shakespeare". В результате вы полу­
чите автора по имени Bill Shakespeare, а не садовника по имени Fred Shakespeare.
Основные операции в системе JavaSpaces:
Название
Функция
read
Осуществляет поиск и извлечение данных из данной области.
write
Помещает некий элемент в данную область.
take
Подобен read, но дополнительно удаляет элемент из данной области.
notify
Задает вид уведомления, которое присылается при записи объекта, совпа­
дающего с шаблоном.
Система Т Spaces поддерживает аналогичный набор операций, но с другими на­
именованиями и несколько другой семантикой. Обе системы построены подобно базе
данных; они обеспечивают элементарные операции и распределенные транзакции, га­
рантирующие целостность данных.
Поскольку мы можем хранить объекты, то можно использовать доску объявлений
для проектирования алгоритмов, основанных на потоке
объектов,
а не только на
данных. Любой может задать свидетелю вопросы, касающиеся расследования, помес­
тить протокол и переместить свидетеля на другой участок доски, где он отвечал по-
другому (если вы дадите и ему прочесть написанное на доске).
Большим преимуществом систем подобного типа является единственный непроти­
воречивый интерфейс к "доске объявлений". При построении обычного распределен­
ного приложения вы можете затратить много времени, обрабатывая уникальные вы­
зовы API для каждой распределенной транзакции и интеракции в системе. Проект
может быстро стать сущим кошмаром, если произойдет комбинаторный взрыв интер­
фейсов и интеракций.
Как организовать доску объявлений
Когда детективы ведут р а с с л е д о в а н и е крупных д е л , то д о с к а объявлений мо­
жет прийти в беспорядок и найти на ней нужные данные станет сложно. Ре­
шение состоит том, чтобы разбить доску на секции и начать каким-то о б р а ­
зом упорядочивать данные.
Различные программные системы осуществляют это разбиение
различными
способами; одни используют достаточно однородные зоны или группы интере­
сов, тогда как другие используют более иерархичную древовидную структуру.
Стиль программирования под названием "доска объявлений" снимает потреб­
ность во многих интерфейсах, позволяя создавать более элегантную и последователь­
ную систему.

Гибкость против хрупкости
153
Пример приложения
Предположим, что мы пишем программу для принятия и обработки заявлений на ипо­
течный кредит или ссуду. Законы, которые действуют в этой области, отличаются оди­
озной сложностью, и чиновникам различного уровня всегда есть что сказать по данно­
му поводу. Кредитор обязан убедить заявителя в том, что он должен раскрыть
некоторые факты и запросить определенную информацию, но не должен задавать
других конкретных вопросов и т.д.
Помимо отвратительных правовых норм, нам приходится бороться со следующими
проблемами.
•
Порядок поступления данных никак не гарантируется. Например, выполне­
ние запросов для проверки кредитоспособности или поиска названия требу­
ет существенных временных затрат, тогда как фамилия и адрес могут быть
найдены сразу.
•
Сбор данных может осуществляться разными людьми, рассеянными по раз­
ным офисам, расположенным в различных часовых поясах.
•
Некоторые данные могут собираться автоматически с помощью других сис­
тем. Эти данные могут поступать в асинхронном режиме.
•
И тем не менее, некоторые данные могут находится в зависимости от других
данных. Например, вы не сможете начать поиск автомобиля по названию,
пока не получите подтверждение права собственности или страховки.
•
Поступление новых данных может вызвать появление новых вопросов и
стратегии действий. Предположим, что проверка кредитоспособности за­
канчивается неубедительным результатом; теперь вам придется заполнить
еще пять формуляров и, возможно, сдать анализ крови.
Вы можете попробовать обрабатывать всевозможные сочетания и обстоятельст­
ва, используя систему автоматизации документооборота. Существует большое число
подобных систем, но они могут быть сложными и требовать интенсивной работы про­
граммистов. При изменении нормативов необходимо менять и документооборот: лю­
дям придется изменять процедуры и переписывать встроенную логику.
Доска объявлений в сочетании с механизмом правил, который включает в себя юри­
дические требования, представляет собой изящное решение имеющих место проблем.
Порядок поступления данных является несущественным параметром: регистрация не­
коего факта активизирует соответствующие правила. Обработка сигналов обратной свя­
зи также не представляет труда: результат действия любой совокупности правил может
поместить на доску и вызвать активизацию более подходящих в данной ситуации правил.
Подсказка 43
Используйте доски объявлений для координации
потоков работ
Мы можем использовать доску для координации неоднородных фактов и агентов,
одновременно сохраняя независимость и даже изоляцию участников друг от друга.

154
Глава 5
Вы можете добиться тех же результатов, действуя и более грубыми методами, но в
результате получите более хрупкую систему. Когда она сломается, даже "вся королев­
ская конница и вся королевская рать" не смогут заставить работать вашу программу.
Другие разделы, относящиеся к данной теме:
•
Преимущество простого текста
•
Всего лишь визуальное представление
Вопросы для обсуждения
•
Используете ли вы доски объявлений в реальности — памятные записки
дома, рядом с холодильником или большие лекционные доски на работе? Что
делает их эффективными? Всегда ли формат помещаемых сообщений явля­
ется последовательным? Имеет ли это значение?
Упражнения

## Будет ли уместным использование системы "доска объявлений" для приложе­


ний, указанных ниже? Почему? (Ответ см. в Приложении В)

## Обработка изображений. Несколько параллельных процессов захватыва­


ют фрагменты изображения, обрабатывают их и помещают обработанные
фрагменты обратно.

## Календарное планирование для групп. Имеется группа людей, находящих­


ся в разных странах, в различных часовых поясах, говорящих на разных
языках и пытающихся спланировать встречу.

## Средство мониторинга компьютерной сети. Система осуществляет сбор


статистических данных о производительности сети и отчетов о неполадках.
Вы хотели бы реализовать несколько программ-агентов, которые могли
бы использовать эту информацию для отслеживания неисправностей в
системе.

Глава 6
Пока вы пишете
программу
Житейская мудрость говорит о том, что, как только проект переходит в стадию напи­
сания текстов программ, работа становится большей частью механической, преобра­
зуя спроектированную конструкцию в набор исполняемых операторов. Мы полагаем,
что подобное отношение является единственной и самой серьезной причиной того,
что многие программы уродливы, неэффективны, плохо структурированы, сложны в
сопровождении и просто ошибочны.
|Написание программ — не механическая процедура^В противном случае CASE-
средства, с которыми специалисты связывали свои надежды в начале 80-х годов про­
шлого века, уже давно заменили бы программистов. Существуют решения, которые
необходимо принимать ежеминутно, решения, требующие тщательного обдумывания
и оценки, дающие написанной программе право на долгую, праведную и продуктив­
ную жизнь.
Разработчики, которые не проявляют активности при обдумывании своей про­
граммы, программируют в расчете на стечение обстоятельств — программа, может
быть и работает, но этому нет определенного объяснения. В разделе "Программиро­
вание в расчете на стечение обстоятельств", мы призываем к большему участию в
процессе написания программы.
Несмотря на то, что большинство составляемых нами программ выполняются бы­
стро, иногда мы разрабатываем алгоритмы, которые способны "посадить" даже са­
мые быстрые процессоры. В разделе "Скорость алгоритма" обсуждаются методы
оценки скорости работы программы и приводятся некоторые подсказки, предупреж­
дающие возникновение потенциальных проблем.
Прагматики относятся критически ко всем программам, включая собственные.
Мы всегда находим резервы улучшения в наших программах и конструкциях. В разде­
ле "Реорганизация" рассматриваются методики, помогающие исправлять сущест­
вующий текст программы, даже если проект находится в самом разгаре.
Всякий раз при написании текста программы необходимо помнить следующее:
придет время, когда вам придется ее тестировать. Сделайте так, чтобы тестирование

156
Глава 6
не оказалось сложной процедурой, и вероятность того, что программа пройдет тести­
рование, увеличится. Эту идею мы развиваем в разделе "Программа, которую легко
тестировать".
И наконец, в разделе "Злые волшебники" говорится о том, что необходимо быть
осторожным с инструментальными средствами, генерирующими миллионы строк от
вашего имени, если вы не понимаете сути работы этих средств.
Многие из нас в значительной степени управляют автомобилем "на автопило­
те" — мы не даем явных указаний ноге, чтобы она нажала на педаль, или руке, что­
бы она повернула руль, а мысленно говорим себе: "снизить скорость и повернуть
направо". Но дисциплинированные водители постоянно контролируют ситуацию,
отыскивают потенциальные проблемы и оказываются в нужном положении, если
происходит непредвиденное. Это применимо и к написанию программ — возможно,
об этом говорилось уже много раз, но хладнокровие всегда позволит вам предотвра­
тить катастрофу.
31 Программирование в расчете
на стечение обстоятельств
Случалось ли вам когда-нибудь смотреть старые черно-белые фильмы о войне? Уста­
лый солдат осторожно выбирается из зарослей кустарника. Впереди него свободное
пространство, и солдат задается вопросом: есть ли впереди мины или можно безбояз­
ненно идти дальше? Ничто не говорит о том, что впереди минное поле, — нет ни зна­
ков, ни колючей проволоки, ни воронок. Солдат пробует штыком грунт впереди себя и
вздрагивает в ожидании взрыва. Но ничего не происходит. Какое-то время он продол­
жает осторожно продвигаться по полю, прощупывая грунт. В конце концов, убедив­
шись, что проход безопасен, он распрямляется и начинает гордо маршировать впе­
ред ... навстречу смерти.
Первые поиски мин, проведенные солдатом, были безрезультатны, но ему просто
повезло. Он пришел к ложному заключению, которое закончилось катастрофой.
Программисты также работают на заминированной территории. Существуют сот­
ни ловушек, подстерегающих нас ежедневно. Помня об истории с солдатом из филь­
ма, нам стоит опасаться ложных заключений. Необходимо избегать программирова­
ния в расчете на стечение обстоятельств, полагаясь на удачу и случайные успехи, и
сделать выбор в пользу преднамеренного программирования.
Как программировать в расчете на стечение
обстоятельств
Предположим, Фреду дано задание написать программу. Фред составляет некоторую
программу, пробует ее запустить, и она вроде работает. Фред пишет еще один фраг­
мент, пробует его запустить, и снова все работает. В такой обстановке проходит еще
несколько недель, но внезапно программа прекращает работать, и, потратив несколь­
ко часов на устранение дефекта, Фред все еще не знает, в чем причина. Фред может
потратить много времени, копаясь с этим фрагментом, без перспективы на восста-

Пока вы пишете программу
157
новление работы программы. И что бы он ни делал, кажется, что она никогда не будет
работать правильно.
Фред не знает, почему программа сбоит, потому не знает, почему она
работала
вначале.
Она лишь казалась работающей в условиях ограниченного "тестирования",
которое проводил Фред, но это было только стечением обстоятельств. Находясь в
плену ложной уверенности, Фред впал в забытье. Большинству интеллектуалов зна­
ком этот образ Фреда, но мы знаем его лучше. Мы ведь не полагаемся на стечение об­
стоятельств, не так ли?
Впрочем, иногда полагаемся. Порой легко спутать счастливый случай с целена­
правленным планированием. Рассмотрим несколько примеров.
Случайная
реализация
Случайная реализация — это то, что происходит просто потому, что программа напи­
сана именно так, как она написана. Вы перестаете полагаться на недокументирован­
ную ошибку или граничные условия.
Предположим, что вы вызываете подпрограмму с неверными данными. Подпро­
грамма откликается определенным образом, и ваша программа основывается на этом
отклике. Но у автора даже и в мыслях не было, что программа будет работать подоб­
ным образом —-это даже не рассматривалось. Если подпрограмма "исправляется",
то основная программа может нарушиться. В самом крайнем случае, вызываемая
подпрограмма даже не предназначена для того, чего вы от нее ждете, но вроде бы она
работает нормально. Вызов каких-либо элементов неправильным образом или в не­
верном контексте, является связанной проблемой.
p a i n t ( g ) ;
i n v a l i d a t e ( ) ;
v a l i d a t e ( ) ;
r e v a l i d a t e ( ) ;
r e p a i n t ( ) ;
paintlmmediately(r);
Похоже, что Фред предпринимает отчаянные попытки вывести что-то на экран.
Но эти подпрограммы не предназначены для того, чтобы к ним обращались таким
способом; хотя они кажутся работающими, в действительности это лишь стечение об­
стоятельств.
Чтобы не получить новых ударов, когда компонент все-таки нарисован, Фред не
пытается вернуться назад и устранить поддельные запросы. "Сейчас она работает, ос­
тавим все как есть..."
Подобные размышления могут ввести вас в заблуждение. Зачем рисковать, пор­
тить то, что работает? Можно так думать по нескольким причинам:
•
Программа действительно может не работать, она может лишь казаться ра­
ботающей.
•
Граничное условие, на которое вы полагаетесь, может быть лишь частным
случаем. В различных обстоятельствах (например, при ином экранном раз­
решении) программа может вести себя по-разному.

158
Глава 6
•
Недокументированное поведение может измениться с выпуском новой вер­
сии библиотеки.
•
Дополнительные и необязательные вызовы замедляют работу вашей про­
граммы.
•
Дополнительные вызовы также увеличивают риск привнесения новых де­
фектов, связанных с этим вызовами.
При написании программы, вызываемой другими разработчиками, полезными мо­
гут оказаться базовые принципы четкой модуляризации и скрытия реализации за не­
сложными, четко документированными интерфейсами. Четко определенный контракт
(см. "Проектирование по контракту") может устранить недоразумения.
Для вызываемых вами подпрограмм полагайтесь только на документированное
поведение. Если по какой то причине вы не можете сделать этого, то четко документи­
руйте ваше предположение.
Случайный
контекст
Вы также можете встретиться со "случайным контекстом". Предположим, вы пишете
сервисный модуль. Поскольку в данное время вы пишете программу для графической
среды, должен ли модуль полагаться на существующий графический интерфейс? По­
лагаетесь ли вы на англоязычных пользователей? На грамотных пользователей? По­
лагаетесь ли вы еще на какой-то контекст, наличие которого не гарантируется?
Неявные
предположения
Совпадения могут вводить в заблуждение на всех уровнях — от генерации требований
до тестирования. Тестирование особенно чревато наличием ложных причинных связей
и случайным совпадением результатов. Легко предположить, что вызывает Y, но, как
сказано в разделе "Отладка", не предполагайте это, но доказывайте.
На всех уровнях люди работают, держа многие предположения в голове, но эти
предположения редко документируются и часто вызывают противоречия между раз­
работчиками. Предположения, которые не основаны на известных фактах, способны
отравить любые проекты.
Подсказка 44
Не пишите программы в расчете на стечение обстоятельств
Преднамеренное
программирование
Мы хотели бы тратить меньше времени на придание нашим программам компактно­
сти, перехватывая и устраняя ошибки, возникающие в ходе разработки как можно
раньше, а для начала допускать меньшее число ошибок. Этот принцип приносит поль­
зу, если мы способны программировать преднамеренно:
• ^Всегда отдавайте себе отчет в том, что вы делаете! Программист Фред посте­
пенное терял контроль над происходящим, пока не сварился сам, подобно
лягушке из раздела "Суп из камней и сварившиеся лягушки".

Пока вы пишете программу
159
• jj-Ie пишите программ вслепую^Попытка написать приложение, которое вы
до конца не понимаете, или использовать технологию, с которой вы не знако­
мы, становится поводом к тому, что вы будете введены в заблуждение слу­
чайными совпадениями.
• ^Действуйте исходя из плана, неважно, где он составлен^ — у вас в голове, на
кухонной салфетке или на огромной "простыне", полученной с помощью
CASE-средств.
•
Полагайтесь только на надежные предметы. Не вводите себя в зависимость
от случаев или предположений. Если вы не можете понять, в чем состоит
различие при специфических обстоятельствах, предполагайте худшее.
•
Документируйте ваши предположения. Раздел "Проектирование по кон­
тракту" поможет вам прояснить ваши предположения в вашей же голове, а
также передать их другим людям.
•
Тестируйте не только вашу программу, но и ваши предположения. Не гадай­
те, попробуйте осуществить это на деле. Напишите программу контроля для
проверки ваших предположений (см. "Программирование утверждений").
Если ваше предположение верно, то вы улучшили документирование вашей
программы. Если вы обнаружили, что предположение ошибочно, тогда счи­
тайте, что вам повезло.
• (Определите приоритеты в вашей работе!, Уделите время аспектам, представ­
ляющим важность; скорее всего, они окажутся непростыми. При отсутствии
надлежащих фундаментальных принципов или инфраструктуры все блестя­
щие "бантики" будут просто неуместны.
• "Не будьте рабами прошлого; Не позволяйте существующей программе
диктовать свою волю той программе, за которой будущее. Если програм­
ма устаревает, она может быть полностью заменена. И даже в пределах
одной программы не позволяйте уже сделанному сдерживать то, что идет
за ним, — будьте готовы к реорганизации (см. "Реорганизация"). Это ре­
шение может повлиять на график выполнения проекта. Мы полагаем, что
это воздействие будет меньше той цены, которую придется платить за от­
сутствие изменений
1.
Поэтому, если в следующий раз что-то начинает работать, но вы не знаете, почему
это происходит, убедитесь, что это не является стечением обстоятельств.
Другие разделы, относящиеся к данной теме:
•
Суп из камней и сварившиеся лягушки
•
Отладка
1
В этом случае дело может зайти слишком далеко. Один разработчик переписывал абсо­
лютно все исходные тексты, которые ему передавались, так как пользовался собственными
соглашениями об именовании.

160
Глава 6
•
Проектирование по контракту
•
Программирование утверждений
•
Временное связывание
•
Реорганизация
•
Все эти сочинения
Упражнения

## Найдите совпадения в представленном фрагменте программы на языке С.


Предположим, что этот фрагмент находится глубоко в недрах библиотечной
подпрограммы. (Ответ см. в Приложении В.)
f p r i n t f ( s t d e r r ,
"Error,
continue?");
g e t s ( b u f ) ;

## Этот фрагмент программы на языке С мог работать в течение какого-то време­


ни на некоторых машинах. Затем он переставал работать. В чем ошибка? (От­
вет см. в Приложении В.)
/*
Truncate
string
to its
last
maxlen
chars
*/
void s t r i n g _ t a i l ( c h a r * s t r i n g ,
int maxlen) {
int len = s t r l e n ( s t r i n g ) ;
i f
(len > maxlen) {
s t r c p y ( s t r i n g ,
s t r i n g + ( l e n - maxlen));
}
}

## Эта программа входит в состав универсального пакета трассировки Java.


Функция записывает строки в файл журнала. Она проходит модульное тести­
рование, но дает сбой при попытке ее применения одним из разработчиков
программ для сети Интернет. На какое стечение обстоятельств полагается эта
программа? (Ответ см. в Приложении В.)
public s t a t i c void debug(String s ) throws IOException {
F i l e W r i t e r fw = new F i l e W r i t e r ( " d e b u g . l o g " ) ;
f w . w r i t e ( s ) ;
f w . f l u s h ( ) ;
f w . c l o s e ( ) ;
}
32 Скорость алгоритма
В разделе "Оценка" говорилось об оценке того, сколько времени потребуется, чтобы
пройти несколько городских кварталов, и сколько времени потребуется для заверше­
ния проекта. Однако существует и другой вид оценок, который прагматики применя­
ют практически ежедневно: оценка ресурсов, которые используются алгоритмами —
времени, работы процессора, объема памяти и т.д.

Пока вы пишете программу
161
Зачастую этот вид оценки является критичным. Если вы можете сделать что-либо
двумя способами, то какой из них стоит выбрать? Если вам известно время выполне­
ния программы при наличии 1000 записей, то как оно изменится при наличии
1 ООО ООО записей? Какая часть программы нуждается в оптимизации?
Оказывается, что во многих случаях на подобные вопросы можно ответить, поль­
зуясь здравым смыслом, некоторым анализом, и методикой записи приближений, ко­
торая называется "О-большое".
Что подразумевается под оценкой алгоритмов?
Большинство нетривиальных алгоритмов обрабатывают некий вид переменных вход­
ных массивов, они выполняют сортировку п строк, обращение матрицы размером
m х п или расшифровку сообщения с я-битовым ключом. Обычно объем входных
данных будет оказывать влияние на алгоритм: чем больше этот объем, тем больше
время выполнения алгоритма или объем используемой памяти.
Если бы эта зависимость всегда была линейной (т.е. время возрастало бы прямо
пропорционально значению я), то этот раздел можно было бы и пропустить. Однако
наиболее важные алгоритмы не являются линейными. Хорошая новость: многие ал­
горитмы являются сублинейными. Например, в алгоритме двоичного поиска при на­
хождении соответствия вовсе не обязательно рассматривать подряд всех кандидатов.
А теперь плохая новость: другие алгоритмы отличаются существенно худшими линей­
ными свойствами; время их выполнения или требования к объему памяти возрастают
намного быстрее, чем значение п. Если для обработки десяти элементов алгоритму
требуется минута, то для обработки ста элементов потребуется целая жизнь.
При написании любых программ, содержащих циклы или рекурсивные вызовы,
мы подсознательно проверяем требования, предъявляемые ко времени выполнения и
объему памяти. Это редко является формальным процессом, скорее, оперативным
подтверждением наличия здравого смысла в том, что мы делаем в определенных об­
стоятельствах. Но иногда мы оказываемся в ситуации, когда нам приходится прово­
дить более детальный анализ. В этом случае весьма полезной оказывается система
обозначений 0() ("О-большое").
Система обозначений ОО
Система 0() представляет собой математический способ обозначения приближений.
Если мы указываем, что некая программа осуществляет сортировку п записей за вре­
мя 0(п
2),
то это просто означает, что максимальное время выполнения программы
будет изменяться пропорционально п

## При удвоении числа записей время возрастет


примерно в четыре раза. 0() можно рассматривать как порядок величины. Система
обозначений 0() определяет верхнюю границу величины параметра, который мы из­
меряем (время, объем памяти и т.д.). Если мы говорим, что некая функция занимает
время 0(п
2),
то под этим понимается, что верхняя граница интервала времени, необ­
ходимого для ее выполнения, возрастает не быстрее п

## Иногда мы встречаемся с до­


вольно сложными функциями 0(), и поскольку именно член высшего порядка будет
определять значение с ростом п, то обычно все члены низшего порядка удаляются,

162
Глава 6
чтобы не мешать постоянным коэффициентом умножения. 0\
1- Зп означает то же
самое, что и С\
)
которое, в свою очередь, является эквивалентом 0(п'
2). В этом и
состоит недостаток системы обозначений 0() — один алгоритм 0(п'
2) может быть бы­
стрее другого алгоритма 0(п
2) в тысячу раз, но из обозначений вы этого не поймете.
На рис. 6.1 показано несколько общих обозначений 0(), с которым вы можете
встретиться, и график, на котором сравнивается время выполнения алгоритмов в ка­
ждой категории. Из него ясно, что все начинает быстро выходить из-под контроля,
как только мы переходим через
0(п
2).
величинам —*
Некоторый универсальные обозначения О-большое
0(1)
Постоянная зависимость (обращение к элементу массива,
простые операторы)
0(1д(л))
Логарифмическая зависимость (двоичный поиск)
[1д(п) — краткое обозначение 1одг(п)]
0(п)
Линейная зависимость (последовательный поиск)
0(п \д(п)) Эта зависимость слабее линейной, но не намного (среднее
время быстрой сортировки, сортировки методом пузырька)
0(п
2)
Квадратичная зависимость (выборочная сортировка и сортировка
включением)
0/ лз\
Кубическая зависимость (перемножение двух матриц
размером
mxn)
0(С")
Экспоненциальная зависимость (задача о коммивояжере,
разбиение набора)
Рис. 6.1.
Время выполнения
различных
алгоритмов

Пока вы пишете программу
163
Предположим, что у вас имеется программа, которая обрабатывает 100 записей за
1 сек. Сколько времени ей потребуется для обработки 1000 записей? Если ваша про­
грамма является 0( 1), то это время остается равным 1 сек. Она является 0(lg(«)), то
для обработки потребуется около 3 сек. При О(п) время обработки линейно возрас­
тает до 10 сек., а при 0(n\g (п)) составит примерно 33 сек. Если вам не повезло и
ваша программа является 0(п
2),
то можете отдохнуть в течение 100 сек., пока она не
сделает свое дело. Ну а в том случае, если вы используете экспоненциальный алго­
ритм 0(2"), то можете заварить чашечку кофе — программа завершит свою работу
примерно через 10
2 6 3 лет. В общем, хотелось бы знать, как происходит конец света.
Система обозначений 0() не применяется только к временным параметрам; ее
можно использовать для представления других ресурсов, требуемых неким алгорит­
мом. Например, часто она является полезной при моделировании расхода памяти (см.
упражнение 35).
Оценка с точки зрения здравого смысла
Можно оценить порядок многих базовых алгоритмов с точки зрения здравого смысла.
•
Простые циклы. Если простой цикл выполняется от 1 до л, то алгоритм, ско­
рее всего, является О(п) — время находится в линейной зависимости от п.
Примерами этого являются исчерпывающий поиск, поиск максимального
элемента в массиве и генерация контрольной суммы.
•
Вложенные циклы. Если вы помещаете один цикл в другой, то ваш алго­
ритм становится О(тхп),
где тип
— пределы этих двух циклов. Обычно
это свойственно простым алгоритмам сортировки, типа пузырьковой сор­
тировки, где внешний цикл поочередно просматривает каждый элемент
массива, а внутренний цикл определяет местонахождение этого элемента в
результирующем массиве. Подобные алгоритмы чаще всего сортировки
стремятся к
0(п
2).
•
Алгоритм двоичного поиска. Если ваш алгоритм делит пополам набор эле­
ментов, который он рассматривает всякий раз в цикле, то скорее всего он ло­
гарифмический 0(\g(n))
(см. упражнение 37). Двоичный поиск в упорядо­
ченном списке, обход двоичного дерева и поиск первого установленного бита
в машинном слове могут быть
0(\g(n)).
•
Разделяй и властвуй. Алгоритмы, которые разбивают входные данные на
разделы, работают независимо с двумя половинами, и затем комбинируют
конечный результат, могут представлять собой 0(n\g(n)).
Классический
примером является алгоритм быстрой сортировки, который делит входной
массив пополам и затем проводит рекурсивную сортировку в каждой из по­
ловин. Хотя технически он является 0(п
2),
поскольку его поведение ухудша­
ется, когда он обрабатывает упорядоченные данные, но среднее время быст­
рой сортировки составляет
0(n\g{n)).
•
Комбинаторика. При использовании алгоритмов в решении любых задач,
связанных с перестановкой, время их выполнения может выйти из-под кон-

164
Глава 6
троля. Это происходит потому, что задачи о перестановке включают вычис­
ления факториалов (существует 5! = 5 x 4 x 3 x 2 x 1 = 120 перестановок
цифр от 1 до 5). Возьмем за основу время выполнения комбинаторного ал­
горитма для пяти элементов; для шести элементов времени потребуется в
шесть раз больше, а для семи — в 42. Примерами этого являются алгорит­
мы решения многих известных сложных задач — о коммивояжере, опти­
мальной упаковке предметов в контейнер, о разделении набора чисел та­
ким образом, что сумма каждого отдельного набора одинакова и т.д. Во
многих случаях для сокращения времени выполнения алгоритмов данного
типа в определенных прикладных областях используются эвристические
подходы.
Скорость алгоритма на практике
Маловероятно, что в своей профессиональной карьере вам придется тратить много
времени на написание программ сортировки. Эти программы, входящие в стандарт­
ные библиотеки, наверняка без особых усилий превзойдут написанное вами. Но ос­
новные типы алгоритмов, описанные выше, будут время от времени всплывать на по­
верхность. Во всех случаях, когда вы пишете простой цикл, то знайте, что имеете дело
с алгоритмом О(п). Если же этот цикл содержит внутренний цикл, то речь идет о
0 ( т х п). Вы обязаны задаться вопросом: а насколько велики эти значения? Если эти
значения ограничены сверху, то вы можете представить, сколько времени потребует­
ся на выполнение программы. Если эти цифры зависят от внешних факторов (наподо­
бие количества записей в запускаемом на ночь пакете программ или количества фа­
милий в списке персоналий), то стоит остановиться и изучить влияние больших числе
на время выполнения программы или объемы необходимой памяти.
Подсказка 45
Оцените порядок ваших алгоритмов
Существуют несколько подходов, которыми вы можете воспользоваться при ре­
шении потенциально возникающих проблем. Если у вас есть алгоритм, который явля­
ется 0(п
2),
попробуйте действовать по принципу "разделяй и властвуй", что может
уменьшить время выполнения до
0(n\g(n)).
Если вы не уверены в том, что ваша программа будет выполняться в течение опре­
деленного времени, или в том, что она затребует определенный объем памяти, попы­
тайтесь запустить ее, варьируя количество обрабатываемых записей или другие пара­
метры, способные оказать воздействие на время выполнения программы. Затем
постройте график на основе полученных результатов и получите представление о
форме кривой. Изгибается ли она кверху, представляет собой прямую линию или
сглаживается с увеличением размера входного массива данных? Представление об
этом можно получить, исходя из трех или четырех точек.
Стоит рассмотреть и то, что происходит в самой программе. При малых значениях
п простой цикл 0(п
2)
может работать намного лучше, чем сложный 0{n\g(n)),
осо­
бенно если последний содержит ресурсоемкий внутренний цикл.

Пока вы пишете программу
165
Говоря о теории, не стоит забывать и о наличии практических соображений. При
работе с небольшими массивами входных данных может показаться, что время вы­
полнения возрастает линейно. Но если программа обрабатывает миллионы записей,
то внезапно время выполнения резко увеличивается, по мере того, как система начи­
нает "буксовать". При проведении тестирования программы сортировки со случайны­
ми входными ключами вы можете удивиться ее работе с упорядоченным входным мас­
сивом. Прагматики стараются обеспечивать как теоретическую, так и практическую
базу. После всех проведенных оценок единственной определяемой временной харак­
теристикой является скорость выполнения вашей программы в реальных условиях
эксплуатации и с реальными данными

## Из этого вытекает следующая подсказка.


Подсказка 46
Проверяйте ваши оценки
Если точное определение времени представляет сложность, воспользуйтесь про­
граммами оптимизации, чтобы подсчитать, сколько раз выполнялся ваш алгоритм, и
постройте зависимость этого количества от размера входного массива данных.
Лучшее — враг хорошего
При выборе подходящего алгоритма также необходимо придерживаться прагмати­
ческого подхода — самые быстрые алгоритмы не обязательно являются наилучши­
ми для конкретного случая. При небольшом входном массиве "прямолинейная" сор­
тировка со вставкой будет работать так же хорошо, как и алгоритм быстрой
сортировки, и потребует меньше времени на написание и отладку. Необходимо со­
блюдать осторожность, если выбранный вами алгоритм отличается высокими затра­
тами на установку. При работе с небольшими массивами эта дорогостоящая уста­
новка может свести на нет преимущество в скорости выполнения и сделать
алгоритм нерентабельным.
Кроме того, необходимо опасаться преждевременной оптимизации. Перед тем как
потратить ваше драгоценное время на улучшение алгоритма, всегда есть смысл убе­
диться, что он действительно является "узким местом".
Другие разделы, относящиеся к данной теме:
•
Оценка
Вопросы для обсуждения
•
Каждый разработчик обязан обладать чутьем на проектирование и анализ
алгоритмов. По данному предмету Роберт Седжвик написал серию доступ­
н а деле авторам не хватило реальной памяти для выполнения поразрядной сортировки свы­
ше 7 млн чисел на компьютере с процессором Pentium и 64Мбайт оперативной памяти во
время тестирования алгоритмов, используемых в качестве упражнения к данному разделу.
После этого была задействована область подкачки, и время сортировки резко сократилось.

166
Глава 6
ных книг ([Sed83, SF96, Sed92] и др.). Мы рекомендуем пополнить вашу
библиотеку одной из этих книг и обязательно прочесть ее.
Те, кто интересуется предметом более глубоко (по сравнением с его подачей
в книге Седжвика), могут прочесть каноническую серию книг Дональда Кну­
та "Искусство программирования", в которых анализируются разнообраз­
ные алгоритмы [Knu97a, Knu97b, Knu98].
В упражнении 34 рассматривается сортировка массивов, состоящих из чи­
сел типа "длинное целое". Как скажется на сортировке усложнение ключей,
а также издержки на их сравнении? Оказывает ли структура ключей воияние
на эффективность работы алгоритмов сортировки, словом, является ли са­
мый быстрый алгоритм сортировки таковым во всех случаях?
Упражнения

## Авторы книги составили набор простых программ сортировки, которые мож­


но загрузить с их Интернет-сайта (www.pragmaticprogrammer.com). Прого­
ните эти программы на разных компьютерах, имеющихся в вашем распоря­
жении. Соответствуют ли полученные вами данные ожидаемым кривым?
Какие заключения можно сделать об относительных скоростях ваших ма­
шин? Каково влияние различных установочных параметров компиляторов?
Является ли поразрядная сортировка действительно линейной? (Ответ см.
в Приложении В.)

## Приведенная ниже подпрограмма выводит на печать содержимое двоичного


дерева. Предполагая, что дерево сбалансировано, какой (примерно) объем
стека будет использоваться подпрограммой для вывода на печать дерева, со­
стоящего из 1 ООО ООО элементов? (Предполагается, что вызовы подпрограм­
мы не оказывают существенной нагрузки на стек). (Ответ см. в Приложе­
нии В.)
void printTree(const
Node *node) {
char buffer[1000];
if
(node) {
printTree(node->left);
getNodeAsString(node,
b u f f e r ) ;
p u t s ( b u f f e r ) ;
printTree(node->right);
}
>

## Существует ли способ уменьшить потребность подпрограммы, описанной в


упражнении 35, в ресурсах стека (помимо уменьшения размера буфера)? (От­
вет см. в Приложении В.)

## В разделе "Оценка с точки зрения здравого смысла» утверждается, что алго­


ритм двоичного поиска является 0( lg( п)). Можно ли это доказать? (Ответ см. в
Приложении В.)

Пока вы пишете программу
167
33 Реорганизация
Как изменилось
и увяло все, что окружает
меня...
Г.Ф. Лайт, Пребудь со мной
По мере развития программы возникает необходимость в переосмыслении ранее при­
нятых решений и переработки отдельных фрагментов текста программы. Это процесс
абсолютно естественен. Программа нуждается в эволюции, она не является статиче­
ским объектом.
К сожалению, наиболее распространенной метафорой разработки программного
обеспечения является строительства здания (Б. Мейер [Меу97Ь] использует термин
"Software Construction" — букв.: строительство программ. — Прим. пер.). Но ис­
пользование термина "строительство" в качестве определяющей метафоры подразу­
мевает наличие следующих стадий:
1.
Архитектор готовит чертежи на кальке.
2.
Фирмы-подрядчики роют котлован под фундамент, возводят надземную часть,
проводят электричество, монтируют водопровод и канализацию и осуществля­
ют отделочные работы.
3.
Арендаторы въезжают в дом и с этого времени живут-поживают, лишь ино­
гда обращаясь в домоуправление с просьбой устранить возникшие неис­
правности.
Программное обеспечение работает несколько по-иному. В отличие от строитель­
ства, написание программ ближе к садоводству,
оно ближе к живой природе, чем к
бетонным конструкциям. Вы высаживаете в саду множество растений согласно пер­
воначальному плану и условиям. Некоторые растения разрастаются, другим же угото­
вана компостная яма. Вы можете пересаживать растения друг относительно друга,
чтобы извлечь пользу из взаимодействия света и тени, ветра и дождя. Переросшие
растения разрубают или обрезают, растения определенного цвета пересаживают на
другие участки, где они становятся более приятными глазу с точки зрения эстетики.
Вы выпалываете сорняки и подкармливаете растения, которые нуждаются в дополни­
тельном питании. Вы постоянно следите за состоянием сада и при необходимости вно­
сите изменения (в почву, растения, общий план).
Для бизнесменов более понятной является метафора строительства здания: она
более научна по сравнению с садоводством, она воспроизводима, в управлении имеет­
ся жесткая иерархия подотчетности и т.д. Но мы не занимаемся строительством небо­
скребов — мы можем выйти за рамки физики и реального мира.
Метафора садоводства намного ближе к реальности разработки программного
обеспечения. Возможно, что некая программа переросла себя или пытается осущест­
вить слишком много — ее необходимо разбить на две. То, что не получается в соот­
ветствии с планом, подлежит прополке или обрезке.
Переписывание, переработка и перепланирование текста программы описывается
общим термином "реорганизация".

168
Глава 6
Если вы встречаете на своем пути камень преткновения, поскольку текст програм­
мы никуда не годится, замечаете, что два объекта стали несовместимы друг с другом,
или же нечто другое, что задевает вас своей "неправильностью", не стесняйтесь
вносить изменения. Другого времени, кроме настоящего, не существует. Программу
можно считать пригодной для реоганизации при наличии одного из указанных ниже
условий:
•
Дублирование. Вы обнаружили нарушение принципа DRY (см. "Пороки
дублирования").
•
Неортогональность конструкции. Вы обнаружили некий фрагмент про­
граммы или конструкцию, которой можно придать большую ортогональ­
ность (см. "Ортогональность").
•
Устаревшие знания. Все изменяется, требования варьируются, и ваши зна­
ния о проблеме расширяются. Программа должна соответствовать новому
уровню знаний.
•
Рабочие характеристики. Для улучшения характеристик программы вам
необходимо перенести функциональную возможность из одной части систе­
мы в другую.
Реорганизация вашей программы, т.е. перемещение функциональной возможно­
сти и изменение ранее принятых решений — это упражнение в обезболивании. Ска­
жем сразу — изменение исходного текста программы может быть весьма болезнен­
ной процедурой: она уже почти работала, а теперь ее разрывают в клочья. Многие
разработчики крайне неохотно соглашаются "вспарывать" программу лишь на том
основании, что она работает не совсем правильно.
Осложнения в реальном мире
Итак, вы идете к вашему шефу или заказчику и говорите: "Эта программа работает,
но для ее реорганизации мне нужна еще неделя".
Они скажут вам... впрочем, это непечатное выражение.
На жесткие временные рамки часто ссылаются, оправдывая отсутствие реоргани­
зации. Но это оправдание не должно становиться нормой: если вы не сможете провес­
ти реорганизацию сейчас, то позже (когда придется принимать во внимание большее
число зависимостей) на устранение возникшей проблемы потребуется намного боль­
ше времени. А будет ли у вас это время? У нас — точно не будет.
Попробуйте объяснить этот принцип вашему шефу, пользуясь аналогией с меди­
циной: рассматривайте программу, нуждающуюся в реорганизации, как "опухоль".
Чтобы удалить ее, требуется хирургическое вмешательство. Вы можете начать сразу
и извлечь ее, пока она небольшая. Но если вы будете ждать, пока она вырастет и рас­
пространится, то удаление ее станет более дорогой и опасной процедурой. Подождите
еще, и вы можете потерять пациента окончательно.
Когда осуществлять реорганизацию?

Пока вы пишете программу
169
Автоматическая реорганизация
Исторически сложилось так, что пользователи Smalltalk всегда пользовались
с р е д с т в о м просмотра к л а с с о в как неотъемлемой частью интегрированной
с р е д ы разработчика. В отличие от web-браузеров, с р е д с т в а просмотра
к л а с с о в позволяют пользователям перемещаться по иерархиям и методам
к л а с с а и проверять их.
Обычно с р е д с т в а просмотра к л а с с о в позволяют редактировать текст про­
граммы, создавать новые методы, к л а с с ы и т.д. С л е д у ю щ е й вариацией на
эту тему является б р а у з е р реорганизации.
Этот б р а у з е р может в полуавтоматическом режиме проводить операции,
обычные при реорганизации: разбивать длинную подпрограмму на несколь­
ко б о л е е коротких, автоматически перенося изменения на имена методов и
Подсказка 47
Реорганизация должна проводиться часто и как можно
раньше
Следите за всем, что требует реорганизации. Если вы не можете провести реорга­
низацию чего-либо прямо сейчас, удостоверьтесь, что она стоит в вашем плане. Убе­
дитесь, что пользователи программы, над которой производится реорганизация, зна­
ют о запланированной процедуре и о том, как она может повлиять на их работу.
Как производится реорганизация?
Реорганизация появилась в среде программистов, работающих с языком Smalltalk, и
начала, вкупе с другими модными поветриями (такими, как шаблоны конструкций),
завоевывать все более широкую аудиторию. Но это все еще малоизвестная тема, по
ней опубликовано не так много работ. Первая большая монография о реорганизации
([FBB+99], а также [URL 47]) вышли одновременно с данной книгой.
Суть реоганизации заключается в перепланировке. Все спроектированное вами
или другими членами вашей команды может быть переделано в свете новых фактов,
более глубокого понимания, изменения требований и т.д. Но если вы предадите заб­
вению огромные фрагменты программы, то окажетесь в худшем положении, чем в на­
чале работы по реорганизации.
Ясно, что реорганизация представляет собой род деятельности, которая должна
осуществляться медленно, преднамеренно и осторожно. Мартин Фаулер предлагает
ряд простых подсказок — как провести реорганизацию, чтобы это не принесло боль­
ше вреда, чем пользы (см. врезку на с. 30 в книге [FS97]):
1.
Не пытайтесь одновременно производить реорганизацию и добавлять функ­
циональные возможности.
2.
Перед тем как начинать реорганизацию, убедитесь, что тестирование прошло
успешно. Проводите тестирование как можно чаще. В этом случае вы сразу
увидите нарушение, которое было вызвано внесенными изменениями.

170
Глава 6
переменных, а также осуществлять операцию "буксировки и перетаскива­
ния", что помогает в перемещении текста программы и т.д.
Во время написания книги этой технологии е щ е предстояло выйти з а преде­
лы мира Smalltalk, но с к о р е е всего она начнет меняться с той же скоростью,
что и язык J a v a — быстро. В то ж е время исторический б р а у з е р реорганиза­
ции Smalltalk можно отыскать в Интернете (URL 20).
3.
Двигайтесь обдуманно и не спеша: переместите поле из одного класса в другой,
объедините два подобных метода в суперкласс. Часто при реорганизации вно­
сится много локальных изменений, которые приводят к серьезным сдвигам.
Если выдвигаетесь без спешки и проводите тестирование после каждого шага,
вы избежите длительной процедуры отладки.
На данном уровне тестирование будет обсуждаться в разделе "Программа, кото­
рую легко тестировать", тестирование на более высоком уровне — в разделе "Безжа­
лостное тестирование", но мнение г-на Фаулера о тщательном регрессионном тести­
ровании является ключом к надежной реорганизации.
Также весьма полезно удостовериться в том, что серьезные изменения в некоем моду­
ле, такие как изменения его интерфейса или его функциональной возможности неподо­
бающим способом, приведут к нарушению процесса сборки. Это означает, что прежние
клиенты этой программы не смогут пройти компиляцию. Тогда вы можете быстро оты­
скать старых клиентов и внести необходимые изменения, чтобы осовременить их.
Поэтому в следующий раз, когда вам попадется фрагмент программы, который не
совсем такой, каким ему надлежит быть, исправьте и его, и все то, что от него зави­
сит. Научитесь управлять этой головной болью: если она досаждает вам сейчас, но за­
тем будет досаждать еще больше, у вас есть шанс устранить ее совсем. Помните уро­
ки, полученные в разделе "Энтропия в программах": не живите с разбитыми окнами.
Другие разделы, относящиеся к данной теме:
•
Мой исходный текст съел кот Мурзик
•
Энтропия в программах
•
Суп из камней и сварившиеся лягушки
•
Пороки дублирования
•
Ортогональность
•
Программирование в расчете на стечение обстоятельств
•
Программа, которую легко тестировать
•
Безжалостное тестирование
Упражнения

## По всей вероятности, за последние годы представленная ниже программа пе­


реписывалась несколько раз, но эти изменения никак не способствовали улуч-

Пока вы пишете программу
171
шению ее структуры. Проведите ее реорганизацию. (Ответ см. в Приложе­
нии В.)
i f
( s t a t e == TEXAS) {
rate = TX_RATE;
amt
= base * TX_RATE;
c a l c = 2*basis(amt) + extra(amt)*1.05;
>
else i f
( ( s t a t e == OHIO) || ( s t a t e == MAINE)) {
rate = ( s t a t e == OHIO) ? 0H_RATE : MN_RATE;
amt
= base * rate;
c a l c = 2*basis(amt) + extra(amt)*1.05;
i f
( s t a t e == OHIO)
points = 2;
>
else {
rate
= 1 ;
amt
= base;
calc = 2*basis(amt) + extra(amt)*1.05;
>

## Класс Java, представленный ниже, нуждается в поддержке дополнительных


форм. Произведите реорганизацию этого класса, чтобы подготовить его к этим
дополнениям.
public c l a s s Shape {
public s t a t i c f i n a l int SQUARE
= 1;
public s t a t i c f i n a l int CIRCLE
= 2;
public s t a t i c f i n a l int RIGHT_TRIANGLE = 3;
private int
shapeType;
private double s i z e ;
public Shape(int shapeType, double s i z e ) {
this.shapeType = shapeType;
t h i s . s i z e
= s i z e ;
>
11 .. . другие методы . . .
public double a r e a ( ) {
switch (shapeType) {
case SQUARE:
return s i z e * s i z e ;
case CIRCLE:
return M a t h . P I * s i z e * s i z e / 4 . 0 ;
case RIGHT_TRIANGLE: return s i z e * s i z e / 2 . 0 ;
)
return 0;
}
}

## Данная программа на языке Java представляет собой часть некоего скелета,


который будет использоваться во всем вашем проекте. Произведите реоргани­
зацию этой программы, чтобы сделать ее более общей и упростить ее расши­
рение в будущем. (Ответ см. в Приложении В.)

172
Глава 6
public class Window {
public Window(int width, int height) { . . .
}
public void s e t S i z e ( i n t width, int height) { . . .
}
public boolean overlaps(Window w) { . . .
}
public int getArea() { . . .
}
}
Термин "программная интегральная схема" является метафорой, брошенной в ходе
дискуссии о многократном использовании и компонентно-ориентированной разработ­
ке

## Идея заключается в том, что программные компоненты должны объединяться так


же, как это происходит с чипами интегральной схемы. Этот подход срабатывает толь­
ко в том случае, если известно, что используемые вами компоненты являются надеж­
ными.
Чипы предназначены для тестирования не только на предприятии-изготовителе,
не только при сборке, но и в сфере их применения. Более сложные чипы и системы
могут снабжаться полномасштабными средствами самотестирования, которые осу­
ществляют внутреннюю диагностику на базовом уровне, или тестовым стендом с ком­
плектом измерительных кабелей, инициирующим подачу тестовых входных сигналов
и снимающим ответную информацию с чипа.
То же самое можно осуществить и в случае с программным обеспечением. Подоб­
но нашим коллегам, работающим с "железом", нам приходится с самого начала
встраивать средства тестирования в программы и тщательно тестировать каждый
фрагмент, перед тем как предпринять попытку их объединения.
Тестирование аппаратных средств на уровне чипа отдаленно напоминает модульное
тестирование программного обеспечения — тестируется каждый модуль по отдельно­
сти для проверки его поведения. Мы можем лучше представить себе, какова будет ре­
акция модуля на внешний мир, если проведем его тщательное тестирование в контро­
лируемых (и даже искусственных) условиях.
Модульный программный тест — это программа, испытывающая работу модуля.
Обычно модульный тест задает некую искусственную среду, затем осуществляется
вызов подпрограмм из проверяемого модуля. Затем происходит проверка получен­
ных результатов, они сравниваются с известными величинами или с результатами
предыдущих прогонов той же самой программы тестирования (регрессионное тести­
рование).
Термин "программная интегральная схема", по-видимому был введен Коксом и Новобилски
(1986) в их книге по языку Objective-C под названием "Object-Oriented Programming"
34 Программа, которую легко
тестировать
Модульное тестирование
[CN91].

Пока вы пишете программу
173
Когда мы объединим наши "программные интегральные схемы" в единую систему,
мы будем уверены, что ее отдельные части работают предсказуемо, а затем можем
применить те же средства модульного тестирования при проверке системы в целом. О
подобном крупномасштабном тестировании речь идет в разделе "Безжалостное тес­
тирование".
Но прежде выйти на этот уровень, необходимо решить, а что же мы будем тести­
ровать на уровне блоков. Обычно программисты задают несколько случайных мас­
сивов данных и считают, что они провели тестирование. Но это можно сделать на­
много лучше, если использовать идеи, связанные с "программированием
по
контракту".
Тестирование в рамках контракта
Мы рассматриваем модульное тестирование, как тестирование исходя из контрак­
та (см. "Проектирование по контракту"). Нам бы хотелось написать процедуры
тестирования, которые гарантируют, что данный модуль соблюдает соответствую­
щий контракт. При этом выясняются два момента: отвечает ли программа услови­
ям контракта, и означает ли контракт на самом деле то, что мы о нем думаем. Мы
хотим проверить, обладает ли модуль функциональными характеристиками, кото­
рые в нем заложены, используя разнообразные тестовые процедуры и граничные
условия.
Что это означает на практике? Рассмотрим подпрограмму извлечения квадратного
корня, с которой мы впервые встретились в разделе "ППК и аварийное завершение
работы программы". Ее контракт довольно прост:
require:
argument >=0
ensure:
abs((result * result) -- argument) < epsilon
Он указывает на моменты, нуждающиеся в проверке:
•
Передать отрицательный аргумент и удостовериться в том, что он отклонен
•
Передать аргумент, равный нулю, и удостовериться в том, что он принят (это
граничное значение)
•
Передать значение в интервале от нуля до максимально выражаемого пара­
метра и проверить, что разность между квадратом результата и исходным ар­
гументом меньше некоторой величины "epsilon"
Вооружась этим контрактом и полагая, что наша программа осуществляет собст­
венную проверку предусловий и постусловий, можно записать базовый тестовый сце­
нарий для проверки функции извлечения квадратного корня.
public void testValue(double num, double expected) {
double result = 0.0;
try
{
/ / We may throw a
result = mySqrt(num);
/ / precondition
exception
>

174
Глава 6
catch (Throwable e) {
i f (num < 0.0)
Return;
Else
A s s e r t ( f a l s e ) ;
//
If
input
is
< 0,
then
II
we're
expecting
the
II
exception,
otherwise
II
force
a test
failure
}
assert(Math.abs(expected-result) < e p s i l o n ) ;
}
Затем мы можем вызвать эту подпрограмму, чтобы проверить нашу функцию из­
влечения квадратного корня:
t e s t V a l u e ( - 4 . 0 ,
0 . 0 ) ;
testValue( 0.0,
0 . 0 ) ;
testValue( 2.0,
1.4142135624);
testValue(64.0,
8 . 0 ) ;
testValue(1.0e7,
3162.2776602);
Это весьма простая процедура тестирования; в реальном мире любой нетривиаль­
ный модуль скорее всего будет зависеть от ряда других модулей, поэтому, может быть,
есть смысл протестировать их сочетание?
Предположим, имеется модуль А, который использует модули LinkedList и Sort.
Мы осуществляем тестирование в следующем порядке:
1.
Полностью тестируем контракт модуля LinkedList.
2.
Полностью тестируем контракт модуля Sort.
3.
Тестируем контракт модуля А, который полагается на другие контракты, но не
раскрывает их напрямую.
При этом способе тестирования вначале вы обязаны проводить тестирование под­
компонентов.
Если модули LinkedList и Sort успешно прошли тестирование, а модуль А испыта­
ния не прошел, мы можем быть вполне уверены, что проблема заключается в моду­
ле А или в том, как модуль А использует один из подкомпонентов. Эта методика спо­
собствует уменьшению трудоемкости процесса отладки: можно быстро сосредото­
читься на вероятном источнике проблем в пределах модуля А и не тратить время на
изучение его подкомпонентов.
Зачем вся эта головная боль? Прежде всего, хотелось бы избежать создания
"бомбы замедленного действия", той, что остается незамеченным и позже взрывается
в самый неподходящий момент во время работы над проектом. Подчеркивая термин
"тестирование в рамках контракта", мы пытаемся, насколько это возможно, избежать
катастроф, возникающих в будущем.
Подсказка 48
Проектируйте с учетом тестирования
Когда вы проектируете модуль или даже целую программу, вы обязаны проектиро­
вать ее контракт и программу для проверки этого контракта. Проектируя программу,

Пока вы пишете программу
175
которая проходит тестирование и выполняет соответствующий контракт, вы можете
учесть граничные условия и другие аспекты, на которые в иных случаях не обратили
бы внимания. Лучше всего устранять ошибки, избежав их с самого начала. На самом
деле, при создании процедуры тестирования до реализации программы вам приходит­
ся испытывать интерфейс, перед тем как принять его.
Создание модульных тестов
Модульные тесты не должны оказываться где-то на периферии исходной древовидной
схемы. Они должны располагаться так, чтобы с ними было удобно обращаться. В слу­
чае небольших проектов можно внедрить модульный тест в сам модуль. Для более
крупных проектов можно поместить каждую из процедур тестирования в отдельный
подкаталог. В любом случае необходимо помнить, что если модуль сложно отыскать,
то он не будет использован.
Делая вашу тестовую процедуру доступной, вы наделяете разработчиков, которые
могут воспользоваться вашей программой, двумя бесценными ресурсами:
1.
Примерами того, как использовать все функциональные возможности вашего
модуля
2.
Средствами построения процедур регрессионного тестирования для проверки
правильности любых изменений, которые будут вноситься в программу впо­
следствии
Если каждый класс или модуль содержит свой собственный модульный тест,
это удобно, но не всегда практично. Например, в языке Java каждый класс содер­
жит собственную подпрограмму main. За исключением файла основного класса
приложения, подпрограмма ma:.n может использоваться для запуска модульных
тестов; она будет игнорироваться во время работы самого приложения. Преиму­
щество состоит в том, что программа, отправляемая заказчику, все еще содержит
тесты, которые могут использоваться для диагностики проблем, возникающих "в
боевой обстановке".
При работе с языком С + + вы можете добиться того же эффекта (во время компи­
ляции) используя конструкцию #ifdef для выборочной компиляции программы мо­
дульного теста. Ниже представлен очень простой модульный тест на языке С + + , вне­
дренный в наш модуль и проверяющий работу функции извлечения квадратного корня
с помощью подпрограммы testValue, подобной программе на языке Java, реализо­
ванной ранее:
#ifdef
__TEST__
int main(int argc, char **argv)
{
a r g c - - ; argv++;
/ / пропускаем
имя
программы
i f
(argc > 2) {
/ / станд.
тесты, если
аргументы
не
указаны
t e s t V a l u e ( - 4 . 0 ,
0 . 0 ) ;
testValue( 0.0,
0 . 0 ) ;
testValue( 2.0,
1.4142135624);
testValue(64.0,
8 . 0 ) ;
testValue(1.0e7, 3162.27^6602);

176
Глава 6
}
else {
/ / в этом случае используем аргументы
double num, expected;
while (argc >= 2) {
num = atof(argv[0]);
expected = atof(argv[1]);
testValue(num,expected);
argc -= 2;
argv += 2;
}
}
return 0;
}
#endif
Данный модульный тест запускает минимальный набор тестов или же (при нали­
чии аргументов) позволяет использовать внешние данные. Эта возможность могла
быть задействована в сценарии запуска более полного набора тестов.
Как поступить, если корректным откликом на модульный тест является выход из
программы или ее аварийное завершение? В этом случае вам необходимо выбирать
запускаемый тест, указывая аргумент в командной строке. Вам также придется пе­
редать некие параметры, чтобы указать различные начальные условия для ваших
тестов.
Но разработки одних модульных тестов недостаточно. Вы обязаны выполнять их и
выполнять часто. Это также полезно, если класс время от времени проходит процеду­
ру тестирования.
Применение тестовых стендов
Поскольку обычно мы пишем большое количество тестирующих программ и прово­
дим большое количество процедур тестирования, есть смысл облегчить себе жизнь и
разработать стандартный тестовый стенд для конкретного проекта. Программа main,
представленная в предыдущем разделе, является весьма простым тестовым стендом,
но обычно нам нужно больше функциональных возможностей.
Тестовый стенд может осуществлять универсальные операции, такие как регист­
рация состояния системы, анализ выходных данных на наличие ожидаемых результа­
тов, а также выбор и запуск конкретных процедур тестирования. Стенды могут управ­
ляться при помощи графического интерфейса, могут быть написаны на том же
целевом языке, что и весь проект, или реализованы в виде сочетания сборочных фай­
лов и сценариев на языке Perl. Простой тестовый стенд описан в ответе к упражне­
нию 41 (см. Приложение В).
При работе с объектно-ориентированными языками и средами вы можете создать
базовый класс, который содержит универсальные операции. Отдельные тесты могут
создать подкласс и добавить обычный специфические процедуры тестирования. Вы
можете использовать стандартное соглашение об именовании и отражение на языке
Java для формирования списка процедур тестирования в автоматическом режиме. Эта

Пока вы пишете программу
177
методика является прекрасным способом соблюдать принцип DRY — вам не прихо­
дится следить за списком доступных тестов. Но перед тем как взлететь и начать пи­
сать свой собственный стенд, есть смысл изучить методику xUnit Кента Бека и Эриха
Гаммы [URL 22]. Они уже проделали всю сложную подготовительную работу.
Вне зависимости от выбранной вами технологии тестовый стенд обязан предостав­
лять следующие возможности:
•
Стандартный способ определения установочной процедуры и завершения
работы
•
Метод выбора отдельных тестов или всех доступных тестов
•
Средства анализа выходных данных на наличие ожидаемых (или неожидан­
ных) результатов
•
Стандартизированная форма отчета об обнаруженных неисправностях
Процедуры тестирования должны быть составными; другими словами, процедура
тестирования может состоять из различающихся степенью детализации субтестов,
которые направлены на подкомпоненты. Мы можем воспользоваться этой особенно­
стью для тестирования отдельных компонентов или системы в целом, используя те же
самые инструменты.
Специальное тестирование
Во время отладки мы можем прекратить с о з д а н и е определенных тестов " н а
лету". Это может быть таким же простым делом, как оператор print или ввод
фрагмент программы в интерактивной оболочке отладчика или ИСР.
В конце с е а н с а отладки вам необходимо формализовать процедуру специ­
ального тестирования. Если программа прервалась один раз, с к о р е е всего,
она прервется снова. Не стоит просто отбрасывать в сторону созданную
вами процедуру тестирования; добавьте е е к существующему
модульному
тесту.
Например, при помощи JUnit (элемент Java из семейства xUnit), можно записать
процедуру проверки извлечения квадратного корня следующим образом:
public class JUnitExample extends TestCase {
public JUnitExample(final String name) {
super(name);
}
protected void setUpO {
// Load up test data...
testData.addElement(new dblPair(-4.0,0.0));
testData. addElement(new dblPair(0.0,0.0));
testData.addElement(new dblPair(64. 0, 8.0));
testData.addElement(new dblPair(Double.MAX_VALUE,
1.3407807929942597E154));
}

178
Глава 6
public void testMySqrt() {
double num, expected, result = 0.0;
Enumeration enum = testData.elements();
while (enum.hasMoreElements()) {
dblPair p = (dblPair)enum.nextElement();
num
= p.getNum();
expected = p.getExpected():
testValue(num, expected);
}
}
public s t a t i c Test suite() {
TestSuite suite= new TestSuiteO;
suite.addTest(new JUnitExample("testMySqrt"));
return suite;
}
}
Пакет JUnit был разработан по модульному принципу: к нему можно добавлять
сколько угодно тестов, и каждый из них может, в свою очередь, являться пакетом.
В дополнение к этому для управления процедурой тестирования вы можете выбрать
графический или текстовый интерфейс.
Построение тестового окна
Даже самые лучшие наборы тестов, скорее всего, не смогут обнаружить всех "жуч­
ков": во влажных и жарких условиях реальной эксплуатации возникает нечто, что за­
ставляет их вылезать из деревянных изделий.
Это означает, что зачастую приходится тестировать фрагмент программного обес­
печения сразу после его развертывания — с реальными данными, текущими в его жи­
лах. В отличие от печатной платы или чипа, в программном обеспечении нет тестовых
контактов, но мы можем по-разному взглянуть на внутреннее состояние модуля, не
прибегая к помощи отладчика (в производственных условиях его применение либо не­
удобно, либо просто невозможно)
Одним из таких механизмов являются файлы журналов. Сообщения в журналах
должны записываться в обычном последовательном формате; возможно, вы захотите
провести их синтаксический анализ в автоматическом режиме для определения вре­
мени обработки или логических путей, по которым двигалась программа. Диагности­
ческие процедуры, составленные небрежно или в несовместимом формате, вызывают
тошноту — их трудно читать и непрактично анализировать.
Другим механизмом, позволяющим заглянуть внутрь выполняющейся программы,
является комбинация "горячих клавиш". При нажатии этой комбинации клавиш на
экране появляется окно диагностики с сообщениями о состоянии и т.д. Совсем не
обязательно сообщать о такой возможности конечным пользователям, но это может
быть весьма полезно для службы технического сопровождения.
Для более крупных программ, работающих на серверах, существует изящная тех­
нология, заключающаяся в том, что для слежения над ходом работы используется
встроенный web-сервер. Любой может привязать web-браузер к HTTP-порту прило-

Пока вы пишете программу
179
жения (который обычно имеет нестандартный номер типа 8080) и увидеть внутреннее
состояние, регистрировать входы в программу и даже нечто вроде панели управления
отладкой. Реализация этого может показаться сложным делом, но в действительности
это не так. Бесплатно внедряемые web-серверы с протоколом HTTP реализованы на
различных современных языках программирования. Поиск можно начать с сайта
[URL 58].
Культура тестирования
Все создаваемые вами программы будут протестированы — если не вами и вашей
командой, то конечными пользователями, так что вы вполне можете планировать их
тщательное тестирование. Небольшая предусмотрительность окажет серьезную по­
мощь в минимизации затрат на сопровождение и снизит количество обращений в
службу технического сопровождения.
Несмотря на репутацию хакеров, члены сообщества Perl являются стойкими при­
верженцами регрессионного и модульного тестирования. Стандартная процедура ин­
сталляции модуля в Perl поддерживает регрессионное тестирование с помощью ко­
манды
% make test
В этом отношении сам по себе Perl, не является чем-то сверхъестественным. Perl
облегчает сопоставление и анализ результатов тестирования для обеспечения соот­
ветствия, но его большое преимущество состоит в том, что он является стандартом —
тестирование проводится в конкретном месте и имеет предсказуемый результат. Тес­
тирование в большей степени является вопросом культуры, а не техники, независимо
от используемого вами языка.
Подсказка 49
Тестируйте ваши программы, в противном случае
это сделают ваши пользователи
Другие разделы, относящиеся к данной теме:
•
Мой исходный текст съел кот Мурзик
•
Ортогональность
•
Проектирование по контракту
•
Реорганизация
•
Безжалостное тестирование
Упражнения

## Спроектировать тестовый шаблон для интерфейса блендера для коктейлей,


описанного в ответе к упражнению 17 (см. Приложение В). Напишите сцена­
рий оболочки, который осуществит регрессионное тестирование блендера.

180
Глава 6
Необходимо проверить основные функциональные возможности, ошибки и
граничные условия, а также любые обязательства по контракту. Какие ограни­
чения налагаются на изменение скорости вращения ротора блендера? Соблю­
даются ли они?
35 Злые волшебники
Никто не может отрицать — создавать приложения становится все сложнее и слож­
нее. В частности, пользовательские интерфейсы становятся все более утонченными.
Двадцать лет назад приложение среднего масштаба обошлось бы интерфейсом "стек­
лянного телетайпа" (а может быть, интерфейса не было бы и вовсе). Асинхронные
терминалы обеспечивали интерактивное отображением символов, а устройства ввода
(наподобие вездесущей IBM 3270) позволяли набирать целую экранную страницу пе­
ред нажатием клавиши [SEND]. Теперь пользователи требуют графический интер­
фейс с контекстно-зависимой справкой, средствами типа "вырезать и вставить", "пе­
ретащить и отпустить", средством OLE, много- или однодокументным интерфейсом.
Пользователям потребна интеграция с web-браузером и поддержка архитектуры с
тонким клиентом.
Усложняются и сами приложения. В настоящее время большинство разработок
использует многозвенную модель, возможно, с промежуточным программным обес­
печением или монитором транзакций. Эти программы будут отличаться динамично­
стью, гибкостью и способностью работать во взаимодействии с приложениями, напи­
санными сторонними фирмами.
Кажется, мы не сказали о том, что нам это было нужно на прошлой неделе — все и
сразу!
Разработчики стараются быть в форме. Если бы мы использовали те же самые ин­
струментальные средства, которые применялись для терминалов ввода-вывода два­
дцатилетней давности, то ничего бы не добились.
Поэтому производители инструментальных средств и поставщики средств инфра­
структуры придумали палочку-выручалочку — функцию-мастера. Это замечательное
средство. Вам нужно приложение с многодокументным интерфейсом и поддержкой
контейнера OLE? Один щелчок мыши, ответ на пару простых вопросов — и функция-
мастер автоматически сгенерирует для вас скелет программы. При выполнении дан­
ного сценария среда Microsoft Visual С + + автоматически создает программу, содер­
жащую свыше 1200 строк. Функции-мастера хорошо справляются и с другими зада­
ниями. Вы можете воспользоваться мастерами при создании серверных компонентов,
реализации элементов Java beans работе с сетевыми интерфейсами — все это доста­
точно сложные области, где не обойтись без помощи эксперта.
Но применение функции-мастера, спроектированного неким компьютерным гуру,
не делает автоматически из разработчика Джо компьютерного эксперта. Джо чувст­
вует себя недурно — он ведь сгенерировал большое количество исходного текста и
довольно элегантную на вид программу. Ему нужно лишь добавить функциональную
возможность, характерную для данного приложения, и программу можно отправлять
заказчику. Но покуда Джо реально не осознает сути программы, сгенерированной от

Пока вы пишете программу
181
его имени, он вводит самого себя в заблуждение. Он программирует в расчете на сте­
чение обстоятельств. Функция-мастер подобна улице с односторонним движением —
она лишь "вырезает" программу и затем движется далее. Если сгенерированная про­
грамма не совсем правильна или обстоятельства изменились), а вам необходимо
адаптировать ее, вы остаетесь с ней один на один.
Мы не выступаем против функций-мастеров. Напротив, их созданию в книге по­
священ целый раздел "Генераторы исходных текстов". Но если вы все же используете
функцию-мастера и не понимаете всей создаваемой ею программы, то не сможете
управлять вашим собственным приложением. Вы не сможете сопровождать его и бу­
дете затрачивать неимоверные усилия при отладке.
Подсказка 50
Не пользуйтесь программой функции-мастера, которую
не понимаете
Некоторые полагают, что это совсем уж экстремистская позиция. Они говорят,
что разработчики всегда основывают свою работу на предметах, которые до конца им
непонятны, — на квантовой механике в интегральных схемах, схеме прерываний в
процессоре, алгоритмах, используемых при диспетчеризации процессов, программах
из имеющихся библиотек и т.д. Мы согласны. И мы придерживались бы того же мне­
ния о функциях-мастерах, если бы они представляли собой просто набор библиотеч­
ных вызовов или стандартные службы операционной системы, на которых могли по­
ложиться разработчики. Но это не так. Функции-мастера генерируют программу,
которая становится неотъемлемой частью приложения, написанного разработчиком
Джо. Сгенерированная программа не выносится за скобки, прячась за опрятным ин­
терфейсом, она переплетена, строчка за строчкой, с теми функциональными возмож­
ностями, которые созданы самим Джо

## В конечном итоге она перестает быть про­


граммой функции-мастера и становится программой самого Джо. Никто не должен
генерировать программу, не понимая ее до конца.
Другие разделы, относящиеся к данной теме:
•
Ортогональность
•
Генераторы исходных текстов
Вопросы для обсуждения
•
Если в вашем распоряжении имеется функция-мастер построения графиче­
ского интерфейса, воспользуйтесь ей для генерирования "скелета" прило­
жения. Внимательно изучите каждую строку сгенерированной программы.
Все ли в ней вам понятно? Могли бы написать ее сами? Лучше написать ее
самому, или же она делает то, что вам не нужно?
Тем не менее, существуют иные методики, которые помогают управлять сложностью про­
грамм. Две из них — Java beans и АОР — обсуждались в разделе "Ортогональность".


Глава 7
Перед тем, как начать проект
У вас никогда не возникало ощущения, что ваш проект обречен еще до его начала?
Иногда так и происходит, если вначале вы не установите некоторые основополагаю­
щие правила. В противном случае вы также можете объявить проект закрытым и сэ­
кономить спонсору некоторую часть его денег.
В самом начале проекта вам придется определить требования. Недостаточно
лишь выслушать пользователей, необходимо прочесть раздел "Карьер для добычи
требований".
Житейская мудрость и управление сдерживающими факторами являются основ­
ными темами раздела "Разгадка невероятных головоломок". Неважно, какую опера­
цию вы осуществляете — анализ, составление текста программы, или тестирование,
проблемы возникают все равно. Чаще они не будут настолько сложными, какими по­
казались вначале.
Когда вы начинаете думать, что решили все проблемы, то все равно будете чувст­
вовать неудобства, начав работу над проектом. Является ли это простым промедлени­
ем или чем-то большим? В разделе "Пока вы не готовы" предлагается совет — в ка­
кой момент благоразумно прислушаться к предостережению внутреннего голоса.
Слишком раннее начало — это проблема, но слишком долгое ожидание еще хуже.
В разделе "Западня со стороны требований" обсуждаются преимущества создания
спецификаций по образцу.
И наконец, в разделе "Круги и стрелки" рассматриваются некоторые ловушки, в
которые можно попасть при использовании формальных процессов и методологий.
Неважно, насколько хорошо он продуман и какие "лучшие случаи из практики" в нем
использованы, — никакой метод не заменит мышления.
Если вы устраните эти критические аспекты до того, как проект будет запущен, вы
лучше справитесь с "аналитическим параличом" и начнете выполнять реальный ус­
пешный проект.

184
Глава 7
36 Карьер для добычи требований
Совершенство достигается не тогда, когда
уже нечего прибавить, но когда уже ничего
нельзя отнять.
Антуан де Сент-Экзюпери, Ветер, песок и звезды, 1939
Многие книги и учебные пособия относят процедуру сбора исходных требований к на­
чальной фазе проекта. Термин "сбор" напоминает о племени счастливых аналитиков,
занимающихся собирательством камней-самородков мудрости, которые разбросанны
по земле, на фоне приглушенного звучания "Пасторальной симфонии". Термин
"сбор" напоминает о том, что все требования уже имеются в наличии, нужно лишь
отыскать их, положить в корзину и весело шагать дальше.
Это не совсем так. Требования редко лежат на поверхности. Обычно они находят­
ся глубоко под толщей предположений, неверных представлений и политики.
Подсказка 51
Не собирайте требования — выискивайте их
В поисках требований
Как распознать истинное требование, пробиваясь к нему сквозь толщу грязевых на­
носов? Ответ на этот вопрос и прост, и сложен одновременно.
Простой ответ состоит в том, что требование формулирует необходимость осущест­
вления чего-либо. Грамотно составленное требование выглядит следующим образом:
•
Доступ к личному делу сотрудника ограничен группой уполномоченных на
то лиц.
•
Температура головки блока цилиндров не должна превышать определенного
критического значения, зависящего от марки двигателя.
•
Редактор выделяет ключевые слова, выбор которых зависит от типа редакти­
руемого файла.
Однако подобной четкостью могут похвастаться лишь немногие требования, что и
делает их анализ весьма сложной задачей.
Первая формулировка в списке, приведенном выше, вероятно, была составлена
пользователями следующим образом: "Доступ к личному делу сотрудника ограничен
его руководителями и работниками отдела кадров". Является ли эта формулировка
требованием? Возможно, что сегодня она таковым и является, но она воплощает
бизнес-политику в абсолютной формулировке. Политика же регулярно меняется, по­
этому, скорее всего, мы не захотим жестко встраивать ее в наши требования. Мы ре­
комендуем документировать положения политики отдельно от требований и связы­
вать их посредством гиперссылки. Сделайте требование общей формулировкой и
снабдите разработчиков информацией о политике в качестве примера того, что им
придется поддерживать в реализации. Политика конечна, как и метаданные в прило­
жении.

Перед тем, как начать проект
185
Это весьма тонкое различие, но именно оно окажет серьезное воздействие на раз­
работчиков. Если требование сформулировано как "Доступ к личному делу сотрудни­
ка ограничен персоналом фирмы", то разработчик может прекращать составление
программы проверки на том месте, где приложение обращается к этим файлам. Одна­
ко если эта формулировка звучит как "Доступ к личному делу сотрудника ограничен
уполномоченными на то пользователями", то разработчик, по всей вероятности,
спроектирует и реализует нечто вроде системы управления доступом. При изменении
политики (а оно произойдет) потребуется лишь обновление метаданных системы. На
самом деле подобный метод сбора требований приведет вас к созданию системы, чет­
ко структурированной для поддержки метаданных.
Различия между требованиями, политикой и реализацией могут быть весьма размы­
тыми, если речь идет о пользовательских интерфейсах. Слова "Система должна давать
возможность выбора срока предоставления ссуды" представляет собой формулировку
требования. Выражение "Для выбора срока предоставления ссуды нам необходимо
окно списка" может являться формулировкой, а может таковой и не являться. Если
пользователям позарез нужно окно списка, то в этом случае речь идет о требовании.
Если же вместо этого они описывают свою способность выбирать, используя окно спи­
ска лишь в качестве примера, то здесь говорится о требовании. Врезка "Когда интер­
фейс становится системой" описывает проект, который пошел совсем не в ту сторону,
поскольку потребности пользователей в интерфейсе были проигнорированы.
Важно обнаружить основополагающую причину того, почему пользователи посту­
пают определенным образом, а не так, как они привыкли делать это. В конечном итоге
разрабатываемой вами программе придется решать проблемы их бизнеса, а не просто
отвечать их заявленным требованиям. Документируя причины, по которым были вы­
двинуты требования, ваша команда получит бесценную информацию, необходимую
для принятия ежедневных решений, связанных с реализацией.
Существует простая методика: чтобы взглянуть изнутри на требования ваших
пользователей (которые часто являются весьма недостаточными), нужно самому
стать пользователем. Пишете систему для службы поддержки? Посидите пару дней на
телефоне вместе с опытным сотрудником службы поддержки. Занимаетесь автомати­
зацией ручной системы управления складскими запасами? Поработайте на складе с
неделю

## Вы получите представление о реальном использовании системы и вдобавок


будете просто поражены тем, насколько просьба "Можно я посижу рядом с вами не­
дельку и посмотрю, как вы работаете?" способствует доверию и закладывает основы
ваших взаимоотношений с пользователями. Но не путайтесь у них под ногами!
Подсказка 52
Работайте с пользователем, чтобы мыслить категориями
пользователя
1
Неделя — это долго или нет? На самом деле нет, особенно если рассматривать процессы,
в которых менеджмент и исполнители находятся в разных мирах. Менеджмент дает одно
представление о том, как все работает, но как только спускаешься в цех, то встречаешься с
иной реальностью, для адаптации к которой требуется время.

186
Глава 7
Добыча полезных требований важна — в это время начинают складываться связи
с вашим пользовательским ядром, изучаются их ожидания и надежды на создаваемую
вами систему. Более подробно это обсуждается в разделе "Большие надежды".
Документация требований
Итак, вы садитесь за один стол с пользователями и начинаете выпытывать у них, что
же им нужно на самом деле. Вы столкнетесь с несколькими вероятными сценариями,
описывающими, что должно делать ваше приложение. Поскольку вы остаетесь про­
фессионалом во всем, то вам хочется записать их и опубликовать документ, которым
все смогут пользоваться в качестве основы при обсуждении, — разработчики, конеч­
ные пользователи и спонсоры проекта.
Это весьма широкая аудитория.
Ивар Джекобсон [Jac94] предложил концепцию "сценариев использования систе­
мы" для фиксирования требований. Они позволяют описывать частные случае исполь­
зования системы не с точки зрения пользовательского интерфейса, а в более абстракт­
ном виде. К сожалению, книга И. Джекобсона несколько расплывчата в деталях,
поэтому в настоящее время не существует единого мнения о том, что считать "сценари­
ем использования системы". Что это — формальный, или неформальный термин, про­
заический или структурированный документ (подобный канцелярской форме)? Каким
должен быть уровень детализации (помните, что у нас весьма широкая аудитория)?
Когда интерфейс становится системой
В своей статье (журнал "Wired", январь 1999, с. 176) п р о д ю с е р и музыкант
Б р а й а н Иноу о п и с а л чудо техники — новейший микшерный пульт. Этот пульт
заставляет звучать все, что в принципе может звучать. И все же, вместо того,
чтобы помочь музыкантам в создании лучших произведений или
ускорить
(или удешевить) п р о ц е с с записи, он "путается под ногами", н а р у ш а я творче­
ский п р о ц е с с .
Чтобы понять, почему это происходит, необходимо взглянуть на работу инжене­
ров студии звукозаписи. Они сводят звук интуитивно. З а годы работы в студии у
них вырабатывается врожденный цикл обратной связи между ушами и кончика­
ми пальцев, управляющих плавно движущимися регуляторами,
вращающимися
ручками и т.д. Однако компьютерный интерфейс нового микшерного пульта не
усиливал их способностей. Вместо этого он заставлял пользователей набирать
текст на клавиатуре и/или щелкать мышью. Функции, обеспечиваемые этим ин­
терфейсом, были универсальными, но они были скомпонованы неизвестными и
экзотическими способами. Функции, необходимые
инженерам в их работе,
иногда скрывались за экзотическими названиями или же достигались за счет
неестественных сочетаний базовых средств.
Э т а с р е д а характеризовалась требованием — усилить существующие
н а ­
выки работы. Вместо того, чтобы раболепно дублировать то, что уже с у щ е с т ­
вует, нужно было обеспечить переход на новую ступень развития.

Перед тем, как начать проект
187
Например, хорошим подспорьем в работе инженеров звукозаписи мог бы
оказаться сенсорный интерфейс, смонтированный
в виде
классического
микшерного пульта, но при этом позволяющий программам выходить з а гра­
ницы, определенные фиксированными ручками и переключателями. Единст­
венным с п о с о б о м завоевать рынок является обеспечение удобства во время
п е р е х о д а н а новую ступень з а счет уже известных метафор.
Этот пример также иллюстрирует нашу уверенность в том, что удачные инст­
рументы всегда привыкают к рукам, их держащим. В данном случае речь идет
о привыкании инструментов, которые создаются вами для других людей.
При рассмотрении сценариев использования системы стоит отметить их целена­
правленную природу. Алистер Кркбэрн опубликовал статью, в которой описывается
этот подход, а также шаблоны, используемые (строго или нестрого) при этом в каче­
стве отправной точки ([Сос97а]; имеется Интернет-версия [URL 46]). На рис. 7.1 по­
казан (в сокращении) пример подобного шаблона, на рис. 7.2 представлен пример
сценария его использования.
A. ХАРАКТЕРНАЯ ИНФОРМАЦИЯ
— Цель в контексте
— Область действия
— Уровень
— Предусловия
— Условие успешного завершения
— Условие неудачного завершения
— Первичный действующий субъект
— Условие начала действия
B. ОСНОВНОЙ СЦЕНАРИЙ ПРИ УСПЕШНОМ ЗАВЕРШЕНИИ
C. РАСШИРЕНИЯ
D. ВАРИАНТЫ
E. СОПУТСТВУЮЩАЯ ИНФОРМАЦИЯ
— Приоритет
— Производительность
— Частота
— Превосходящий прецедент использования
— Подчиненный прецедент использования
— Канал связи с первичным действующим субъектом
— Вторичные действующие субъекты
— Канал связи со вторичными действующими субъектами
F. РАСПИСАНИЕ
G. ОТКРЫТЫЕ ПРОБЛЕМЫ
Рис. 7.1.
Шаблон
сценария
использования
системы
по А.
Кокбэрну
Используя формальный шаблон в качестве шпаргалки, вы можете быть уверены в
том, что включили всю необходимую информацию в сценарий использования систе­
мы: характеристики производительности, другие стороны-участники, приоритет, час­
тоту использования, и разнообразные ошибки и исключения, которые могут появ­
ляться неожиданно ("нефункциональные требования"). Шаблон удобен для записи

188
Глава 7
комментариев пользователей, наподобие " если мы получим условие ххх, то вместо
этого нам придется сделать ууу". Шаблон может послужить в качестве готовой пове­
стки дня при встрече с пользователями ваших программ.
ПРЕЦЕДЕНТ ИСПОЛЬЗОВАНИЯ № 5: ПРИОБРЕТЕНИЕ ТОВАРА
A. ХАРАКТЕРНАЯ ИНФОРМАЦИЯ
• Цель в контексте: Покупатель напрямую направляет коммерческий запрос в нашу
фирму и ожидает отгрузки товаров и выставления счета за указанные товары
• Область действия: Фирма
• Уровень: Итоговая информация
• Предусловия: Нам известен покупатель, его адрес и т.д.
• Условие успешного завершения: Покупатель получает товары, мы получаем оплату
• Условие неудачного завершения: Мы не производим отгрузку товаров,
покупатель не производит оплату
• Первичный действующий субъект: Покупатель, любой агент (или компьютер),
действующий от имени заказчика
• Условие начала действия: Получение запроса на приобретение товара
B. ОСНОВНОЙ СЦЕНАРИЙ С УСПЕШНЫМ ЗАВЕРШЕНИЕМ

## Покупатель оплачивает счет-фактуру


C. РАСШИРЕНИЯ
За. Один из пунктов заказа отсутствует у данной фирмы: Заказ переоформляется
4а. Покупатель производит оплату непосредственно кредитной картой:
Прием оплаты кредитной картой (прецедент использования № 44)
7а. Покупатель возвращает товар: Оформление возвращенного товара
(прецедент использования № 105)
D. ВАРИАНТЫ

## Покупатель может осуществить заказ по телефону, факсу, при помощи


Интернет-формы (на странице), по другим сетям электронного обмена информацией

## Покупатель может оплатить заказ наличными, денежным переводом, чеком,


или кредитной картой
E. СОПУТСТВУЮЩАЯ ИНФОРМАЦИЯ
• Приоритет: Высший
• Производительность: 5 минут на оформление заказа, оплата в течение 45 дней
• Частота: 200 заказов в день
• Превосходящий прецедент использования: Управление взаимоотношением
с заказчиком (сценарий использования № 2)
• Подчиненные прецеденты использования: Компоновка заказа (прецедент
использования №15)
• Прием оплаты кредитной картой (сценарий использования №44). Возврат товара покупателем
(прецедент использования №105)
• Канал связи с первичным действующим субъектом: по телефону, факсу или
компьютерной сети
• Вторичные действующие субъекты: компания — оператор платежной системы, банк,
экспедиторская фирма
F. РАСПИСАНИЕ
• Должная дата: Выпуск 1.0
G. ПРОБЛЕМЫ, ЯВЛЯЮЩИЕСЯ ОТКРЫТЫМИ
• Что происходит, если имеется лишь часть заказа?
• Что происходит, если кредитная карта похищена?
Рис. 7.2.
Пример
сценария
использования
системы

Перед тем, как начать проект
189
Подобного рода организация поддерживает иерархическое структурирование сце­
нариев использования системы — вложение более подробных сценариев в сценарии
более высокого уровня. Например, сценарии post debit и post credit дополняют друг
друга в сценарии post transaction.
Диаграммы сценариев
использования
Последовательность операций может быть зафиксирована при помощи диаграмм на
языке UML, а схемы концептуального представления иногда могут быть полезны для
оперативного моделирования бизнес-процессов. На самом деле сценарии использо­
вания представляют собой текстовые описания с иерархией и перекрестными ссылка­
ми. Сценарии использования могут содержать гиперссылки на другие сценарии и мо­
гут вкладываться друг в друга.
Рис. 7.3.
Сценарии
использования,
выраженные
UML, понятны
даже
ребенку!
Нам кажется невероятным, что кто-нибудь можно всерьез воспринимать докумен­
тирование информации, используя примитивные символы, подобные изображенным на
рис. 7.3. Не будьте рабом любой системы обозначений: используйте любой метод об­
щения, с помощью которого можно обмениваться требованиями с вашей аудиторией.
Чрезмерная спецификация
При генерации документов, содержащих требования, возникает серьезная опасность
чрезмерной спецификации. Хорошие документы остаются абстрактными. Там, где
думают о требованиях, простейшая формулировка, точно отражающая суть потреб­
ности, является наилучшей. Это не означает что вы можете допустить неопределен­
ность, нужно зафиксировать основополагающие семантические инварианты в качест­
ве требований и задокументировать конкретную или же существующую на данный
момент практику в качестве политики.
Требования не являются архитектурой. Требования — это не конструкция и не
пользовательский интерфейс. Это потребность.
Видеть перспективу
Вина за возникновение "проблемы 2000 года" часто возлагается на близоруких про­
граммистов, пытавшихся сэкономить несколько байтов в те дни, когда объем памяти
мэйнфреймов был меньше, чем у современных пультов дистанционного управления
телевизорами.

190
Глава 7
Но это не зависело от программистов и не являлось вопросом использования
памяти. Если уж быть честным до конца, вина за это лежит на системных аналити­
ках и проектировщиках. "Проблема 2000 года" возникла по двум основным причи­
нам: из-за нежелания выйти за пределы существующей бизнес-практики и нару­
шения принципа DRY.
Двухразрядное обозначение года использовалось в деловой практике задолго
до появления компьютеров. Это было обычной практикой. В то время приложе­
ния, предназначенные для обработки данных, в основном занимались автоматиза­
цией существующих бизнес-процессов и просто повторили ошибку. Даже в том
случае, когда архитектура требовала двухразрядного обозначения при вводе дан­
ных, создании отчетов и хранении данных, появлялась абстракция DATE, которая
"знала" о том, что две цифры представляли собой усеченную форму реальной ка­
лендарной даты.
Подсказка 53
Абстракции живут дольше, чем подробности
Требует ли фраза "Видеть перспективу", чтобы вы занимались предсказанием бу­
дущего? Нет. Это означает создание формулировок типа:
Система
активно
извлекает
пользу
из абстракции
DATE.
Система
последовательно
и универсально
осуществит
реализацию
служб
DATE наподобие
форматирования,
хранения
данных
и
математиче­
ских
операций.
В требованиях указывается лишь то, что даты используются в принципе. Это
может навести на мысль, что с датами можно производить некоторые математиче­
ские действия и что даты будут храниться на различных устройствах внешней па­
мяти. Это и есть истинные требования для модуля или класса DATE.
Еще одна мелочь...
Вина за неудачи многих проектов возлагается на увеличение области их примене­
ния — это также называется раздуванием одной их характеристик, мелким улучша-
тельством или размыванием требований. Это аспект синдрома лягушки из раздела
"Суп из камней и сварившиеся лягушки". Что можно сделать для того, чтобы требо­
вания не поглотили нас?
В литературе описаны многие метрики: количество обнаруженных и устраненных
дефектов, плотность дефектов, сцепление, связывание, функциональные точки,
строки программы и т.д. Эти метрики могут прослеживаться вручную или с помощью
программы.
К сожалению, немногие проекты могут похвастаться активным прослеживанием
требований. Это означает, что они не имеют никакой возможности сообщать об изме­
нении в области действия — кто затребовал средство, кто утвердил его, общее число
утвержденных запросов и т.д.

Перед тем, как начать проект
191
Указание спонсорам на то воздействие, которое оказывает всякое новое средство
на график проекта, является средством сдерживания роста количества требований.
Если проект запаздывает на год по сравнению с начальными оценками, а в адрес ис­
полнителей летят обвинения, всегда полезно иметь точную и полную картину того,
как и когда происходит рост числа требований.
Легко быть втянутым в водоворот под названием "всего лишь еще одно средство",
но с помощью прослеживания требований вы получите более четкое представление о
том, что это "всего лишь еще одно средство" на самом деле является пятнадцатым по
счету, добавленным в этом месяце.
Поддержка
глоссария
Как только вы начинаете обсуждать требования, пользователи и специалисты в пред­
метной области будут использовать определенные термины, имеющие для них специ­
фическое значение. Например, они проводят различие между "клиентом" и "заказчи­
ком". Было бы неуместно допустить небрежность, используя в системе то один, то
другой термин.
Создайте и поддерживайте "глоссарий проекта", где будут определены все специ­
фические термины и словарь, используемый в проекте. Все участники проекта, от ко­
нечных пользователей до специалистов службы поддержки, обязаны использовать
глоссарий для обеспечения согласованности. Это подразумевает доступность глосса­
рия для широкого круга — хороший аргумент для размещении документации на web-
сайтах (об этом буквально через минуту).
Подсказка 54
Используйте глоссарий проекта
Очень сложно создать успешный проект, в котором пользователи и разработчики
обращаются к одному и тому же предмету под разными именами или, что даже хуже,
обращаются к разным предметам, используя одно и тоже имя.
Прошу слова...
В разделе "Все эти сочинения" обсуждается публикация проектных документов на
внутренних сайтах, обеспечивающих легкость доступа к ним со стороны всех участни­
ков. Этот способ распространения особенно полезен для документации, относящейся
к требованиям.
Представляя требования в виде гипертекстового документа, мы можем обращаться
к нуждам различной аудитории — дать каждому читателю то, что он хочет. Спонсоры
проекта могут действовать на высоком уровне абстракции, чтобы удостовериться в том,
что нет отклонений от цели бизнеса. Программисты могут использовать гиперссылки
для того, чтобы "врубиться" в возросшие уровни детализации (даже в те, которые ссы-
лаютя на соответствующие определения или технические характеристики).
Распространение с помощью сети Интернет также позволит избежать создания
толстенных отчетов под названием "Анализ требований", которые никто никогда не

192
Глава 7
прочтет и которые устаревают в тот момент, когда первая капля чернил смачивает
лист бумаги.
Если этот материал есть в Сети, то программисты даже могут его прочесть.
Другие разделы, относящиеся к данной теме:
•
Суп из камней и сварившиеся лягушки
•
Довольно приличные программы
•
Круги и стрелки
•
Все эти сочинения
•
Большие надежды
Вопросы для обсуждения
•
Можете ли вы использовать программы, которые сами пишете? Можно ли
обладать хорошим чутьем на требования, будучи неспособным использовать
программы самостоятельно?
•
Выберите проблему (не связанную с информатикой), которую вам необходи­
мо решить в данный момент. Сгенерируйте требования для решения, не тре­
бующего наличия компьютера.
Упражнения

## Какие из нижеследующих примеров, по всей вероятности, являются требова­


ниями? Переформулируйте те, которые таковыми на являются, для придания
им большей пользы (если это возможно). (Ответ см. в Приложении В.)

## Приложение будет организовано в виде нескольких внешних процессов и


внутреннего сервера.

## Если пользователь вводит нечисловые символы в числовое поле, система


будет выдавать звуковой сигнал и не примет их.

## Прикладная программа и данные должны умещаться в пределах 256 Кбайт.


37 Разгадка невероятных ГОЛОВОЛОМОК
Однажды царь Фригии Гордий завязал узел, который никто не мог развязать. Было
предсказано, что тот, кто сможет развязать его, станет властелином всей Азии. И вот
пришел Александр Македонский, который разрубил узел своим мечом. Несколько
иная интерпретация требований, и все — он стал властителем всей Азии.
Время от времени вы будет оказываться в ситуации, когда в самом разгаре проекта
перед вами возникает сложнейшая головоломка: техническая проблема, с которой
невозможно справиться, или фрагмент программы, составление которого оказалось
намного сложнее, чем вы думали. Может быть, это выглядит просто невозможным.
Но так ли это сложно на самом деле?

Перед тем, как начать проект
193
Рассмотрим реальные головоломки — хитроумные детальки, выполненные из
дерева, металла или пластмассы, которые появляются в дни рождественских
праздников и распродаж. Вся ваша задача состоит в том, что бы снять кольцо, или
сложить Т-образные кусочки в одну картинку или выполнить нечто подобное этим
заданиям.
Итак, вы пытаетесь сложить сделать это и быстро приходите к выводу, что очевид­
ные решения просто не срабатывают. Головоломка не может быть разгадана подоб­
ным способом. И хотя это очевидно, люди не прекращают делать одно и то же снова и
снова, будучи уверенными, что это и есть нужный способ.
Конечно же нет. Разгадка находится в совершенно другом месте. Секрет разгадки
головоломки состоит в идентификации реальных (а не воображаемыхТсдерживающих
факторов и поиске решения, исходя из этих ограничений, некоторые из которых абсо­
лютны, а другие являются лишь предвзятыми мнениями| Абсолютные ограничения
обязаны соблюдаться, какими бы неприятными и нелепыми они не казались. С другой
стороны, некоторые очевидные ограничения в реальности могут таковыми и не яв­
ляться. Например, существует старый фокус, который обычно демонстрируется в
баре: вы берете закупоренную бутылку шампанского и спорите, что можете пить из
нее пиво. Фокус заключается в том, что вы переворачиваете бутылку донышком вверх
и наливаете немного пива в углубление на донышке. Многие проблемы в программи­
ровании можно разрешить подобным оригинальным способом.
Степени свободы
Широко известное "умное" изречение о "размышлении вне пределов ящика" поощ­
ряет распознавание сдерживающих факторов, которые могут быть неприменимы в
данной ситуации, и игнорирование их впоследствии. Но эта фраза не вполне точна.
Если "ящик" является границей сдерживающих факторов и условий, то фокус заклю­
чается в нахождении этого "ящика", который может оказаться намного больше, чем
вы думаете.
Ключом к разгадке головоломки является распознавание факторов, сдерживаю­
щих вас, и степеней свободы, которые у вас есть, поскольку в них-то и находится раз­
гадка. Вот почему многие головоломки столь эффективны: слишком легко вы отвер­
гаете потенциальные разгадки.
Например, можете ли вы соединить все четыре точки (см. рисунок ниже) тремя
прямыми линиями и вернуться в исходную точку, не отрывая карандаша от бумаги и
не проводя одной и той же линии дважды [Но178]?
Вы обязаны бросить вызов любым предвзятым мнениям и оценить, являются ли
они реальными, раз навсегда установленными сдерживающими факторами.
Неважно, как вы мыслите — в пределах ящика или за его пределами. Проблема
заключается в нахождении ящика — распознавании реальных ограничений.

194
Глава 7
Подсказка 55
Не размышляйте вне ящика — найдите этот ящик
Столкнувшись с серьезной проблемой, представьте все возможные направления, в
которых вы можете двигаться. Не отвергайте никакие варианты, какими бы бесполезны­
ми или глупыми они ни казались. Теперь просмотрите весь список и объясните, почему
нельзя идти по тому или иному пути. Вы уверены в этом? Можете ли это доказать?
Рассмотрим историю с троянским конем — свежее решение непреодолимой
проблемы. Как войско может попасть в укрепленный город, оставаясь незамечен­
ным? Можете поспорить, что вариант "через главные ворота" изначально был от­
вергнут как самоубийственный. Расположите ограничения по категориям и приори­
тетам. Столяры вначале вырезают самые крупные деревянные детали, а затем из
оставшейся части — детали меньшего размера. Действуя подобным образом, мы
хотим вначале идентифицировать самые жесткие ограничения и поместить остав­
шиеся внутрь.
Между прочим, решение головоломки с четырьмя точками представлено в
Приложении В.
Есть более простой способ!
Иногда вам приходится работать над проблемой, которая оказывается намного слож­
нее, чем вы думали. Возможно, вы идете неправильным путем, возможно, в данный
момент вы отклонились от графика выполнения проекта или уже отчаялись увидеть
систему работающей, поскольку конкретную проблему "невозможно решить".
В этот момент необходимо сделать шаг назад и задать себе несколько вопросов:
•
Существует ли более простой способ?
•
Вы пытаетесь решить главную проблему или отвлекаетесь на второстепен­
ные технические детали?
•
Почему это является проблемой?
•
Что делает эту проблему столь сложной для решения?
•
Стоит ли делать это именно таким образом?
•
Стоит ли это делать вообще?
И во многих случаях секрет удивительным образом раскроется перед вами, как
только вы попробуете ответить на один из этих вопросов. Во многих случаях новая ин­
терпретация требований может унести с собой целый ворох проблем — так, как это
произошло в случае с гордиевым узлом.
Все, что вам нужно, — это знание реальных сдерживающих факторов, факторов,
вводящих вас в заблуждение, и мудрость, позволяющая отличить одно от другого.
Вопросы для обсуждения
•
Пристально взгляните на любую сложную проблему, которую вам приходит­
ся решать сегодня. Можете ли вы разрубить гордиев узел? Задайте себе

Перед тем, как начать проект
195
ключевые вопросы, приведенные выше, особенно этот: "Стоит ли делать это
именно таким образом?"
•
Когда вы получили проект, которым занимаетесь в настоящее время, то при­
лагался ли к нему набор ограничений?
38 Чувство готовности
Тот, кто колеблется,
иногда
спасается
Джеймс Тэрбер, Стекло на поле
Великим лицедеям присуща одна общая черта: они знают, когда начинать, и когда подож­
дать. Прыгун в воду стоит на трамплине, ожидая подходящего момента для прыжка. Ди­
рижер стоит за пультом с поднятыми руками, пока не почувствует, что пора начинать.
Вы — великий артист. Вам также необходимо прислушиваться к внутреннему го­
лосу, который шепчет "подожди". Если вы садитесь, начинаете набирать текст, а у вас
в голове возникает неотступное сомнение, прислушайтесь к нему.
Подсказка 56
Прислушайтесь к брюзжащим сомнениям — начинайте тогда,
когда полностью готовы
Когда-то существовал стиль обучения игре в теннис под названием "внутренний
теннис". Обучающийся должен был часами перекидывать мячи через сетку, не осо­
бенно заботясь о точности, а вместо этого описывая словами место, куда попал мяч,
относительно некой цели (часто этой целью был стул). Идея заключалась в трениров­
ке подсознания и рефлексов; так начинающий теннисист улучшал свою игру, не осоз­
навая, как и почем это происходит.
Будучи разработчиком, вы проделываете то же самое на протяжении всей вашей
профессиональной карьеры. Вы испробовали разные методы и видели, какие из них
работают, а какие нет. Вы накапливали опыт и мудрость. Когда вы сомневались или
испытывали затруднения, сталкиваясь с задачей, вы учитывали это. Возможно, вы не
сможете точно указать, что не так, но потерпите немного, и ваши сомнения, вероятно,
выкристаллизуются в нечто более твердое, на что вы можете ссылаться. Разработка
программ пока еще не является научной дисциплиной. Дайте инстинктам внести леп­
ту в вашу работу.
Здравое суждение или промедление?
Каждый испытывает страх перед чистым листом бумаги. Начало нового проекта (или
даже новый модуль в существующем проекте) может лишить вас спокойствия. Мно-\
гие из нас предпочли бы отложить момент связывания себя обязательствами. Но вы/
же не можете заявить, что вы просто оттягиваете начало работы?
Создание прототипа — это методика, хорошо зарекомендовавшая себя в этих об­
стоятельствах. Выберите область, которая, по вашему мнению, будет трудной, и нач-

196
Глава 7
ните создание некоего доказательства концепции. Вскоре вы можете ощутить, что
тратите время понапрасну. Это признак того, что ваше изначальное сопротивление
было просто желанием отложить момент связывания себя обязательствами. Откажи­
тесь от прототипа и врубайтесь в реальную разработку.
С другой стороны, в ходе разработки прототипа наступает момент истины, когда
вы внезапно осознаете, что некая базовая предпосылка была неверной. Но вам станет
ясно не только это, но и способ исправления этой предпосылки. Вы с легкостью отка­
жетесь от прототипа и начнете проект надлежащим образом. Инстинкты вас не обма­
нули, и вы сэкономили для себя и вашей команды значительное количество усилий,
которое могли потратить впустую.
Когда вы принимаете решение о создании прототипа в целях исследования причи­
ны вашего беспокойства, не забывайте, зачем вы это делаете. Вспоминать о том, что
вы начали создавать прототип спустя несколько недель после начала серьезного про­
екта, — последнее дело.
Это звучит несколько цинично, но начало работ по созданию прототипа может
быть более политкорректно, нежели примитивное высказывание типа "Я не настроен
на начало работы" с последующим запуском игры "пасьянс".
Вопросы для обсуждения
•
Обсудите синдром "страха начала работы" с вашими коллегами. Испытывают
ли они тот же самый синдром? Принимают ли они его во внимание? Какие прие­
мы они используют для его преодоления? Может ли группа преодолеть сопро­
тивление отдельной личности, или это будет давлением со стороны команды?
39 Западня со стороны требований
Пилот,
совершающий
посадку,
не управляет
самолетом
до
подачи
команды
"высота
принятия
решения",
когда
пилот,
управляющий
самолетом
и не совершающий
посадку,
переда­
ет управление
пилоту,
не осуществляющему
управление
и со­
вершающему
посадку,
если
последний
не подает
команду
"уход на второй
круг",
и в этом случае
пилот,
осуществляю­
щий
управление
и не совершающий
посадку,
продолжает
управлять
самолетом,
а пилот,
не управляющий
самолетом
и
совершающий
посадку,
остается
на связи
до подачи
команды
"посадка"
или "уход на второй
круг"
в зависимости
от
об­
становки.
Ввиду
недавних
случаев
неоднозначного
толкова­
ния этих правил
считаем
необходимым
дать их более
четкую
формулировку.
Цитата из докладной записки авиакомпании
British Airways, опубликованная
в журнале "Pilot Magazine", декабрь 1996 г.
Спецификация программы представляет собой процесс приема требований и сокра­
щения их до точки, в которой навык программиста может взять вверх. Это акт передачи
информации, объяснения и прояснения подобным образом в целях устранения основных

Перед тем, как начать проект
197
неоднозначностей. Подобно разговору с разработчиком, который будет осуществлять
первоначальную реализацию, спецификация является скрижалью для будущих поколе­
ний программистов, которые будут заниматься сопровождением и усовершенствованием
программы. Спецификация представляет собой и соглашение с пользователем — это
кодификация их потребностей и негласный контракт, говорящий о том, что окончатель­
ная версия системы будет соответствовать тем же требованиям.
Составление спецификации — это большая ответственность.
Проблема состоит в том, что многим проектировщикам трудно остановиться. Они
полагают, что, пока каждая второстепенная деталь не будет выявлена до мельчайших
подробностей, они даром получают свои деньги.
Эта является ошибкой по ряду причин. Во-первых, наивно полагать, что специфи­
кация вообще способна зафиксировать каждую подробность некой системы или
предъявляемых к ней требований. В узких предметных областях существуют фор­
мальные методы, с помощью которых можно описать систему, но для объяснения
смысла обозначений конечным пользователям все равно требуется проектиров­
щик — все еще имеет место человеческий фактор. И даже в отсутствии проблем,
присущих этой версии, весьма маловероятно, что средний пользователь точно знает,
что ему нужно от этого проекта. Заказчики могут сказать, что осознают суть требова­
ний, и подписаться под 200-страничным документом, составленным вами, но можете
быть уверены — как только они увидят систему в работе, вы будет завалены просьба­
ми о внесении изменений.
Во вторых, существует проблема выразительности самого языка. Все методики со­
ставления диаграмм и формальные методы все еще полагаются на выражение проводи­
мых операций средствами естественных языков'. А естественный язык не приспособ­
лен для этого. Посмотрите на формулировку любого контракта: юристам приходится
коверкать язык самым неестественным образом, стараясь быть точными.
Проблемный вопрос для вас. Напишите короткую инструкцию по завязыванию
бантиком шнурков на ботинках. Попробуйте!
Если вы хоть чем-то похожи на нас, то, скорее всего, сдадитесь, дойдя примерно до
этого места: "Теперь оберните ваш большой и указательный пальцы так, чтобы сво­
бодный конец шнурка проходил под левым шнурком во внутреннюю петлю..." Это фе­
номенально трудное задание. И все же большинство из нас могут зашнуровать ботин­
ки, не напрягая мозги.
Подсказка 57
Некоторые вещи лучше сделать, чем описывать
И наконец, существует "эффект смирительной рубашки" — конструкции, которая
не оставляет кодировщику пространства для импровизации и отнимает усилия про­
граммирования любого рода. Кое-кто говорит, что хотел как лучше, но он неправ. За-
Существуют некоторые формальные методики, которые пытаются выразить операции ал­
гебраически, но они редко используются на практике. Эти методы требуют, чтобы аналити­
ки разъясняли их значение конечным пользователям.

198
Глава 7
частую лишь на стадии написания текста определенные варианты становятся очевид­
ными. Во время написания текста вы можете подумать следующее: "Посмотрим вот
сюда. Поскольку я написал эту подпрограмму именно таким образом, я смог добавить
эту функциональную возможность практически без усилий". Или: "В спецификации
говорится, что нужно сделать вот это, но я смог добиться практически того же резуль­
тата, сделав по-другому, но затратил на это вдвое меньше времени". Ясно, что вы не
обязаны вносить изменения, но у вас не было бы и намека на эту возможность, если
бы ваши действия сдерживались конструкцией, изобилующей предписаниями.
Будучи прагматиком, вы должны стремиться рассматривать сбор требований,
проектирование и реализацию как различные ипостаси одного процесса — по­
ставки заказчику качественной системы. Не воспринимайте в изоляции друг от
друга те среды, в которых происходит сбор требований, составление специфика­
ций и создание программ. Вместо этого постарайтесь принять "бесшовную" техно­
логию: спецификация и реализация просто являются разными аспектами одного и
того же процесса — попыткой зафиксировать и кодифицировать некое требова­
ние. Каждый из этих аспектов должен плавно переходить в другой без искусствен­
ных границ. Вы обнаружите, что в здоровом процессе разработки поощряется об­
ратная связь, идущая от реализации и тестирования к процессу составления
спецификации.
Поймите нас правильно, мы не против искусственного генерирования специфика­
ций. Разумеется, мы признаем, что в ряде случаев необходимы невероятно подробные
спецификации — в силу причин, обусловленных контрактом, из-за операционной
системы, в которой вы работаете, или природы самого продукта, разработкой которо­
го вы занимаетесь'. Просто осознайте, что, по мере того как спецификации становят­
ся все более подробными, их доходность начинает убывать, а то и уходит в минус. Кро­
ме того, будьте осторожны при составлении многослойных спецификаций, нижние
уровни которых не обеспечены реализацией или прототипами; слишком легко соста­
вить спецификацию того, что невозможно построить.
Чем дольше вы будете позволять спецификациям оставаться защитной оболочкой,
предохраняющей разработчиков от кошмарного мира составления программ, тем
сложнее будет перейти к решению задач, возникающих при составлении программ.
Не окажитесь в этой спирали спецификации: в некоторой точке вам придется начать
программирование! Если ваша команда будет облачена в теплые, удобные специфи­
кации, разорвите эти оковы. Подумайте о создании прототипов или о разработке с ис­
пользованием метода "стрельбы трассирующими".
Другие разделы, относящиеся к данной теме:
•
Стрельба трассирующими
Подробные спецификации, несомненно, подходят для систем жизнеобеспечения. Очевид­
но, что эти спецификации составляются для интерфейсов и библиотек, используемых дру­
гими пользователями. Если результаты в целом представляют собой набор стандартных
вызовов, лучше убедиться в том, что эти вызовы строго определены.

Перед тем, как начать проект
199
Вопросы для обсуждения
•
Пример с завязыванием шнурка бантиком, приведенный в данной главе, яв­
ляется интересной иллюстрацией проблем, связанных с письменным изло­
жением. Вы не думали о том, что лучше описывать процесс блок-схемами, а
не словами? Фотографиями? С помощью некой формальной системы обо­
значений, взятой из топологии? При помощи модели с проволочными шнур­
ками? Как бы вы научили ребенка завязывать шнурки?
Иногда от одного рисунка больше пользы, чем от любого количества слов.
Если вы замечаете, что ваша'спецификация чрезмерна, можно ли призвать
на помощь рисунки или специальную систему обозначений? Насколько под­
робными они обязаны быть? В каких случаях лучше использовать наглядное
средство, а не лекционную доску?
40 Круги и стрелки
[Фотографии
j с кругами и стрелками
и
несколькими
строками
на обратной
стороне,
объясняющими,
кто есть кто, должны были
стать
свидетельством
против
нас...
Арло Гатри, Ресторан
Алисы
Начиная со структурного программирования, минуя бригады главного программиста,
CASE-средства, разработку методом "водопада", спиральную модель, метод Джексо­
на, диаграмму "сущность-связь", облака Буча, метод объектного моделирования, ме­
тод Objectory, метод Коуда/Йордона, и до современного языка UML информатика ни­
когда не страдала от недостатка методов, стремившихся уподобить программирование
инженерной дисциплине. Каждый метод имеет своих приверженцев, и каждый из них
переживает период популярности. Затем ему на смену приходит следующий. Долгая
жизнь была суждена возможно лишь одному из всех этих методов — структурному
программированию.
И все же некоторые разработчики, дрейфуя в море тонущих проектов, продолжа­
ют цепляться за последний "пунктик", подобно тому как жертвы кораблекрушения
хватаются за проплывающее мимо бревно. Когда к ним подплывает другой обломок,
то они, испытывая мучения, доплывают до него, надеясь, что уж он-то будет получше.
Хотя, в конце концов, качество обломка не имеет особого значения — разработчики
дрейфуют все так же бесцельно.
Поймите нас правильно. Нам нравятся (некоторые) формальные методики и мето­
ды. Но мы полагаем, что слепое следование любой методике без рассмотрения ее в
контексте практики разработки программ и ваших возможностей является лучшим
рецептом для разочарования.
Подсказка 58
Не будьте рабом формальных методов

200
Глава 7
Формальные методы имеют ряд серьезных недостатков.
•
Большинство формальных методов фиксируют требования, используя соче­
тание диаграмм и нескольких пояснительных фраз. На этих рисунках показа -
но, как проектировщик понимает требования. Однако в многих случаях для
конечных пользователей эти диаграммы бессмысленны, поэтому они нужда­
ются в их интерпретации проектировщиками. Следовательно, в реальности
формальная проверка требований со стороны фактического пользователя
отсутствует — все основывается на объяснениях проектировщика, как и в
старомодных письменных требованиях. В этом способе фиксирования тре­
бований есть определенная польза, но мы предпочитаем, если это возможно,
предоставить в распоряжение пользователя некий прототип и дать ему с ним
поиграться.
•
Похоже, что формальные методы поощряют специализацию. Одна группа
людей работает над моделью данных, другие занимаются архитектурой, в то
время как сборщики требований коллекционируют сценарии использования
(или их эквивалент). Мы видели, как это приводило к плохому взаимодейст­
вию и трате усилий впустую. Кроме того, существует тенденция впадать в
умонастроение типа "мы против них" — проектировщики против програм­
мистов. Мы же предпочитаем воспринимать систему, над которой мы рабо­
таем, целиком. Скорее всего, невозможно будет глубоко проникнуть в суть
каждого аспекта системы, но вы обязаны знать, как взаимодействуют между
собой компоненты, куда помещены данные и каковы требования.
•
Мы предпочитаем создавать настраиваемые динамичные системы, исполь­
зуя метаданные, позволяющие изменять характер приложений в ходе их вы­
полнения. Большинство современных формальных методов сочетают модель
статического объекта или данных с некоторой разновидностью механизма
построения диаграммы событий или процесса. Мы пока не встречали меха­
низм, который позволяет отображать динамизм, ожидаемый от систем. На
самом деле большинство формальных методов уводят в сторону, поощряя
ваше стремление к заданию статических отношений между объектами, кото­
рые должны быть связаны между собой динамически.
Какова отдача от методов?
В своей статье в журнале САСМ [Gla99b], написанной в 1999 г, Роберт Гласе сделал
обзор исследований улучшений в производительности и качестве, полученных благо­
даря семи различным технологиям разработки программ (технология 4GL, структур­
ные методики, CASE-средства, формальные методы, методология "чистой комнаты",
модели процессов и ООТ). Он сообщает, что первоначальное оживление, связанное
со всеми этими методами, было преувеличено. Хотя существуют указания на то, что у
некоторых методов есть преимущества, эти преимущества начинают проявляться
только после существенного снижения производительности и качества в период при­
нятия технологии на вооружение и обучения пользователей. Не стоит недооценивать

Перед тем, как начать проект
201
стоимость принятия новых инструментальных средств и методов. Подготовьтесь к
тому, что первые проекты с применением этих технологий будут предназначены для
учебных целей.
Должны ли мы использовать формальные методы?
Безусловно. Но не забывайте, что формальные методы разработки — это лишь
один инструмент из вашего арсенала. Если после тщательного анализа вы почув­
ствуете, что вам необходим формальный метод, то берите его на вооружение, но
помните, что несете ответственность. Никогда не становитесь рабом методологии,
ведь кружки и стрелки обедняют своих хозяев. Прагматики смотрят на методоло­
гии критическим взглядом, затем берут лучшее из каждой и преобразуют в набор
практических технологий, который улучшается каждый месяц. И это является кри­
тическим моментом. Вы должны постоянно работать над усовершенствованием
процессов. Никогда не делайте жесткие рамки методологии границами вашего
собственного мира.
Не подавайтесь ложному авторитету метода. Люди могут ходить на собрания, при­
нося с собой гектары бумаги с изображением диаграмм классов и сто пятьдесят сце­
нариев использования, но вся эта макулатура — лишь их ошибочная интерпретация
требований и конструкции. Старайтесь не думать о том, сколько стоит тот или иной
инструмент, глядя на результаты его работы.
Подсказка 59
Дорогие инструменты не всегда создают лучшие решения
Конечно, в разработке программ есть место формальным методам. Однако, столк­
нувшись с проектом, философия которого заключается в изречении "диаграмма клас­
са и есть приложение, все остальное — лишь механическое составление текста про­
граммы", знайте, что имеете дело с проектной командой, которая уцепилась за
плавучее бревно и медленно гребет к берегу.
Другие разделы, относящиеся к данной теме:
•
Карьер для добычи требований
Вопросы для обсуждения
•
Диаграммы сценариев использования являются частью процесса UML при
сборе требований (см. "Карьер для добычи требований"). Являются ли они
эффективным способом взаимодействия с вашим пользователями? Если
нет, то почему вы их используете?
•
Как вы можете объяснить пользу, которую приносит формальный метод ва­
шей команде? Чем вы можете ее измерить? В чем состоит улучшение? Мо-

202
Глава 7
жете ли вы провести различие между пользой от инструментального средст­
ва и возросшим опытом сотрудников вашей команды?
•
Где расположена точка безубыточности при внедрении новых методов в ва­
шей команде? Как можно оценить компромисс между пользой, приносимой в
будущем, и текущими потерями в производительности в период внедрения
нового инструментального средства?
•
Годятся ли инструментальные средства, применяемые в крупномасштабных
проектах, для малых проектов? Верно ли обратное?

Глава 8
Прагматические
проекты
Поскольку вы уже работаете над проектом, нам придется отойти от вопросов, связан­
ных с личностной философией и написанием программ, чтобы поговорить о более
серьезных вещах в масштабах проекта. Мы не собираемся углубляться в специфику
руководства проектами, а рассмотрим несколько критических областей, которые спо­
собны создать или разрушить любой проект.
Как только число сотрудников, работающих на проектом, превышает единицу, вам
приходится устанавливать некие основные правила и делегировать части проекта со­
ответствующим образом. В разделе "Команды прагматиков" мы покажем, как это
можно делать, соблюдая принципы прагматической философии.
Единственным и самый важным фактором, придающим последовательность и на­
дежность процессам на уровне проекта, является автоматизация процедур. В разделе
"Вездесущая автоматизация" мы объясним, почему это именно так, и приведем неко­
торые примеры из реальной жизни.
Выше говорилось о тестировании в ходе написания программ. В разделе "Безжа­
лостное тестирование" мы переходим на следующую ступень философии и инстру­
ментов, применяемых в масштабе проекта, в особенности, если нет отдела контроля
качества, находящегося у вас на побегушках.
Единственная вещь, которую разработчики не любят больше, чем тестирова­
ние, — это документация. Независимо от того, есть ли у вас технические писате­
ли, помогающие вам, или вы пишете документацию сами, мы покажем вам в разде­
ле "Все эти сочинения", как сделать эту работу менее болезненной и более
продуктивной.
Успех проекта находится перед глазами наблюдателя — спонсора проекта. Вос­
приятие успеха — это самое главное, и в разделе "Большие надежды" мы покажем
вам некоторые хитрости, чтобы порадовать сердце любого спонсора проекта.
Последней подсказкой в этой книге является прямое следствие всех остальных.
В разделе "Гордость и предубеждение"-мы поощряем вас подписывать свою работу, и
гордиться тем, что вы делаете.

204
Глава 8
41 Команды прагматиков
В группе L Стоффел руководит
шестью
пер­
воклассными
программистами
— это
руково­
дящая работа,
которую
можно приравнять
к
управлению
бродячими
котами.
Журнал "Washington Post" от 9 июня 1985 г.
Пока в этой книге мы рассматривали прагматические методики, которые помогают
отдельной личности стать лучшим программистом. Могут ли эти методы работать и в
приложении к командам?
Отвечаем на это громким "да!" В личностном прагматизме есть свои преимущест­
ва, но эти преимущества преумножаются, если личность работает в команде прагма­
тиков.
В этом разделе мы кратко рассмотрим, как прагматические методики могут при­
меняться к целым командам. Эти замечания — лишь начало. Как только собирается
команда разработчиков-прагматиков, которые работают в среде, предоставляющей
определенные возможности, они быстро развивают и совершенствуют свою собст­
венную командную динамику, работающую на них.
Рассмотрим некоторые из предыдущих разделов с точки зрения команд.
Никаких разбитых окон
Качество является прерогативой команды. Для самого прилежного разработчика, по­
павшего в команду, которая безразлична к работе, окажется сложным сохранять эн­
тузиазм, необходимый для устранения проблем, требующих кропотливости. Про­
блемы будут только усугубляться, если команда активно отговаривает разработчика
не тратить время на устранение этих проблем.
Команды в целом не должны допускать наличия разбитых окон — этих маленьких
недостатков, которые никем не устраняются. Команда обязана взять на себя ответст­
венность за качество продукта, поддерживая разработчиков, исповедующих филосо­
фию "не живите с разбитыми окнами", которая описана в разделе "Энтропия в про­
граммах", и поощряя ее изучение теми, кто пока не открыл ее для себя.
В некоторых методологиях коллективной работы предусмотрен менеджер по каче­
ству — сотрудник, которому команда делегирует ответственность за качество продук­
та, отправляемого заказчику. Это просто смешно: качества можно достичь только в
результате индивидуальной лепты, вносимой каждым членом команды.
Сварившиеся лягушки
Помните несчастную лягушку, сидевшую в кастрюле с водой в разделе "Суп из кам­
ней и сварившиеся лягушки"? Она не заметила постепенного изменения в окружаю­
щей среде и в конце концов сварилась. То же самое может произойти с отдельными
личностями, которые теряют бдительность. Трудно уследить за общим состоянием
среды в разгаре работы над проектом.

Прагматические проекты
205
По сравнению с отдельной личностью команда может свариться значительно бы­
стрее. Люди предполагают, что кто-то другой занимается неким вопросом, или что ру­
ководитель команды наверняка одобрил изменение, которое просил внести пользова­
тель. Даже самые целеустремленные группы могут не обращать внимания на
существенные изменения, происходящие с их проектами.
Боритесь с этим. Убедитесь, что каждый активно отслеживает изменения в со­
стоянии среды. Может быть, стоит нанять "ответственного за состояние воды". Этот
сотрудник должен постоянно следить за увеличением сферы покрытия, уменьшением
масштабов времени, дополнительными средствами, новыми средами — за всем тем,
чего на было в первоначальном соглашении. Сохраняйте метрики по новым требова­
ниям (см. раздел "Еще одна мелочь..."). Команде не придется наотрез отказываться от
изменений — просто надо знать, что они происходят. В противном случае лягушкой в
горячей воде окажетесь именно вы.
Общайтесь
Очевидно, что разработчики в группе должны разговаривать друг с другом. В раз­
деле "Общайтесь" даны некоторые советы для облегчения подобного общения.
Однако не забывайте, что сама по себе команда находится в рамках определенной
организации. Команде как субъекту приходится четко взаимодействовать с осталь­
ным миром.
Для посторонних худшими проектными командами являются те, которые кажутся
угрюмыми и чересчур сдержанными. Они проводят бессистемные встречи, на которых
никто не хочет выступать. Их документы — сплошная путаница, среди них хотя бы
двух похожих, и каждый разработчик пользуется своей терминологией.
Лучшие проектные команды обладают ярко выраженной индивидуальностью.
Люди ожидают встреч с ними, поскольку знают, что увидят хорошо подготовленную
презентацию, от которой всем станет лучше. Производимая ими документация отли­
чается четкостью, точностью и последовательностью. В команде нет разноголосицы
1.
У нее даже может быть чувство юмора.
В маркетинге существует простой трюк, помогающий командам взаимодейство­
вать как одно целое: создание брэнда. Когда вы начинаете некий проект, придумайте
имя для проектной команды, в идеале — нечто из ряда вон выходящее. (В прошлом
мы называли проекты в честь попугаев-киллеров, охотящихся на овец, оптических
обманов и мифических городов). Потратьте полчаса на придумывание самого идиот­
ского логотипа, и используйте его в ваших служебных записках и отчетах. В разгово­
рах с людьми свободно упоминайте название вашей команды. Это звучит глупо, но оно
придает вашей команде некую самобытность, а миру — что-то запоминающееся, с
чем можно ассоциировать вашу работу.
В команде нет разногласий — но это только внешне. Внутри же команды поощряются
оживленные серьезные дискуссии. Хорошие разработчики склонны быть страстными, ко­
гда речь идет об их работе.

206
Глава 8
Не повторяйте самого себя
В разделе "Пороки дублирования" говорилось о трудностях, связанных с устранением
дублирования работы, выполняемой членами команды. Это дублирование ведет к
тому, что усилия тратятся впустую и все выливается в кошмарные ситуации при со­
провождении. Ясно, что здесь нужо четкое взаимодействие, но в ряде случаев необхо­
димо приложить и дополнительные усилия.
Некоторые команды включают в свой состав библиотекаря проекта, который не­
сет ответственность за координацию документации и хранение текстов исходных про­
грамм. Другие члены команды могут использовать этого сотрудника в качестве "исти­
ны в последней инстанции", когда они занимаются поиском чего-либо. Хороший
библиотекарь также способен предсказать возникновение дублирования, прочитав
материал, с которым они работают.
Если проект слишком велик для одного-единственного библиотекаря (или никто
не хочет брать на себя его функции), назначьте несколько человек "фокусными точка­
ми" различных функциональных аспектов работы. Если кто-то хочет обговорить тему
обработки даты, он знает, что по этому вопросу нужно обращаться к Мэри. Если же
речь идет о базе данных, то следует обращаться к Фреду.
И не забудьте о значении программного обеспечения для коллективной работы и
локальных телеконференциях в сети Usenet для обмена информацией и создания ар­
хивов вопросов и ответов.
Ортогональность
Традиционная организация команды основана на устаревшем методе создания про­
граммного обеспечения, известного под названием "метода водопада". Отдельным
членам команды назначаются роли, основанные на их должностных обязанностях.
В команде имеются бизнес-аналитики, проектировщики, программисты, тестировщи-
ки, технические писатели и т.п.
1 В этом случае существует явная иерархия — чем
ближе вы допущены к конечному пользователю, тем выше ваше положение.
В стремлении довести все до крайности некоторые объединения разработчиков
диктуют строгое разграничение ответственности: тем, кто составляет программы, не
разрешено общаться с теми, кто их тестирует, а им, в свою очередь, не разрешено об­
щаться с главным архитектором и т.д. Некоторые организации еще более усложняют
задачу, заставляя различные подгруппы отчитываться через отдельные цепочки
управления.
Ошибочным является мнение о том, что действия при работе над неким проек­
том — анализ, проектирование, написание программы и тестирование — могут про­
исходить изолированно друг от друга. Такого не бывает. Это различные точки зрения
на одну и ту же проблему, и их искусственное разделение может вызвать целый ворох
проблем. Программисты, отделенные двумя или тремя уровнями от реальных пользо-
В книге "The Rational Unified Process: An Introduction" [Kru98] автор выделяет 27 отдель­
ных ролей в пределах проектной команды!

Прагматические проекты
207
вателей написанной ими программы, скорее всего, не знают о контексте, в котором
используется результат их труда. Они будут не в состоянии принять обоснованные ре­
шения.
Подсказка 60
Организуйте команду на основе функциональности,
а не должностных обязанностей
Мы одобряем разбиение команды исходя из функциональных возможностей.
Разделите ваших сотрудников на небольшие группы, каждая из которых будет нести
ответственность за конкретный функциональный аспект конечной версии системы.
Каждая группа обладает обязательствами перед другими группами, участвующими в
проекте, что определено их согласованными обязательствами. Строгий набор обя­
зательств изменяется с каждым новым проектом, как и распределение людей по
группам.
В данном случае функциональная возможность не обязательно означает сценарии
использования конечным потребителем программного продукта. Сюда относятся и
уровень доступа к базе данных, и справочная подсистема. Мы ищем сплоченные,
в большой степени самостоятельные коллективы людей, по тем же критериям, кото­
рые мы обязаны использовать при декомпозиции программы. Существуют признаки,
предупреждающие о том, что организация команды неверна; классическим примером
этого являются две подгруппы, работающие над одним и тем же программным моду­
лем или классом.
В чем же состоит польза от подобного функционального стиля организации? Ор­
ганизуя наши ресурсы, используя те же методики, что и при организации программы,
используя контракты (см. "Проектирование по контракту"), несвязанность (см. "Не­
связанность и закон Деметера") и ортогональность (раздел "Ортогональность"), мы
способствуем изоляции команды в целом от влияния изменений. Если пользователь
внезапно решится на замену поставщиков баз данных, то это скажется только на ко­
манде, занимающейся базами данных. Если отдел маркетинга внезапно примет реше­
ние об использовании готового средства календарного планирования, то это будет
ударом только для группы разработчиков средств календарного планирования. При
надлежащем исполнении подобный подход к группам может существенно снизить
число пересечений в работе отдельных личностей, снизить затраты времени, повы­
сить качество и уменьшить число дефектов. Этот подход помогает сделать команду
разработчиков более сплоченной. Каждая группа знает, что только они несут ответст­
венность за конкретную функцию.
Однако этот подход работает только при наличии ответственных разработчиков и
сильного руководства. Создать пул автономных групп и позволить им разбалтывать­
ся в отсутствие руководства — кратчайший путь к катастрофе. Проекту необходимы
как минимум два руководителя — один технический, другой административный.
Технический руководитель определяет философию и стиль разработки, распределя­
ет обязанности между группами и является арбитром в неизбежных "дискуссиях"
между членами команды. Он также осуществляет контроль за ситуацией в целом,

208
Глава 8
стараясь найти ненужную общность задач между группами, которая снижает орто­
гональность общих прилагаемых усилий. Административный руководитель, или ру­
ководитель проекта, намечает ресурсы, которые необходимы группам, контролирует
ход выполнения работ, отчитывается о проделанной работе и помогает в определе­
нии приоритетов с точки зрения потребностей бизнеса. Административный руково­
дитель может действовать и в роли полномочного представителя команды при обще­
нии с внешним миром.
Команды, выполняющие большие проекты, нуждаются в дополнительных ресур­
сах: библиотекаре, который упорядочивает и хранит тексты программ и документа­
цию, компоновщике инструментальных средств, обеспечивающем работоспособ­
ность обычных инструментальных средств и операционных сред, оперативную
поддержку и т.д.
Подобная организация команды напоминает старую концепцию "бригады главно­
го программиста", впервые описанную в 1972 г. [Вак72].
Автоматизация
Автоматизация является отличным способом обеспечить полноту и точность всего,
что делает команда. Зачем компоновать текст программы вручную, если ваш редактор
может делать это автоматически, пока вы набираете текст? Зачем заполнять форму­
ляры тестирования, если процедура сборки может осуществлять тестирование авто­
матически?
Автоматизация является существенным компонентом любой проектной коман­
ды — настолько важным для нас, что мы посвятили ей следующий раздел целиком.
Чтобы убедиться в том, что процессы автоматизированы, назначьте одного или
несколько членов группы компоновщиками инструментальных средств для конструи­
рования и развертывания средств, которые автоматизируют всю тяжелую работу.
Они будут создавать файлы сборки, сценарии оболочек, шаблоны редактирования,
вспомогательные программы и т.п.
Чувствуйте момент, когда нужно остановиться
Помните, что коллективы состоят из личностей. Дайте возможность каждому сотруд­
нику проявить себя во всем блеске. Создайте структуру, достаточную для их поддерж­
ки и выполнения проекта в соответствии с требованиями. Но затем, подобно живо­
писцу из раздела "Вполне приличные программы", не поддавайтесь искушению
добавить больше краски на холст.
Другие разделы, относящиеся к данной теме:
•
Энтропия в программах
•
Суп из камней и сварившиеся лягушки
•
Вполне приличные программы
•
Общайтесь

Прагматические проекты
209
•
Пороки дублирования
•
Ортогональность
•
Проектирование по контракту
•
Несвязанность и закон Деметера
•
Вездесущая автоматизация
Вопросы для обсуждения
•
Оглянитесь вокруг в поисках успешных команд, работающих вне сферы раз­
работки программного обеспечения. Каков фактор их успеха? Применяют
ли они какой-либо из процессов, описанных в данном разделе?
•
В следующий раз, когда вы начнете работать над проектом, постарайтесь
убедить людей, что проекту необходим брэнд. Дайте вашей организации вре­
мя, чтобы привыкнуть к этой мысли, и затем проведите быстрый аудит, что­
бы увидеть, изменило ли наличие брэнда что-нибудь как внутри команды, так
и в общении с внешним миром.
•
Командная алгебра: В школе мы решали задачи, наподобие этой: "Если че­
тырем рабочим требуется 6 ч на то, чтобы выкопать канаву, то сколько вре­
мени потребуется на это восьми рабочим?" Какие факторы из реальной жиз­
ни повлияют на ответ к задаче: "Если четырем программистам требуется
6 месяцев на разработку приложения, то сколько времени потребуется на
это восьми программистам?" Назовите число сценариев, в которых время на
разработку действительно сокращается.
42 Вездесущая автоматизация
Прогресс цивилизации
состоит
в
расширении
сферы действий,
которые мы
выполняем
не
думая.
Альфред Норт Уайтхед
На заре автомобильной эры инструкция по запуску автомобиля "Форд-Т" составляла
две с лишним страницы. В современных автомобилях достаточно лишь повернуть
ключ — процедура запуска является автоматической и надежной. Водитель, дейст­
вующий по инструкции, может "залить" свечи зажигания, а автоматический стартер
подобного не допустит.
Хотя информатика все еще напоминает автопромышленность времен выпуска мо­
дели "Форд-Т", мы не можем позволить себе в обычной работе раз за разом выпол­
нять набор инструкций, расположенный на двух страницах. Неважно, что это — про­
цедура сборки и выпуска готовой версии, рассмотрение текста программы или же
любая повторяющаяся задача, возникающая в ходе проекта, — все это должно вы­
полняться автоматически. Возможно, нам придется изготовить стартер и топливный

210
Глава 8
инжектор "с нуля", но, как только это будет сделано, с этого момента будет достаточ­
но лишь повернуть ключ зажигания.
Мы хотим также гарантировать полноту и повторяемость при работе над проек­
том. Процедуры, выполняемые вручную, не гарантируют полноту; повторяемость так­
же не гарантируется, особенно если аспекты конкретной процедуры открыты для ин­
терпретации другими людьми.
все в автоматическом режиме
Однажды мы посетили фирму-заказчик, где все разработчики использовали одну и ту
же интегрированную среду разработки. Их системный администратор снабжал каж­
дого разработчика набором инструкций по установке добавочных средств для этой
среды. Эти инструкции занимали много страниц — "щелкни мышью здесь, прокрути
туда, отбуксируй это, щелкни здесь мышью два раза, повтори".
Не удивительно, что компьютер у каждого из разработчиков загружался по-
своему. Когда разные разработчики прогоняли одну и ту же программу, в поведении
приложения проявлялись малозаметные отличия. Дефекты возникали на одной ма­
шине, а на других все было нормально. При прослеживании разницы в версиях любо­
го из компонентов обычно выявлялись неожиданные вещи.
Подсказка 61
Не используйте процедуры, выполняемые вручную
В отличие от компьютеров, люди не обладают повторяемостью в своих действиях.
Мы этого от них и не ждем. Сценарий оболочки или пакетный файл выполнят те же
самые инструкции, в том же порядке, раз за разом. Они могут отслеживаться систе­
мой управления исходным текстом, так что возможно изучать изменения в процедуре
и по прошествии времени ("но ведь она всегда работала ...").
Другим излюбленным средством автоматизации является сгоп (или "at" в системе
Windows NT). Он позволяет планировать периодический прогон задач без участия
пользователя — обычно этот прогон делается ночью. Например, представленный
ниже файл crontab указывает, что команда nightly, используемая в проекте, должна
запускаться каждый день в 00:05, что процедура резервного копирования backup
должна запускаться в 03:15 по будням и что команда expense_reports должна выпол­
няться в полночь первого числа каждого месяца.
# MIN HOUR DAY MONTH DAY0FWEEK COMMAND
#
5
0
*
*
*
/projects/Manhattan/bin/nightly
15
3
*
*
1-5
/usr/local/bin/backup
0
0
1
*
*
/home/accounting/expense_reports
С помощью cron мы можем планировать процедуры резервного копирования, со­
провождение web-сайтов и любых других операций, которые нужно проводить без
участия пользователя, т.е. автоматически.

Прагматические проекты
211
Компилирование проекта
Компилирование проекта — это работа, которая должна быть надежной и повто­
ряемой. Обычно мы компилируем проекты с помощью файлов сборки даже в интегри­
рованной среде разработчика. В использовании файлов сборки есть ряд преимуществ.
Это подготовленная по сценарию автоматическая процедура. Мы можем добавлять
специальные программные процедуры для генерации текста программы и запускать
регрессионные тесты в автоматическом режиме. Интегрированные среды имеют свои
преимущества, но, пользуясь только ими, бывает трудно добиться нужного нам уровня
автоматизации. Мы хотим осуществлять проверку, сборку, тестирование и передачу
программы заказчику с помощью одной-единственной команды.
Генерирование текста программы
В разделе "Пороки дублирования" мы призываем к генерированию тестов программ
для получения знания из обычных источников. Для облегчения этого процесса мы мо­
жем задействовать механизм анализа зависимости в программе make. Добавление пра­
вил в файл сборки для автоматической генерации файла из некоего другого источника
не представляет особой сложности. Например, предположим, что имеется некий файл
XML, из которого необходимо сгенерировать файл Java, а результат скомпилировать.
.SUFFIXES: J a v a .class .xml
.xml.Java:
perl convert.pl $<
> $@
.java.class:
$(JAVAC) $(JAVAC_FLAGS) $<
Наберем make t e s t . c l a s s , и программа make автоматически найдет файл с име­
нем test.XML, сформирует файл .java, выполнив сценарий Perl, а затем скомпилиру­
ет этот файл, создав t e s t . class.
Можно также использовать подобные правила также для автоматической генера­
ции исходного текста, файлов заголовка или документации из иной формы (см. "Гене­
раторы исходных текстов").
Регрессионные
тесты
Вы также можете воспользоваться файлом сборки для прогона либо регрессионных
тестов, либо отдельного модуля, либо подсистемы в целом. Вы легко можете протес­
тировать весь проект целиком при помощи одной-единственной команды на вершине
исходного дерева или же протестировать отдельный модуль, воспользовавшись той
же командой в единственном каталоге. Более подробно регрессионное тестирование
рассматривается в разделе "Безжалостное тестирование".
Рекурсивная сборка
Многие проекты устанавливают специальные рекурсивные иерархические
файлы для сборки проектов и тестирования. Но не забывайте о некоторых
потенциальных проблемах.

212
Глава 8
Программа make вычисляет зависимости между различными объектами, кото­
рые о н а д о л ж н а собрать. Но она может проанализировать только зависимо­
сти, существующие в п р е д е л а х одного-единственного обращения
к про­
грамме make. В частности,
рекурсивная
программа make не
о б л а д а е т
информацией о зависимостях, которые имеются у других обращений к про­
грамме make. Если вы будете осторожны и точны в своих действиях, то вы по­
лучите н а д л е ж а щ и е результаты, но при этом можно проделать много лишней
работы или проглядеть зависимость и не перекомпилировать е е , когда это
необходимо.
Кроме того, зависимости сборки могут отличаться от зависимостей тестиро­
вания, и вам могут понадобиться дополнительные
иерархии.
Автоматизация процесса
сборки
Сборка представляет собой процедуру, которая использует пустой каталог (и извест­
ную среду компиляции) и формирует проект с нуля, создавая то, что вы хотели бы ви­
деть в качестве конечного результата, отправляемого заказчику, например эталонный
лазерный диск или самораспаковывающийся архив. Обычно сборка проекта включа­
ет в себя следующие этапы.
1.
Исходный текст программы извлекается из архива.
2.
Проект формируется с нуля, обычно из файла сборки верхнего уровня. Каж­
дая сборка помечается определенным номером выпуска / версии или отмет­
кой даты.
3.
Создается копия для распространения. Эта процедура может повлечь за собой
фиксирование права собственности на файл и разрешения на его использова­
ние, создание всех примеров, документации, файлов README и всего того,
что будет отправлено вместе с готовым продуктом именно в том формате, кото­
рый требуется при передаче заказчику
1.
4.
Проведите указанные тесты (процедура make test).
Для большинства проектов этот этап сборки осуществляется автоматически каж­
дую ночь. "Ночная" сборка обычно выполняет больше полных тестов, чем отдельный
сотрудник при сборке определенной части проекта. Важным моментом является то,
что при полной сборке должны запускаться все тесты, имеющиеся в наличии. Вы хо­
тите убедиться в том, что программа не прошла регрессионный тест вследствие изме­
нений, которые были сделаны в программе сегодня. Идентифицируя проблему ближе
к источнику, вы с большей вероятностью сможете отыскать и устранить существую­
щую проблему.
Например, при записи компакт-диска в формате ISO9660 запускается программа, создаю­
щая побитовый образ файловой системы 9660. Стоит ли тянуть до последней минуты, что­
бы убедиться, что все нормально?

Прагматические проекты
213
Если вы не проводите тесты регулярно, то можете обнаружить, что приложение не
работает вследствие изменений, внесенных три месяца назад. Удачи вам — в поиске
этого изменения.
Окончательные
сборки
Окончательные
сборки, которые вы Намереваетесь отправить заказчику в виде го­
товых продуктов, могут предъявлять требования, отличающиеся от регулярной "ноч­
ной" сборки. Окончательная сборка может требовать, чтобы библиотека исходных
файлов была заблокирована или снабжена номером выпуска, чтобы флаги оптимиза­
ции и отладки были установлены по-другому, и т.д. Мы предпочитаем использовать
отдельный рабочий файл make (типа make final), который устанавливает все эти пара­
метры сразу.
Помните, что если компиляция продукта отличается от компиляции предыдущей
версии, то вы обязаны провести тестировании согласно этой версии заново.
Автоматические административные процедуры
Наверное, было бы недурно, если бы программисты могли реально посвящать все
свое время программированию. К сожалению, это бывает очень редко. Нужно отве­
чать на сообщения электронной почты, выполнять бумажную работу, помещать доку­
менты в Интернет и т.д. Вы можете решиться на создание сценария оболочки, кото­
рый будет делать всю грязную работу, но не забывайте запускать этот сценарий, когда
необходимо.
Поскольку память — это вторая по счету вещь, которую мы теряем с возрастом',
мы не хотим полагаться на нее слишком сильно. Мы можем запускать сценарии, ко­
торые будут выполнять для нас процедуры в автоматическом режиме, основываясь на
содержимом исходного текста программы и документов. Наша цель состоит в том,
чтобы поддерживать автоматическую, не требующую вмешательства пользователя
последовательность операций содержательного характера.
Генерирование
web-сайта
Многие команды разработчиков используют внутренний web-сайт для обмена инфор­
мацией в ходе выполнения проекта, и мы полагаем, что это прекрасная идея. Но мы не
хотим тратить много времени на поддержку web-сайта и мы не желаем, чтобы инфор­
мация, содержащаяся на нем, устаревала. Информация, вводящая в заблуждение,
хуже, чем отсутствие какой бы то ни было информации вообще.
Документация, извлекаемая из программы, анализа требований, проектных доку­
ментов и любых чертежей, графиков или диаграмм должна регулярно публиковаться
на web-сайте. Мы предпочитаем публиковать эти документы автоматически — что
А что же первое? Проклятый склероз.

214
Глава 8
является частью ночной процедуры сборки или добавочным блоком в процедуре воз­
вращения исходного текста программы в библиотеку.
Однако, если это сделано, содержание web-сайта должно генерироваться авто­
матически из информации, хранящейся в централизованной библиотеке, и публико­
ваться без вмешательства человека. На самом деле это еще одно применение прин­
ципа DRY: информация существует в одной форме — в виде исходного текста и
документов в библиотеке. При просмотре с помощью web-браузера они так и выгля­
дят — просто визуальное представление. Вам не придется поддерживать это пред­
ставление вручную.
Любая информация, сгенерированная в процессе ночной сборки, должна быть
доступна на web-сайте разработчиков: результаты самой сборки (они могут быть
представлены в виде краткого отчета на одной странице, содержащего предупрежде­
ния компилятора, ошибки и текущее состояние), регрессионные тесты, рабочая ста­
тистика, программные метрики, а также любые другие результаты статического ана­
лиза и т.д.
Административные
процедуры
утверждения
Некоторые проекты участвуют в административном документообороте, требования
которого необходимо соблюдать. Например, рассмотрение проекта или текста про­
граммы должно быть спланировано и доведено до конца, документы необходимо ут­
верждать и т.д. Мы можем использовать автоматизацию и — особенно это касается
web-сайта — облегчить бремя, налагаемое бумажной работой.
Предположим, что вы хотели автоматизировать планирование рассмотрения и
процедуру утверждения текста программы. В каждый файл с исходным текстом вы
могли бы поместить специальный маркер:
/*
Status:
needs_review
*/
Простой сценарий должен пройти весь исходный текст до конца и произвести по­
иск всех файлов, которые находились в состоянии needs_review, которое указывало
на то, что они готовы к рассмотрению. Затем вы могли бы поместить список этих фай­
лов в виде web-страницы, автоматически послать электронную почту соответствую­
щим адресатам или даже назначить встречу, используя программу календарного пла­
нирования.
Вы можете организовать форму на web-странице, чтобы рецензенты регистри­
ровали свое утверждение или несогласие. После рассмотрения состояние может
быть автоматически изменено на reviewed. Использовать или не использовать
сквозной контроль текста программы всеми участниками — это зависит от вас; всю
бумажную работу вы можете проделывать автоматически независимо от этого.
(В своей статье в журнале САСМ (апрель 1999 г.) Роберт Гласе обобщает результа­
ты исследования, которое, похоже, указывает на то, что критическое рассмотрение
текста программы отличается эффективностью, в отличие от рассмотрения в ходе
собраний [Gla99a]).

Прагматические проекты
215
Дети сапожника
Дети сапожника всегда без сапог. Зачастую те, кто занимается разработкой про­
грамм, используют наихудшие инструментальные средства для выполнения своей
работы.
Но у нас имеются все исходные материалы для того, чтобы создать лучшие инстру­
менты. У нас есть программа сгоп. У нас есть программа make для платформ Windows
и Unux. У нас есть и Perl, а также другие языки сценариев высокого уровня для быст­
рой разработки заказных инструментальных средств, генераторов web-страниц, ис­
ходных тестов программ, тестовых стендов и т.д.
Дайте компьютеру делать скучную, земную работу — он сделает это лучше, чем
мы. У нас есть задачи поважнее и потруднее.
Другие разделы, относящиеся к данной теме:
•
Мой исходный текст съел кот Мурзик
•
Пороки дублирования
•
Сила простого текста
•
Игры с оболочками
•
Отладка
•
Генераторы исходных текстов
•
Команды прагматиков
•
Безжалостное тестирование
•
Все эти сочинения
Вопросы для обсуждения
•
Посмотрите на свои ежедневные действия. Есть ли у вас повторяющиеся
задачи? Набираете ли вы одну и ту же последовательность команд раз за ра­
зом? Попробуйте написать несколько сценариев оболочки для автоматиза -
ции процесса. Всегда ли вы щелкаете мышью по определенной последова­
тельности пиктограмм, повторяя эту операцию раз за разом? Можете ли вы
создать макрокоманды, которая будет это делать за вас?
•
Какая часть вашей бумажной работы, связанной с проектом, может быть ав­
томатизирована? Учитывая большие расходы на содержание штата програм­
мистов
1, определите, какая часть проектного бюджета тратится впустую на
административные процедуры. Можете ли вы обосновать временные затра­
ты на создание автоматизированного решения, основываясь на общей эко­
номии затрат, которая достигается при его внедрении?
Ориентировочно можно принять среднюю величину по отрасли равной 100 ООО долларов
надушу; в нее входят заработная плата, социальные выплаты, обучение, оборудование ра­
бочего места, накладные расходы и т.д.

216
Глава 8
43 Безжалостное тестирование
БОЛЬШИНСТВО разработчиков ненавидят тестирование. Они стремятся тестировать ос­
торожно, подсознательно ощущая, в каком месте программа может сбоить, и избегая
слабых мест. Но прагматики ведут себя по-другому. Мы обладаем мотивацией к оты­
сканию дефектов именно сейчас, чтобы нам не пришлось испытывать позор, когда
кто-то другой найдет наши ошибки позже.
Поиск дефектов можно уподобить ловле рыбы с помощью сети. Мы используем
мелкие, небольшие сети (модульные тесты) для ловли пескарей и большие, крупные
сети (комплексные тесты) для ловли акул-убийц. Иногда рыбе удается выскользнуть,
поэтому мы заделываем все найденные дыры в надежде поймать как можно больше
скользких дефектов, плавающих в бассейне нашего проекта.
Подсказка 62
Тестируйте раньше. Тестируйте часто. Тестируйте
автоматически
Как только у нас появляется текст программы, мы сразу хотим начать его тестиро­
вание. Крошечные пескарики имеют отвратительную привычку быстро становиться
огромными акулами-людоедами, а поймать акулу намного сложнее. Но мы не хотим,
чтобы нам пришлось осуществлять все это тестирование вручную.
Многие команды разрабатывают сложные планы тестирования своих проектов.
Иногда они даже их используют. Но мы обнаружили, что команды, использующие ав­
томатизированные процедуры тестирования, имеют больше шансов на успех. Тесты,
запускающиеся в ходе каждого процесса сборки, являются более эффективными по
сравнению с планами тестирования, которые лежат на полке.
Чем раньше обнаружен дефект, тем дешевле обходится его устранение. "Чуть-
чуть напишешь, чуть-чуть проверишь" — популярное изречение в мире Smalltalk
1, и
мы можем принять эту мантру как нашу личную, создавая одновременно (или даже
раньше) с написанием рабочей программы программу ее тестирования.
На самом деле удачный проект содержит больше программ тестирования, чем ра­
бочих программ. Временные затраты на написание тестовой программы себя оправ­
дывают. В конечном счете это оказывается намного дешевле, и вы действительно
имеете возможность создания практически бездефектного продукта.
Кроме того, осознание того, что вы прошли тест, дает вам большую степень уве­
ренности в том, что этот фрагмент программы "готов".
Подсказка 63
Программа не считается написанной, пока не пройдет
тестирование
На сайте extreme Programming [URL 45] эта концепция обозначена как "непрерывная ин­
теграция, безжалостное тестирование".

Прагматические проекты
217
Тот факт, что вы закончили работу.с фрагментом программы, вовсе не означает,
что можно идти к шефу или заказчику, чтобы сообщить ему о его "готовности". Фраг­
мент не готов. Прежде всего, программа в реальности никогда не бывает готовой.
И, что более важно, пока она не пройдет все имеющиеся тесты, вы не можете утвер­
ждать, что она может использоваться кем бы то ни было.
Необходимо рассмотреть три основных аспекта тестирования в масштабе всего
проекта: что тестировать, как тестировать и когда тестировать.
Что тестировать
Существует несколько видов процедур тестирования программного обеспечения ко­
торые вам приходится выполнять:
•
Модульное тестирование
•
Комплексное тестирование
•
Подтверждение правильности и верификация
•
Тестирование в условиях ресурсов, ошибки и их исправление
•
Тестирование производительности
•
Тестирование удобства использования
Этот перечень ни в коей мере не является полным, и в некоторых специализиро­
ванных проектах потребуются другие виды процедур тестирования. Но это дает нам
хорошую отправную точку.
Модульное
тестирование
Модульный
тест
представляет собой программу, которая занимается тестировани­
ем некоего модуля. Эта тема освещена в разделе "Программа, которую легко тести­
ровать". Модульное тестирование является основой для всех других видов тестирова­
ния, которые обсуждаются в данном разделе. Если части не работают по отдельности,
то скорее всего, они не будут хорошо работать и вместе. Все используемые вами мо­
дули обязаны пройти собственное модульное тестирование, перед тем как продолжать
работу.
Как только все соответствующие модули прошли индивидуальное тестирование,
вы готовы к новому этапу. Вам придется проверить, как модули используют друг друга
и взаимодействуют между собой по всей системе.
Комплексное
тестирование
Комплексное
тестирование
показывает, что основные подсистемы, из которых со­
стоит проект, работают и нормально взаимодействуют друг с другом. При наличии
удачных и хорошо проверенных контрактов обнаружить любые проблемы интеграции
не составляет особого труда. В противном случае, интеграция становится благодат­
ной почвой для размножения дефектов. Фактически в многих случаях она является
единственным и самым крупным источником дефектов в системе.

218
Глава 8
В реальности комплексное тестирование является продолжением модульного тес­
тирования, описанного выше — с той лишь разницей, что теперь вы проверяете, как
целые подсистемы соблюдают свои контракты.
Подтверждение
правильности и верификация
Как только в вашем распоряжении появляется рабочий пользовательский интерфейс
или прототип, вам приходится отвечать на существенный вопрос: пользователи сказа­
ли вам, что они хотели бы увидеть, но то ли это на самом деле?
Отвечает ли он функциональным требованиям системы? Это также нуждается в
тестировании. Бездефектная система, которая отвечает на неправильные вопросы, не
приносит много пользы. Необходимо осознавать схемы доступа конечного пользова­
теля и их отличие от тестовых данных разработчика (в качестве примера обратите
внимание на историю о рисовании кистью из раздела "Отладка").
Тестирование в условиях ресурсов,
ошибки
и их исправление
Теперь, когда вы понимаете, что система будет вести себя корректно в идеальных усло­
виях, вам придется испытать, как она ведет себя в реальных условиях. В реальном мире
ресурсы ваших программ не безграничны — они исчерпываются. Ваша программа мо­
жет столкнуться со следующими ограничениями:
•
Объем памяти
•
Объем дискового пространства
•
Мощность процессора
•
Тактовая частота
•
Скорость обмена с диском
•
Пропускная способность сети
•
Цветовая палитра
•
Разрешающая способность экрана
Вы можете реально проверить нехватку дискового пространства или объема памяти,
но как часто вы проверяете другие ограничения? Будет ли ваше приложение работать с
экраном при разрешении 640 х 480 и 256 цветами? Будет ли оно выполняться на экране
с разрешением 1600 х 1280 с 24-битным цветом, и при этом не быть размером с почто­
вую марку? Завершится ли пакетное задание до момента запуска программы архивации?
Вы можете обнаружить наличие ограничений в операционной среде, таких как
спецификация видеоподсистемы, и приспособиться к ним соответствующим образом.
Однако не все сбои являются восстановимыми. Если ваша программа обнаруживает
нехватку памяти, то вы ограничены в ваших действиях: вам не хватит ресурсов, чтобы
завершить программу способом, отличным от аварийного завершения.
Когда система выходит из строя
1, будет ли это делаться изящно? Постарается ли
она сделать лучшее, на что она способна в данной ситуации, — сохранить свое Co-
Редактор американского издания требовал изменить это предложение на "Если система
выходит из строя... ". Авторы сопротивлялись.

Прагматические проекты
219
стояние и предотвратить потерю данных? Или она выдаст пользователю сообщения
типа "Общая ошибка защиты" или "core dump" (отключение ядра системы)?
Тестирование
производительности
Тестирование производительности, нагрузочное тестирование или тестирование в ре­
альных условиях эксплуатации может также оказаться важным аспектом проекта.
Задайте себе вопрос, отвечает ли программа требованиям производительности в
условиях реального мира — с ожидаемым числом пользователей, подключений или
транзакций в единицу времени. Является ли она масштабируемой?
При работе с некоторыми приложениями вам может понадобиться специализиро­
ванная тестовая аппаратура или программное обеспечение для реалистической ими­
тации нагрузок.
Тестирование удобства
использования
Тестирование удобства использования отличается от процедур тестирования, обсуж­
денных выше. Оно осуществляется с реальными пользователями в реальных условиях
окружающей среды.
Рассмотрим удобство использования с точки зрения человеческого фактора. Име­
лись ли какие-либо недоразумения в ходе анализа требований, на которые необходимо
обратить внимание? Подходит ли программное обеспечение пользователю, становясь
продолжением его рук? (Мы не только хотим, чтобы не только наши собственные инст­
рументы были изготовлены по руке, но чтобы и те инструменты, которые мы создаем
для пользователи, подходили им).
Как и при подтверждении правильности и верификации, вам приходится осущест­
влять тестирование удобства использования как можно раньше, пока есть время на
внесение изменений. Для крупномасштабных проектов вы можете привлечь специа­
листов в области человеческого фактора.
Несоответствие критериям удобства использования является дефектом такого же
порядка, как деление на ноль.
Как проводить тестирование
Мы рассмотрели то, что подлежит тестированию. Теперь мы обратим внимание на то,
как это делается, включая следующее:
•
Регрессионное тестирование
•
Тестовые данные
•
Тестирование систем с графическим интерфейсом
•
Тестирование самих тестов
•
Исчерпывающее тестирование

220
Глава 8
Тестирование проектных решений/методологии
Можете ли вы провести тестирование проектных решений в с а м о й програм­
ме и методологии, которую вы использовали при с б о р к е программного
обеспечения? Некоторым образом вы можете. Вы д е л а е т е это, анализируя
метрики — измерения различных аспектов программы. С а м о й простой мет­
рикой (и чаще всего, наименее интересной) является число строк кода —
насколько велика с а м а программа?
Существует большое количество других метрик, которые вы можете исполь­
зовать для исследования
программы:
• Показатель цикломатической
сложности Маккейба
(измеряет
сложность
структуры решений)
• Коэффициент разветвления по входу при наследовании (количество базо­
вых классов) и по выходу (количество производных модулей; используется
в качестве родителя)
• Набор откликов ( с м . р а з д е л "Несвязанность и закон Д е м е т е р а " )
• Отношения связывания к л а с с а (см. [URL 48])
Некоторые
метрики
предназначены для того, чтобы дать вам "проходной
б а л л " , тогда как другие полезны только в сравнении. Это означает, что вы вы­
числяете метрики для каждого модуля в с и с т е м е и смотрите, как конкретный
модуль относится к своим братьям. З д е с ь обычно используются стандартные
статистические методики.
Если вы обнаруживаете модуль, чья метрика значительно отличается от всех
остальных, вам необходимо задать с е б е вопрос, приемлемо ли это. Для не­
которых модулей "нарушение х о д а кривой" может быть вполне
нормально.
Но для тех, у которых нет хорошего оправдания, это может свидетельство­
вать о потенциальных
проблемах.
Регрессионное
тестирование
Регрессионное тестирование сравнивает выходные данные текущего теста с результа­
тами (или известными значениями) предыдущих. Мы можем гарантировать, что дефек­
ты, устраненные сегодня, не нарушат ничего из того, над чем мы работали вчера. Это
важное средство страховки, и оно сокращает число неприятных сюрпризов.
Все тесты, о которых мы говорили до настоящего момента, могут запускаться как
регрессионные тесты с гарантией, что мы не откатываемся назад, когда разрабатыва­
ем новую программу. Мы можем запускать регрессии для тестирования производи­
тельности, контрактов, достоверности и т.д.
Тестовые данные
Где мы достаем данные для запуска всех этих тестов? Существуют только два типа
данных: реальные и синтезированные. В действительности нам необходимо использо-

Прагматические проекты
221
вать оба типа, поскольку различная природа этих типов данных будет способствовать
выявлению разных дефектов в нашем программном обеспечении.
Реальные данные исходят из некоторого реального источника. Возможно, они
были получены из существующей системы, конкурирующей системы или некоего
прототипа. Они представляют типичные пользовательские данные. Большие сюрпри­
зы возникают, как только вы открываете значение термина "типичный". При этом
скорее всего, являются дефекты и недоразумения в анализе требований.
Синтезированные данные генерируются искусственно, возможно, с определенны­
ми статистическими ограничениями. Вам могут понадобиться синтезированные дан­
ные по одной из следующих причин:
•
Вам необходимо много данных, возможно, больше, чем содержится в любом
из имеющихся образцов. Вы сможете использовать реальные данные в каче­
стве "саженца" для генерации большего набора данных и добиться уникаль­
ности определенных полей.
•
Вам необходимы данные для того, чтобы выделить определенные граничные
условия. Эти данные могут быть полностью синтезированными: поля данных
содержащих дату 29 февраля 1999 г., огромные размеры записей или адреса
с иностранными почтовыми индексами.
•
Вам необходимы данные, которые демонстрируют определенные статисти­
ческие свойства. Вы хотите увидеть, что случается, если сбой происходит с
каждой третьей транзакцией? Вспомните алгоритм сортировки, который за­
медляется и ползет, когда обрабатывает предварительно отсортированные
данные? Чтобы продемонстрировать эту слабость, вы можете представить
данные в случайном или упорядоченном виде.
Тестирование систем с графическим
интерфейсом
Тестирование систем, насыщенных графическими интерфейсами, часто требует на­
личия специализированных инструментальных средств. Эти средства могут основы­
ваться на простой модели захвата/воспроизведения данных или могут потребовать
специально для этой цели написанных сценариев для управления графическим ин­
терфейсом. Некоторые системы объединяют элементы обеих моделей.
Менее сложные инструментальные средства предписывают высокую степень свя­
зывания тестируемой версии программы и самого тестового сценария: если вы переме­
щаете диалоговое окно или уменьшаете размер экранной кнопки, процедура тестирова­
ния может не найти всего этого и оказаться неудачным. Большинство современных
инструментальных средств тестирования графических интерфейсов используют ряд ме­
тодик, чтобы обойти эту проблему и попытаться приспособиться к незначительным
различиям в компоновке.
Однако вы не можете автоматизировать все. Энди работал над графической систе­
мой, которая позволяла пользователю создавать и отображать недетерминированные
визуальные эффекты, которые моделировали различные природные явления. К сожа­
лению, в ходе тестирования нельзя просто захватить растровое изображение и срав­
нить с предыдущим прогоном, потому что приложение было спроектировано так, что

222
Глава 8
каждый раз оно выполнялось по-разному. В подобных ситуациях у вас может не быть
выбора, кроме как положиться на ручную интерпретацию результатов теста.
Одним из преимуществ, возникающих при написании несвязанной программы (см.
"Несвязанность и закон Деметера") является большая доля модульного тестирова­
ния. Например, для приложений, занимающихся обработкой данных, которые имеют
внешний графический интерфейс, конструкция должна быть несвязанной в достаточ­
ной степени, чтобы вы могли тестировать логику приложения в отсутствие
графи­
ческого интерфейса. Эта идея аналогична необходимости тестировать компоненты в
числе первых. Как только достоверность логики приложения была подтверждена, за­
дача по поиску дефектов, которые выявляются при наличии пользовательского интер­
фейса, не представляет труда (скорее всего, эти дефекты были созданы программой
интерфейса пользователя).
Тестирование самих тестов
Поскольку мы не можем писать совершенные программы, то из этого следует, что мы
не можем написать и совершенные программы для тестирования. Нам необходимо
проверять сами тесты.
Рассматривайте набор тестовых пакетов как сложную систему безопасности,
предназначенную для подачи звукового сигнала тревоги при выявлении дефекта.
Ведь нет лучшего способа проверки безопасности системы, как попытаться вло­
миться в нее?
После того как вы написали тест для обнаружения конкретного дефекта, вызовите
этот дефект преднамеренно и удостоверьтесь, что тест его обнаружил. Это гарантия
того, что тест обязательно выловит этот дефект в реальных условиях.
Подсказка 64
Используйте диверсантов для тестирования самих тестов
Если вы действительно серьезно относитесь к тестированию, то вы должны нанять
диверсанта
проекта, чья роль состоит в том, чтобы воспользоваться отдельной ко­
пией исходного дерева, преднамеренно внести дефекты и проверить, что при тестиро­
вании они будут выловлены.
При написании тестов убедитесь, что сигналы тревоги раздаются тогда, когда они
обязаны раздаваться.
Исчерпывающее
тестирование
Вы уверены в том, что ваши тесты являются корректными и обнаруживают созданные
вами дефекты. Но как вы узнаете о том, насколько исчерпывающе вы провели тести­
рование ядра программы?
Ответ здесь краток: "никак", вы никогда это не узнаете. Но на программном рынке
имеются продукты, которые могут вам помочь. Эти средства анализа степени покры­
тия отслеживают вашу программу при тестировании и регистрируют, какие строки

Прагматические проекты
223
были выполнены, а какие нет. Эти средства дают общее представление о том, на­
сколько исчерпывающей является ваша процедура тестирования, но не стоит ожи­
дать, что степень покрытия составит 100%.
Даже если выполненными окажутся все строки программы, это еще не все. Важно
то число состояний, в которых может находиться ваша программа. Состояния не яв­
ляются эквивалентом строк программы. Предположим, что есть функция, обрабаты­
вающая два целых числа, каждое из которых может принимать значение от 0 до 999.
int t e s t ( i n t a, int b) {
return a / (a + b)
}
Теоретически эта функция, состоящая из трех строк, имеет 1 ООО ООО логических
состояний, 999 999 из которых будут работать правильно, а одно — неправильно (ко­
гда а + b равно нулю). Если вам известно лишь то, что данная строка программы вы­
полнена, то вам придется идентифицировать все возможные состояния программы.
К сожалению, это очень сложная проблема. Настолько сложная, что "пока вы ее ре­
шите, солнце превратится в холодную глыбу".
Подсказка 65
Тестируйте степень покрытия состояний, а не строк текста
программы
Даже при высокой степени покрытия программы, данные, используемые вами в
процедуре тестирования, все еще оказывают огромное влияние, и, что более важно,
порядок, в котором вы выполняете программу, может оказать самое сильное воз­
действие.
Когда тестировать
Многие проекты стремятся отложить процедуру тестирования на последний мо­
мент — тот, когда оно будет срезано в преддверии контрольного срока

## Нам придется


начать тестирование намного раньше, чем наступит этот срок. Как только появится
какая-либо рабочая программа, ее необходимо протестировать.
Большинство процедур тестирования должно выполняться автоматически. Важно
заметить, что под термином "автоматически" мы имеем в виду и автоматическую ин­
терпретацию результатов теста. Более подробно этот аспект рассматривается в раз­
деле "Вездесущая автоматизация".
Мы предпочитаем проводить тестирование как можно чаще и всегда делаем это
перед возвращением исходного текста в библиотеку. Некоторые системы управления
В оригинале приводится толкование термина deadline — контрольный срок — в Webster's
Collegiate Dictionary: черта, проведенная вокруг тюрьмы (или в ее пределах), за которую
заключенный не имеет права выходить под страхом смерти.

224
Глава 8
исходным текстом, наподобие Aegis, могут осуществлять это автоматически. В других
случаях мы просто набираем
% make test
Обычно не представляет труда запускать регрессии на всех отдельных модульных
и комплексных тестах и проделывать это так часто, как это необходимо.
Но для ряда тестов частый прогон может представлять сложность. Для проведения
нагрузочного тестирования могут потребоваться специальные настройки или обору­
дование и некоторая часть ручной работы. Эти тесты могут проводиться с меньшей
частотой — возможно, еженедельно или ежемесячно. Но важно то, что они прогоня­
ются на регулярной, запланированной основе. Если это нельзя сделать автоматиче­
ски, то удостоверьтесь, что тесты включены в план вместе со всеми ресурсами, назна­
ченными для данной задачи.
Кольцо сжимается
И наконец, мы хотели бы раскрыть единственный и самый важный принцип в тести­
ровании. Он очевиден, и практически в каждом учебнике говорится о том, что это
должно делаться именно так. Но в силу некоторых причин в большинстве проектов
этого все еще не делается.
Если дефект проскальзывает через сеть существующих тестов, вам необходимо
добавить новый тест, чтобы поймать его в следующий раз.
Подсказка 66
Дефект должен обнаруживаться единожды
Как только тестировщик обнаружит дефект, это должно быть в первый и послед­
ний раз — когда дефект обнаруживается человеком. Автоматизированные тесты
должны быть модифицированы для проверки наличия этого дефекта, начиная с мо­
мента его первоначального обнаружения, всякий раз, без каких-либо исключений,
независимо от степени тривиальности, не обращая внимания на жалобы разработчи­
ка и его фразу "Этого больше не случится".
Потому что это снова случится. И у нас просто нет времени гоняться за дефектами,
которые автоматизированные тесты не могли обнаружить для нас. И нам придется
тратить время на написание новой программы — с новыми дефектами.
Другие разделы, относящиеся к данной теме:
•
Мой исходный текст съел кот Мурзик
•
Отладка
•
Несвязанность и закон Деметера
•
Реорганизация
•
Программа, которую легко тестировать
•
Вездесущая автоматизация

Прагматические проекты
225
Вопросы для обсуждения
•
Можете ли вы осуществить автоматическое тестирование вашего проек­
та? Многие команды вынуждены дать отрицательный ответ. Почему?
Слишком сложно определить приемлемые результаты? Не приведет ли
это к затруднениям, когда вы попытаетесь доказать спонсорам, что проект
"сделан"?
Сложно ли проверить логику приложения независимо от графического ин­
терфейса? Что можно сказать о графическом интерфейсе? О связывании?
44 Все эти сочинения
Лучше выцветшие
чернила,
чем отличная
память.
Китайская пословица
Как правило, разработчики не размышляют над документацией слишком долго.
В лучшем случае она является для них досадной необходимостью; в худшем случае она
считается задачей с низким приоритетом в надежде на то, что руководство забудет о
ней в конце работы над проектом.
Прагматики воспринимают документацию как неотъемлемую часть общего про­
цесса разработки. Написание документации может облегчено, если вы не дублируете
усилия, не теряете время попусту и держите документацию под рукой, а если это воз­
можно, — то в самой программе.
Эти мысли не отличаются оригинальностью и новизной; идея о брачном союзе
программы и документации к ней появляется уже в работе Доналда Кнута о грамот­
ном программировании и в утилите JavaDoc фирмы Sun. Мы хотим уменьшить про­
тиворечие между программой и документацией, и вместо этого считать их двумя ви­
зуальными представлениями одной и той же модели (см. "Всего лишь визуальное
представление"). На самом деле мы хотим пойти немножко дальше и применить все
наши прагматические принципы к документации так, как мы применяем их к про­
граммам.
Подсказка 67
Считайте естественный язык одним из языков
программирования
Существует два основных вида документации, которая готовится для проекта:
внутренняя и внешняя. Внутренняя документация включает комментарии исходных
текстов, документы, касающиеся проектирования и тестирования и т.д. Внешняя до­
кументация — это то, что отправляется заказчику или публикуется для внешнего
мира, например руководство пользователя. Но вне зависимости от целевой аудито­
рии, или роли автора (разработчик он или технический писатель), вся документация
является отражением программы. При наличии несоответствий программа — это то,
что имеет значение.

226
Глава 8
Подсказка 68
Встраивайте документацию в проект, а не накручивайте
ее сверху
Начнем с внутренней документации.
Комментарии в программе
Создать форматированные документы из комментариев и объявлений в исходном тек­
сте довольно просто, но вначале мы должны убедиться, что в тексте программы дейст­
вительно имеются комментарии. Программа должна иметь комментарии, но слишком
большое их количество может быть так же плохо, как и малое.
В общем, комментарии должны обсуждать, почему выполняется та или иная
операция, ее задачу и ее цель. Программа всегда демонстрирует, как это делается,
поэтому комментирование этого — избыточная информация и нарушение принци­
па DRY.
Создание комментариев в тексте исходной программы дает вам отличную возмож­
ность документировать неуловимые фрагменты проекта, которые не могут документи­
роваться где-либо еще: технические компромиссы, почему было принято то или иное
решение, какие альтернативные варианты были отвергнуты и т.д.
Мы предпочитаем увидеть простой
комментарий в заголовке (на уровне модуля),
комментарии к существенным данным и объявлениям типов и краткие заголовки для
каждого из классов и методов, описывающие, как используется именно эта функция и
все ее неочевидные действия.
Имена переменных должны выбираться четко и со смыслом. Например, имя
foo, не имеет смысла, также как doit или manager, или stuff. "Венгерский" стили
именования (в котором вы кодируете информацию о типе переменной в самом ее
имени) крайне нежелателен в объектно-ориентированных системах. Не забывай­
те, что вы (и те, кто идет за вами) будут читать
текст программы много сотен раз,
но писать
ее будут лишь несколько раз. Не торопитесь и напишите connection-
Pool вместо ср.
Имена, вводящие в заблуждение, еще хуже, чем бессмысленные. Приходилось ли вам
слышать, как кто-нибудь объясняет несоответствия в унаследованном тексте программы
типа: "Подпрограмма с именем getData на самом деле записывает данные на диск"? Че­
ловеческий мозг будет периодически все путать — это называется эффектом Струпа
[Str35]. Вы можете поставить на себе следующий эксперимент, чтобы увидеть эффекты
подобных помех. Возьмите несколько цветных ручек и напишите ими названия цветов
спектра. Но при этом название цвета должно быть написано только ручкой другого цвета.
Вы может написать слово "синий" зеленым цветом, слово "коричневый" — красным и
т.д. (В качестве альтернативы имеется набор цветов спектра, уже помещенный на наш
web-сайт www.pragmaticprogrammer.com). Как только вы написали названия цветов, по­
старайтесь как можно быстрее произнести вслух название цвета, которым написано каж­
дое слово,. В определенный момент вы собьетесь и станете читать имена цветов, а не
сами цвета. Имена очень важны для воспрятия, а имена, вводящие в заблуждение, вно­
сят беспорядок в программу.

Прагматические проекты
227
Вы можете документировать параметры, но задайте себе вопрос, а нужно ли это
делать во всех случаях. Уровень комментариев, предлагаемый средством JavaDoc, ка­
жется весьма приемлемым:
J * *
* Найти пиковое
(наивысшее)
значение
в указанном
интервале
* дат
* §param
aRange
Range of dates
to search
for
data.
* eparam
aThreshold
Minimum
value
to
consider.
* @return
the value,
or <code>null<code>
if
no value
found
* greater
than
or equal
to the
threshold.
*/
public Sample findPeak(Date Range aRange, double aThreshold);
Вот перечень того, чего не должно быть в комментариях к исходному тексту про­
граммы.
•
Перечень функций, экспортируемых программой в файл. Существуют
программы, которые анализируют исходный текст. Воспользуйтесь ими, и
этот перечень никогда не устареет.
•
Хронология изменений. Для этого предназначены системы управления ис­
ходным текстом программы (см. "Управление исходным текстом"). Однако
будет полезно включить информацию о дате последнего изменения и сотруд­
нике, который внес это изменение'.
•
Список файлов, используемых данным файлом. Это можно определить бо­
лее точно при помощи автоматических инструментальных средств.
•
Имя файла. Если оно должно указываться в файле, не поддерживайте его
вручную. Система RCS и ей подобные могут обновлять эту информацию ав­
томатически. При перемещении и удалении файла вам не хочется вспоми­
нать о необходимости редактирования заголовка.
Одним из наиболее важных фрагментов информации, который обязан появится в
исходном файле, — это имя автора, не обязательно того, кто осуществлял последнюю
редакцию, но имя владельца. Приложение обязательств и ответственности к исходно­
му тексту программы творит чудеса, сохраняя людей честными (см. "Гордость и пре­
дубеждение").
Проект также может потребовать наличия определенных ссылок на авторские
права или других юридических стереотипов в каждом исходном файле. Сделайте так,
чтобы программа редактирования вставляла эти элементы автоматически.
При наличии осмысленных комментариев, инструментальные средства, подобные
JavaDoc [URL 7] и D O C + + [URL 21 ], могут извлекать и форматировать их для авто­
матического создания документации на уровне API. Это является одним из конкрет­
ных примеров более универсальной методики, которой мы пользуемся, —
исполняе­
мые
документы.
Информация подобного рода, как и имя файла, дается тегом RCS $ld$.

228
Глава 8
Как быть, если мой документ не хранится в формате
простого текста?
К сожалению, в настоящее время все больше проестной документации с о ­
ставляется с помощью текстовых процессоров, сохраняющих ф а й л на д и с к е
в некоем определенном формате. Мы говорим "к сожалению", потому что
это существенно ограничивает возможности автоматической обработке до­
кумента. Но у в а с в з а п а с е есть е щ е д в а варианта:
• Создавайте макрокоманды. В настоящее время большинство многофунк­
циональных текстовых процессоров содержит встроенные макроязыки. З а ­
тратив некоторое усилие, вы можете запрограммировать их таким о б р а ­
зом, чтобы экспортировать
отмеченные
разделы ваших документов в
альтернативные формы, которые вам необходимы. Если программирова­
ние на таком уровне является для в а с болезненной процедурой, вы всегда
можете экспортировать соответствующий р а з д е л в файл, имеющий стан-
Более подробно модели и преставления рассмотрены в разделе "Всего лишь визуальное
представление".
Исполняемые документы
Предположим, что имеется спецификация, которая перечисляет столбцы в таблице
базы данных. Тогда мы получим отдельный набор команд SQL для создания реальной
таблицы в базе данных и, по всей вероятности, некую структуру записи на языке про­
граммирования для хранения содержимого строки в таблице. Одна и та же информа­
ция повторяется три раза. Стоит изменить один из этих трех источников — и два дру­
гих немедленно устареют. Это явное нарушение принципа DRY.
Для решения этой проблемы необходимо выбрать авторитетный источник инфор­
мации. Это может быть спецификация, инструментальное средство для построения
схем баз данных или некий третий источник. Выберем в качестве источника специфи­
кацию. Теперь она является моделью нашего процесса. Тогда нам необходим способ
экспортирования информации, содержащейся в нем, в виде различных визуальных
представлений — к примеру, в виде схемы базы данных и записи на языке програм­
мирования высокого уровня
1.
Если ваш документ хранится в виде простого текста вместе с командами описа­
ния документов (например, в виде HTML, LATgX или troff), то в этом случае вы мо­
жете использовать такие инструментальные средства, как Perl, для извлечения схе­
мы и ее автоматического переформатирования. Если ваш документ хранится в
двоичном формате текстового процессора, то некоторые варианты действий приво­
дятся во врезке ниже.
Теперь ваш документ — неотъемлемая часть разработки проекта. Единственным
способом изменения схемы является изменение документа. Вы гарантируете, что спе­
цификация, схема и программа находятся в согласии. Вы сводите к минимум работу,
которую необходимо выполнить для внесения каждого изменения, и можете обнов­
лять визуальные представления изменений автоматически.

Прагматические проекты
229
дартный формат простого текста, а затем воспользоваться инструменталь­
ным с р е д с т в о м наподобие Perl для преобразования его в окончательную
форму.
• Сделайте документ подчиненным. Вместо того, чтобы использовать доку­
мент в качестве определяющего источника, используйте другое представ­
ление. В примере с базой данных, вы хотели бы использовать с х е м у в каче­
стве
авторитетной
информации.
Тогда
с о з д а й т е
средство,
которое
экспортирует эту информацию в ту форму, которую документ может им­
портировать.
О д н а к о
при
этом будьте внимательны. Вы должны
быть
уверены, что э т а информация импортируется всякий раз, когда документ
выводится на печать, а не единожды, при создании этого документа.
Аналогичным образом можно генерировать документацию на уровне API из исход­
ного текста программы, пользуясь инструментальными средствами, такими как
JavaDoc и DOC+ + . Моделью является исходный текст программы: компилироваться
может одно визуальное представление модели; другие представления предназначены
для вывода на печать или просмотра на web-странице. Нашей целью всегда является
работа над моделью (неважно, является ли эта модель самой программой или же
каким-либо иным документом), и мы должны добиться того, чтобы все эти представ­
ления обновлялись автоматически (см. "Вездесущая автоматизация").
Внезапно документация оказывается не столь уж плохой.
Технические писатели
До этого момента мы говорили лишь о внутренней документации, которую составля­
ют сами программисты. Но что происходит, если в вашем проекте участвуют профес­
сиональные технические писатели? Слишком часто программисты просто "перекиды­
вают" материал техническим писателям и дают им возможность заработать себе на
жизнь, создавая руководства пользователей, рекламные материалы и т.д.
Это является ошибкой. То, что программисты не составляют такие документы, во­
все не означает, что мы можем поступиться прагматическими принципами. Мы хотим,
чтобы писатели восприняли те же основные принципы, что и прагматики, — соблю­
дали принципы DRY, ортогональности, концепцию "модель-визуальное представле­
ние", применяли автоматизацию и сценарии.
Печатать документ или ткать его на холсте?
Издаваемой бумажной документации присуща одна проблема: она может устареть, пока
будет напечатана. Документация в любой ее форме — лишь моментальный снимок.
Поэтому мы стараемся создавать всю документацию в форме, которая может быть
помещена в информационную сеть, на web-страницу вместе в гиперссылками. Это
представление документации легче сохранять в обновленном виде, нежели отслежи-

230
Глава 8
вать все существующие бумажные экземпляры, уничтожать их и распространять об­
новленные версии. Это также является лучшим способом обращения к нуждам широ­
кой аудитории. Однако не забывайте помещать дату или номер версии на каждой web-
странице. В этом случае читатель может разобраться, что соответствует текущему
моменту, что изменилось недавно, а что осталось неизменным.
Во многих случаях вам приходится представлять одну и ту же документацию в раз­
личных форматах: в печатном, в виде web-страницы, экранной справки, а может быть,
и в виде слайд-шоу. Обычное решение в большой степени полагается на технологию
"вырезать и вставить" и на создание нескольких независимых документов из одного
оригинала. Это неудачная идея: представление документа не должно зависеть от его
содержания.
Если вы пользуетесь системой описания документов, то обладаете гибкостью, что­
бы реализовать столько различных выходных форматов, сколько вам нужно. Вы мо­
жете использовать:
<Hl>Chapter
Title</H1>
для генерации новой главы в отчетной версии документа и названия нового слайда в
слайд-шоу. Можно воспользоваться технологиями типа XSL и CSS
1 для генерирова­
ния множественных выходных форматов из этого описания.
Если вы используете текстовый процессор, то, по всей вероятности, будете распо­
лагать аналогичными возможностями. Если вы не забывали использовать стили для
идентификации различных элементов документа, то, применяя различные таблицы
стилей, вы можете существенным образом изменить внешний вид окончательного ре­
зультата. Большинство текстовых процессоров теперь позволяет конвертировать до­
кументы в форматы типа HTML для публикации на web-сайтах.
Языки разметки
Мы рекомендуем рассмотреть некоторые из современных схем описания документа­
ции для крупномасштабных проектов по документированию.
Многие авторы, пишущие на технические темы, используют в настоящее время
средство DocBook для описания своих документов. DocBook представляет собой
стандарт описания документов на основе SGML, который тщательно идентифицирует
каждый компонент в документе. Документ можно обрабатывать процессором DSSSL,
для его преобразования в любое число различных форматов. Проект документации
Linux использует DocBook, для представления информации в форматах RTF, TgX,
info, Postscript и HTML.
Пока ваше первоначальное описание достаточно насыщено, чтобы выразить все
концепции, которые вам необходимы (включая гиперссылки), перевод в любую дру­
гой форму публикации не составит труда и будет выполняться автоматически. Вы мо­
жете создавать интерактивную справку, руководства, описание основных свойств
продукта для помещения на web-сайт и даже календарь с ежедневными советами —
все из одного и того же источника, который находится в системе управления исходным
Технологии XSL и CSS были разработаны для отделения представления от содержимого.

Прагматические проекты
231
текстом и собирается в ходе процедуры ночной сборки основной программы (см.
"Вездесущая автоматизация").
Документация и программа — это различные визуальные представления одной и
той же основополагающей модели, но лишь визуальные представления имеют право
разниться. Не позволяйте документации превращаться в гражданина второго сорта,
которому запрещено участвовать в основном документообороте проекта. Обращай­
тесь с документацией так же бережно, как вы обращаетесь с программой, и пользова­
тели (а также сотрудники службы сопровождения) будут петь вам осанну.
Другие разделы, относящиеся к данной теме:
•
Пороки дублирования
•
Ортогональность
•
Преимущества простого текста
•
Управление исходным текстом
•
Всего лишь визуальное представление
•
Программирование в расчете на стечение обстоятельств
•
Карьер для добычи требований
•
Вездесущая автоматизация
Вопросы для обсуждения
•
Приходилось ли вам писать пояснительный комментарий для исходного тек­
ста программы, который вы только записали? Почему нет? Не было време­
ни? Вы не уверены, что программа действительно работает — вы пробуете
некую идею в виде прототипа? Впоследствии вы выбросите эту программу,
не правда ли? Ведь при этом она не попадет в проект без комментариев и в
экспериментальном виде, не так ли?
•
Иногда неудобно документировать проектное решение исходного текста
программы, поскольку это решение вам не совсем ясно — оно еще на стадии
развития. Вы полагаете, что не должны тратить свои усилия впустую, описы­
вая как работает что-то, еще до того, как оно действительно начинает рабо­
тать. Не похоже ли это на программирование в расчете на стечение обстоя­
тельств? (См. одноименный раздел.)
45 Большие надежды
Подивитесь
сему, небеса, и
содрогнитесь,
и ужаснитесь,
говорит
Господь.
Иеремия (2,12)
Компания объявляет о рекордной прибыли, а цена ее акций падает на 20%. Вечерняя те­
лепрограмма финансовых новостей объясняет, что компания не удалось оправдать наде-

232
Глава 8
жды аналитиков. Ребенок открывает дорогой рождественский подарок — и в слезы: там
нет дешевой куклы, на которую он так надеялся. Проектная команда творит чудеса, реа­
лизуя феноменально сложное приложение, и лишь для того, чтобы получить ушат воды
со стороны пользователей, поскольку в системе отсутствует справка.
В абстрактном смысле приложение успешно, если оно корректно реализует свои
спецификации. К сожалению, это и оплачивается лишь абстрактно.
В действительности успех проекта измеряется тем, насколько он соответствует на­
деждам своих пользователей. Проект, который не оправдывает их надежд, обречен на
неудачу, неважно, насколько хорошо он соответствовал срокам. Однако, подобно ро­
дителям ребенка, ожидающего дешевую куклу, вы заходите слишком далеко и терпите
неудачу.
Подсказка 69
Слегка превышайте надежды ваших пользователей
Однако выполнение этой подсказки требует некоторых усилий.
Передача надежд
Пользователи обычно приходят к вам с некоторым видением того, чего они хотят. Оно
может быть неполным, противоречивым или технически невыполнимым, но оно при­
надлежит им, и, подобно ребенку в Рождество, они вкладывают в него некоторые
эмоции. Вы не можете просто проигнорировать их видение.
По мере того как вы осознаете потребности потребителей, вы обнаруживаете об­
ласти, в которых вы не сможете удовлетворить их требования, или те области, где их
требования слишком консервативны. Ваша роль частично заключается в передаче
этого состояния. Работайте со своими пользователями так, чтобы их понимание того,
что вы им поставляете, было точным. И этим необходимо заниматься на протяжении
всего процесса разработки. Никогда не теряйте из виду те бизнес-задачи, которые
предполагается решать с помощью вашей программы.
Некоторые консультанты называют этот процесс "управление ожиданиями" —
активное управление тем, что пользователи надеются получить от их систем. Мы по­
лагаем, что это несколько высокомерная позиция. Наша роль заключается не в том,
чтобы управлять надеждами наших пользователей. Необходимо работать с ними, что­
бы прийти к общему пониманию процесса разработки и конечного результата, наряду
с теми ожиданиями, которые еще не выражены словами. Если команда свободно об­
щается с внешним миром, то этот процесс практически автоматизирован; все должны
понять, что ожидается и как это будет построено.
Существует ряд важных методик, которые могут использоваться для облегчения
этого процесса. Из них наиболее важными являются "Стрельба трассирующими" и
"Прототипы и памятные записки". Обе позволяют команде конструировать то, что
может увидеть пользователь. Обе являются идеальными способами передать ваше
понимание требований пользователей, обедают возможность вам и вашим пользова­
телям практиковаться в общении друг с другом.

Прагматические проекты
233
Небольшой довесок
Если вы работаете в тесном взаимодействии с вашим пользователями, разделяя их
надежды и сообщая им о том, что вы делаете, то при завершении проекта практически
не возникнет ряд сюрпризов.
ЭТО ПЛОХО. Постарайтесь удивить ваших пользователей. Заметьте себе, их не
надо пугать, их надо
восхищать.
Дайте им немного больше, чем они ожидают. Небольшое усилие, которое потре­
буется, чтобы добавить в систему некое средство, ориентированное на пользователя,
окупится доброжелательностью не одни раз.
Прислушивайтесь к вашим пользователям в ходе работы над проектом, чтобы по­
лучить намеки на те средства, которые действительно могут их восхитить. Вот некото­
рые средства, которые вы можете добавить без особого труда и которые порадуют
среднего пользователя:
•
Всплывающая подсказка
•
"Горячие" комбинации клавиш
•
Краткое справочное руководство в качестве дополнения к руководству поль­
зователя
•
Расцвечивание
•
Анализаторы журнала регистрации
•
Автоматическая инсталляция
•
Инструментальные средства проверки целостности системы
•
Возможность запускать несколько версий системы в целях тренировки
•
Экран-заставка, настроенный для фирмы-заказчика
Все эти вещи относительно поверхностны и особо не нагружают систему. Однако
каждый из этих "довесков" говорит пользователям о том, что команда разработчиков
позаботилась о создании отличной системы, предназначенной для использования в ре­
альной жизни. Просто не забывайте о том, что работа системы не должна быть рас­
строена этими нововведениями.
Другие разделы, относящиеся к данной теме:
•
Неплохие программы
•
Стрельба трассирующими
•
Прототипы и памятные записки
•
Карьер для добычи требований
Вопросы для обсуждения
•
Иногда самыми жесткими критиками проекта являются те, кто над ним рабо­
тал. Случалось ли вам испытывать разочарование, когда ваши собственные
надежды не были оправданы тем, что вы создали? Как это могло произойти?
Может быть, здесь присутствует нечто большее, чем логика.

234
Глава 8
•
Что говорят ваши пользователи, когда вы доставляете им готовую програм­
му? Пропорционально ли их внимание к различным аспектам данной про­
граммы усилиям, которые вы в эти аспекты вложили? Что их восхищает?
Прагматики не уклоняются от ответственности. Вместо этого они испытывают радость,
принимая вызовы и распространяя свой опыт. Если мы несем ответственность за проект­
ное решение или фрагмент программы, мы делаем работу, которой можем гордиться.
Подсказка 70
Ставьте вашу подпись под работой
В прошлом мастеровые гордились, подписывая свою работу. Вы должны следо­
вать их примеру
Проектные команды все еще состоят из людей, и это вызывает сложности. В некото­
рых проектах идея о монопольных правах на программу может вызывать трения. Люди
могут начать обособляться или не выказывать желания работать над общими фундамен­
тальными элементами. Проект может закончиться феодальной раздробленностью. У вас
возникнут предубеждения относительно и вашей программы, и ваших коллег.
Этого-то мы и не хотим. Вы не должны ревниво защищать свою программу от тех,
кто вторгается в ее пределы; вы должны платить людям той же монетой и относиться
к программам других разработчиков с уважением. Золотое правило "Поступай с дру­
гими так, как бы ты хотел, чтобы они поступали с тобой" и взаимоуважение среди раз­
работчиков является критическим для действия подсказки, приведенной выше.
Анонимность, особенно при работе с крупномасштабными проектами, может ока­
заться благодатной почвой для небрежности, ошибок, лени и неудачных программ.
Слишком легко рассматривать себя лишь в качестве винтика в большой машине, вы­
сказывая неубедительные извинения в бесконечных отчетах о состоянии, а не просто
создавая хорошие программы.
Хотя у программы должен быть владелец, он не обязательно является физическим
лицом. Успешный метод eXtreme Programming [URL 45], разработанный Кентом Бе­
ком, рекомендует коллективную собственность на программу (но это требует дополни­
тельных процедур типа парного программирования в целях защиты от анонимности).
Мы хотим, чтобы вы гордились правом собственности. "Я это написал, и я стою за
своей работой". Ваша подпись должна стать признанным знаком качества. Люди долж­
ны увидеть ваше имя в заголовке программы и рассчитывать на то, что она будет солид­
ной, хорошо составленной, проверенной и документированной. Это должна быть поис­
тине профессиональная работа. Написанная настоящим профессионалом своего дела.
Программистом-прагматиком.
46 Гордость и предубеждение
Вы восхищали
нас довольно
долго.
Джейн Остин, Гордость
и
предубеждение

Приложение А
Информационные
ресурсы
Авторы затронули в книге весьма широкий круг вопросов программирования, и этому
есть объяснение: вопросы рассматривались с высоты птичьего полета. Но если бы им
было уделено то внимание, которого они заслуживают, то объем книги стал бы боль­
ше на порядок.
Книга начинается с утверждения, что программисты-прагматики должны постоян­
но учиться. В данном приложении приводится перечень источников информации, ко­
торые могут им в этом поспособствовать.
В разделе "Профессиональные общества" приведены координаты IEEE (Institute
of Electrical and Electronical Engineers — Институт инженеров по электротехнике и
радиоэлектронике) и ACM (Association of Computing Machinery — Ассоциация по
вычислительной технике). Мы рекомендуем программисту-прагматику вступить в
ряды одного (или обоих) из этих обществ. Ниже, в разделе "Собираем библиотеку",
указаны периодические издания, книги и интернет-сайты, которые содержат высоко­
качественную и ценную информацию (или просто-напросто забавны по своему содер­
жанию).
В книге содержится много ссылок на программные ресурсы, доступные через Ин­
тернет. В разделе "Интернет-ресурсы" приводятся их адреса (URL) с кратким описа­
нием. Но в силу природы Интернета многие из них могут устареть к моменту выхода
книги в свет. Для того чтобы найти более свежие ссылки, можно воспользоваться од­
ной из поисковых систем, или же посетить наш интернет-сайт: www.pragmatic-
programmer.com и просмотреть соответствующий раздел.
И наконец, в приложении содержится библиографический список .

236
Приложение А
Профессиональные общества
У программистов существует два профессиональных объединения мирового уровня:
Association of Computing Machinery — ACM
1 (Ассоциация по вычислительной техни­
ке) и Institute of Electrical and Electronical Engineers — IEEE
2 (Компьютерное обще­
ство института инженеров по электротехнике и радиоэлектронике). Всем програм­
мистам рекомендуется вступить в одно (или оба) из этих обществ. Кроме того,
разработчики, проживающие вне США, пожелают вступить в соответствующие на­
циональные объединения (примером может служить British Computer Society —
BCS — Британское компьютерное общество).
Члены профессиональных обществ пользуются рядом преимуществ. Конференции
и собрания дают возможность общения людям с общими интересами, а специальные
секции и технические комитеты позволяют участвовать в выработке стандартов и ре­
комендаций, используемых во всем мире. Многое можно почерпнуть из их публика­
ций, в которых ведутся "высоколобые" дискуссии по практическим вопросам и "при­
земленные" разговоры по компьютерной теории.
Собираем библиотеку
Мы серьезно относимся к чтению книг. Как было замечено в разделе "Портфель зна­
ний", хороший программист учится постоянно. Постоянное нахождение программи­
ста в курсе выходящих книг и периодики способствует такому обучению.
Периодические
издания
Люди, подобные авторам книги, хранят старые журналы и периодику до тех пор, пока
вес стопки не будет достаточен для превращения нижних экземпляров в алмаз. Вот
некоторые периодические издания, рекомендуемые авторами.
•
IEEE Computer. Рассылается по подписке членам Компьютерного общества
института инженеров по электротехнике и радиоэлектронике. Этот журнал
сосредоточен на практических аспектах, но не чужд и теории. Некоторые но­
мера посвящены конкретной тематике, другие же представляют собой про­
сто сборники интересных статей. Говоря языком связистов, журнал облада­
ет хорошим соотношением "сигнал-шум".
•
IEEE Software. Не менее ценная публикация Компьютерного общества ин­
ститута инженеров по электротехнике и радиоэлектронике, издаваемая раз в
два месяца и нацеленная на программистов-практиков.
•
Communications of the ACM. Основной журнал, получаемый всеми члена­
ми Ассоциации по вычислительной технике, на протяжении десятилетий яв­
ляется отраслевым стандартом и опубликовал больше основополагающих
статей, чем любой другой источник.
1
ACM Member Services, РО BOX 11414, New York, NY 19286, USA •=> www.acm.org
2
1730 Massachusetts Avenue NW, Washington, DC 20036-1992, USA => www.acm.org

Информационные ресурсы
237
•
S1GPLAN. Журнал выпускается секцией языков программирования, входя­
щей в ассоциацию АСМ, распростаняется среди членов АСМ. В нем часто
публикуются спецификации языков программирования, наряду с тематиче­
скими статьями для всех, кто любит "копать вглубь".
•
Dr. Dobbs Journal. Ежемесячный журнал, распространяемый по подписке и
продающийся в киосках. Этот журнал непрост для восприятия, но его статьи
охватывают как практические аспекты, так и чистую теорию.
•
The Perl Journal. Поклонникам Perl стоит подписаться на этот журнал
(www.tpj.com).
•
Software Development Magazine. Ежемесячный журнал, посвященный общим
вопросам управления проектами и разработки программного обеспечения.
Еженедельные профессиональные
издания
Существует несколько еженедельных газет, издаваемых для разработчиков и менед­
жеров. Эти газеты в основном представляют собой сборники фирменных пресс-
релизов, перекроенных в статьи. Тем не менее, их содержание представляет цен­
ность — оно позволяет быть в курсе событий, не пропускать объявления о выходе но­
вых продуктов и следить за возникновением и распадом отраслевых альянсов. Но от
них не стоит ожидать наличия глубоко проработанных технических материалов.
Книги
Книги по компьютерной тематике весьма дороги, но при тщательном выборе они ста­
новятся хорошим вложением денег. Вот некоторые книги, понравившиеся авторам:
Анализ и
проектирование
ш Object-Oriented
Software
Construction,
второе
издание.
Эпическое
произведение Бертрана Мейера, посвященное основам объектно-ориенти­
рованного программирования, общим объемом 1300 страниц. [Меу97Ь].
•
Design Patterns.
Конструктивный шаблон описывает метод решения кон­
кретного класса задач на более высоком уровне по сравнению с фразеоло­
гизмом на языке программирования. Эта неоклассическая книга [GHJV95],
написанная "бандой четырех" (группа авторов Erich Gamma, Richard Helm,
Ralph Johnson и John Vlissides. — Прим. пер.) содержит описание 23 базо­
вых конструктивных шаблонов, включая шаблоны Proxy, Visitor и Singleton.
•
Analysis
Patterns.
Сокровищница высококлассных архитектурных шабло­
нов, выбранных из множества реальных проектов и переработанных в виде
книги. Относительно быстрый способ перенимания опыта моделирования,
полученного в течение многих лет [Fow96].

238
Приложение А
Команды и проекты
•
The Mythical
Man Month. Классическое произведение (не так давно пере­
работанное) Фреда Брукса, о "подводных камнях", появляющихся в ходе ор­
ганизации команд разработчиков [Вго95].
•
Dynamics
of Software
Development.
Серия коротких очерков о разработ­
ке программного обеспечения в больших командах, сосредоточенных на ди­
намике взаимодействия членов команды между собой, а также между самой
командой и внешним миром [МсС95].
•
Surviving
Object-Oriented
Projects:
A Manager's
Guide. "Вести с перед­
него края", сообщенные Алистером Кокбэрном, иллюстрируют многие
опасности и ловушки, подстерегающие Вас при управлении объектно-ори­
ентированным проектом, особенно если этот ваш первый проект. Г-н Кок-
бэрн дает подсказки и методики, позволяющие читателю решать наиболее
общие проблемы [Сос97Ь].
Среды
программирования
•
Unix. У. Р. Стивене написал несколько прекрасных книг, включая "Advanced
Programming in the Unix Environment" и "Unix Network Programming"
[Ste92, Ste98, Ste99].
•
Windows. Книга Маршалла Брэйна "Win32 System Services" [Bra95] являет­
ся кратким справочником по низкоуровневым интерфейсам прикладных про­
грамм. Труд Чарльза Петцольда "Programming Windows" [Pet98] стал своего
рода Библией для разработчиков графических сред пользователя Windows.
•
С + + . Получив проект на языке С + + , нужно бежать (не идти) в книжный
магазин и хватать книгу Скотта Мейерса под названием "Effective С+ + ", и к
ней, возможно, книгу "More Effective С + + " [Меу97а, Меу96]. При построе­
нии систем существенных размеров может понадобиться книга Джона Лако-
са "Large-Scale С + + Software Design" [Lak96]. В поисках более сложных
методик стоит обратиться к труду Джима Коплина под названием "Advanced
С + + Programming Styles and Idioms" [Сор92].
Кроме того, книги из серии Nutshell издательства O'Reilly (www.ora.com) дают
оперативное и всестороннее освещение разнообразных тем и языков, таких как perl,
уасс, sendmail, внутренней организации Windows и регулярных выражений.
Интернет
Найти в Интернете нужную информацию трудно. Вот несколько ссылок, которые
проверяются авторами как минимум раз в неделю.
•
Slashdot. Под заголовком "News for nerds. Stuff that matters" (Новости для
дебилов. Материал со значением) скрывается один из крупнейших сайтов
сообщества Linux. Помимо регулярно обновляемых новостей из мира Linux
сайт предлагает информацию по модным технологиям и проблемам, которые
волнуют разработчиков.
•Ф www.slashdot.org

Информационные ресурсы
239
•
Cetus Links. Тысячи ссылок на тему объектно-ориентированного програм­
мирования.
•=> www.cetus-links.org
•
WikiWikiWeb. Центральная база данных шаблонов и обсуждение шаблонов
(в Портленде, США). Не являясь особо выдающимся ресурсом, данный сайт
представляет собой интересный эксперимент по коллективному редактиро­
ванию идей.
О www.c2.com
Интернет-ресурсы
Приведенные ниже ссылки на ресурсы, доступные в Интернете, были действительны
во время работы над книгой, но (Сеть есть Сеть!) к моменту выхода ее в свет могут
сильно устареть. В этом случае можно попробовать общий поиск по именам файлов
или же зайти на сайт Pragmatic Programmer (www.pragmaticprogrammer.com) и про­
верить имеющиеся на нем ссылки.
Текстовые
редакторы
Emacs и vi — не единственные межплатформенные редакторы, но они распространя­
ются бесплатно и находят широкое применение. Пролистав любой специализирован­
ный журнал (например, Dr. Dobbs), можно найти ряд коммерческих альтернатив вы­
шеуказанным редакторам.
Редактор
Emacs
Редакторы Emacs и XEmacs имеют версии как для платформы Unix, так и для
Windows.
[URL
1] Редактор Emacs
•=> www.gnu.org
Новейший "крупнокалиберный"' редактор, обладающий всеми возможностями сво­
их предшественников. Кривая обучения Emacs почти вертикальна, но вас ждет щед­
рое вознаграждение по мере овладения тонкостями работы. Редактор также содер­
жит отличную программу чтения почты и новостей, адресную книгу, календарь и
дневник, приключенческую игру...
[URL 2] Редактор XEmacs
•=> www.xemacs.org
Отпочковавшись от классического редактора Emacs несколько лет назад, XEmacs от­
личается более корректными внутренними командами и более изящным интерфейсом.
Редактор vi
Существует как минимум 15 различных клонов редактора vi. Редактор vim переносит­
ся на большинство платформ и является хорошим выбором при работе в различных
программных средах.
[URL 3] Редактор Vim

240
Приложение А
•=> f t p : / / f t p . f u - b e r l i n . de/misc/editors/vim
Цитата из документации: "Редактор vi содержит большое количество усовершенст­
вований: многоуровневая отмена команд, многооконный интерфейс с буферами, вы­
деление синтаксиса, редактирование в командной строке, дополнение имен файлов,
экранная справка, визуальный выбор объектов и т.д.)
[URL 4] Редактор elvis
•=>
www.fh-wedel.de/elvis
Усовершенствованный клон редактора vi с поддержкой X.
[URL 5] Emacs Viper Mode
•=> http://www.cs.sunysb.edu/"kifer/emacs. html
Viper представляет собой набор макрокоманд, которые придают редактору Emacs
внешнее сходство с редактором vi. Некоторые могут поставить под сомнение разум­
ность шага, заключающегося в расширении самого большого редактора в мире с це­
лью эмулирования другого редактора, характерной чертой которого является ком­
пактность. Другие, напротив, считают, что он объединяет в себе лучшее из двух
цивилизаций — Emacs и vi.
Компиляторы, языки программирования и средства
разработки
[URL 6] The GNU C / C + + Compiler
о
www.fsf.org/software/gcc/gcc.html
Один из наиболее популярных в мире компиляторов С и С++. Он также работает с
Objective-C. (Во время работы над книгой проект egcs, который вначале отпочко­
вался от gcc, находился в процессе воссоединения с последним.)
[URL 7] The Java Language from Sun
•=> java.sun.com
Домашняя страница Java, включающая загружаемые SDK, документацию, средства
обучения, новости и т.д.
[URL 8] Perl Language Home Page
•=> www.perl.com
Эти ресурсы, относящиеся к языку Perl, предоставляются фирмой O'Reilly.
[URL 9] The Python Language
•=> www.python.com
Объектно-ориентированный язык программирования Python является интерпрети­
руемым и интерактивным, обладает хитроумным синтаксисом и большим количест­
вом верных поклонников.
[URL 10] SmallEiffel
S m a l l E i f f e l . l o r i a . f r

Информационные ресурсы
241
Компилятор GNU Eiffel работает на любом компьютере, снабженном компилятором
ANSI С и средой выполнения Posix.
[URL 11] ISE Eiffel
<=> www.eiffel.com
Фирме Interactive Software Engineering принадлежит авторство программы Design
by Contract; она реализует на коммерческой основе компилятор Eiffel и сопутствую­
щие инструментальные средства.
[URL 12]Sather
•=> w w w . i c s i . b e r k e l e y . e d u / ~ s a t h e r
Sather является экспериментальным языком программирования, ведущим свое про­
исхождение от Eiffel. Его задачей является поддержка функций высшего порядка и
итерационной абстракции, а также Common Lisp, CLU или Scheme и быть таким же
эффективным, как С, С + + или Fortran.
[URL 13]VisualWorks
•=> www.objectshare.com
Основной ресурс для среды VisualWorks Smalltalk. Некоммерческие версии для
Windows и Linux распространяются бесплатно.
[URL 14] The Squeak Language Environment
•=> h t t p : / / s q u e a k . c s . u i u c . e d u
Squeak представляет собой бесплатно распространяемую и переносимую реализа­
цию — Smalltalk-80, написанную на Squeak; может генерировать код на С для по­
вышения производительности.
[URL 15] The TOM Programming Language
=> www.gerbil.org/tom
Весьма динамичный язык, ведущий свое начало от Objective-C.
[URL 16] The Beowulf Project
•=> www.beowulf.org
Проект посвящен построению высокопроизводительных компьютеров из сетевых
кластеров, состоящих из недорогих Linux-блоков.
[URL 17] iContract — Design by Contract Tool For Java
О
www.reliable-systems.com
Данное инструментальное средство использует формализм предварительных усло­
вий, выходных условий и инвариантов; реализовано в виде препроцессора для Java.
Использует наследование, реализует кванторы существования и многое другое.
[URL 18] Nana — Logging and Assertions for С and С + +
<=> www. c s . ntu, edu.au/homepages/pjm/nana-home/index, html
Улучшенная поддержка проверки утверждений и регистрации в С и С + + . Nana так­
же обеспечивает некоторую поддержку для программы Design by Contract.

242
Приложение А
[URL 19] D D D — Data Display D e b u g g e r
•=> www.cs.tu-bs.de/softech/ddd
Бесплатный графический интерфейс конечного пользователя для отладчиков Unix.
[URL 20] John Brant's Refactoring Browser
•=> st-www. cs. uiuc.edu/users/brant/Refactory
Популярный браузер применяемый при реорганизации (язык Smalltalk).
[URL 21] D O C + + Documentation Generator
•=> www. zib.de/Visual/software/doc++/index. html
D O C + + представляет собой систему документирования для C / C + + и Java, кото­
рая генерирует выходные файлы в форматах L A T E X и HTML для утонченного про­
смотра документации непосредственно из заголовка С+ + или файлов класса Java.
[URL 22] xUnit — Unit Testing Framework
•=> www.Xprogramming.com
Представляя простую, но мощную концепцию, модуль тестирования структур xUnit
является полной платформой для тестирования программного обеспечения, напи­
санного на нескольких языках.
[URL 23] The Tel Language
•=> www.scriptics.com
Язык Tel (Tool Command Language) является языком сценариев, разработанным
для упрощения процедуры встраивания в приложение.
[URL 24] Expect — Automate Interaction with Programs
expect.nist.gov
Расширение expect, построенное на языке Tel [URL 23], позволяет создавать сце­
нарии взаимодействия с программами. Помимо помощи при составлении команд­
ных файлов, которые, например, осуществляют вызов файлов с удаленных серве­
ров или расширяют возможности оболочки, expect приносит пользу и при
регрессионном тестировании. Графическая версия expectk позволяет переносить
по словам приложения неграфического интерфейса пользователя при работе с
оконным интерфейсом.
[URL 25] Т Spaces
•=> www.almaden.ibm.com/cs/TSpaces
Цитата с web-страницы: "Т Spaces представляет собой сетевой коммуникационный
буфер с функциональными возможностями баз данных. Он осуществляет связь ме­
жду приложениями и устройствами в сети с гетерогенными компьютерами и опера­
ционными системами. Т Spaces обеспечивает следующие средства: коллективной
связи, работы с базами данных, переноса файлов (основанные на URL) и оповеще­
ния о событиях".
[URL 26] javaCC — Java Compiler-Compiler
•=> www.suntest.com
Генератор грамматического разбора, связанный с языком Java.

Информационные ресурсы
243
[URL 27] The bison Parser Generator
•=> www.gnu. o r g / s o f t w a r e / b i s o n / b i s o n , html
Генератор bison получает на входе описание грамматики и генерирует из него исход­
ный текст соответствующей программы грамматического разбора на языке С.
[URL 28] SWIG — Simplified Wrapper and Interface Generator
•=> www.swig.org
SWIG представляет собой инструментальное средство разработки, стыкующее ме­
жду собой программы, написанные на языках С, С + + и Objective-C, с языками вы­
сокого уровня, такими как Perl, Python, Tcl/Tk, а также Java, Eiffel и Guile.
[URL 29] The Object Management Group, Inc.
•=> www.omg.org
Фирма Object Management Group, Inc. является "распорядителем" различных спе­
цификаций для разработки распределенных объектно-базирующихся систем. К чис­
лу работ этой фирмы относятся CORBA (обобщенная архитектура брокера объект­
ных запросов) и НОР (протокол передачи сообщений между сетевыми объектами
через Интернет). Сочетание этих спецификаций дает возможность объектам связы­
ваться друг с другом, даже если они написаны на разных языках и выполняются на
компьютерах различных типов.
Инструментальные
средства UNIX, работающие
в среде DOS
[URL 30] The UWIN Development Tools
О
www.gtlinc.com/Projects/Uwin.html
Фирма Global Technologies, Inc., Old Bridge, NJ
Пакет UWIN предоставляет библиотеки динамической компоновки (DLL) Windows,
которые эмулируют большую часть библиотечного интерфейса уровня Unix С. Ис­
пользуя данный интерфейс, фирма Global Technologies, Inc перенесла большое чис­
ло инструментальных средств из командной строки Unix в систему Windows. См.
также ссылку [URL 31 ].
[URL 31 ] The Cygnus Cygwin Tools
www.sources.cygnus.com/cygwin/
Фирма Cygnus Solutions, Sunnyvale, CA
Пакет Cygnus также эмулирует интерфейс библиотеки Unix С и предоставляет
большой набор инструментальных средств, работающих в режиме командной строки
Unix, при работе в операционной системе Windows.
[URL 32] Perl Power Tools
•=> www.perl.com/language/ppt/
Данный проект посвящен повторной реализации классического набора команд Unix
на языке Perl, что дает возможность их использования при работе со всеми платфор­
мами, поддерживающими Perl (их довольно много).

244
Приложение А
Средства управления исходным текстом программ
[URL 33] RCS — Revision Control System
>=> www.cyclic.com
Система управления исходным текстом программ GNU для Unix и Windows NT.
[URL 34] CVS — Concurrent Version System
•=> www.cyclic.com
Система управления исходным текстом программ для Unix и Windows NT, распро­
страняемая бесплатно. Расширяет возможности Revision Control System, поддержи­
вая модель "клиент-сервер" и параллельный доступ к файлам.
[URL 35] Aegis Transaction-Based Configuration Management
•=> www. canb. auug. org. a u / " m i l l e r p / a e g i s . html
Инструментальное средство управления версиями (ориентированное на процесс),
которое применяет к ним существующие стандарты проекта (например, проверку
прохождения тестов для возвращаемых программных кодов).
[URL 36] ClearCase
•=> www. r a t i o n a l . com
Управление версиями программы, рабочей областью и полной сборкой программы,
управление процессом.
[URL 37] MKS Source Integrity
•=> www.mks.com
Управление версиями и конфигурацией. Некоторые версии включают средства, по­
зволяющие удаленным пользователям-разработчикам одновременно работать над
одними и теми же файлами.
[URL 38] PVCS Configuration Management
www.merant.com
Система управления исходным текстом программ, очень популярная при работе в
Windows.
[URL 39] Visual SourceSafe
•=> www.microsoft.com
Система управления версиями, интегрируемая с инструментами визуальной разра­
ботки фирмы Microsoft.
[URL 40] Perforce
•=> www.perforce.com
Менеджер конфигурирования программного обеспечения "клиент-сервер".
Прочие инструментальные
средства
[URL 41 ] Winzip — Archive Utility for Windows
www.winzip.com

Информационные ресурсы
245
Фирма Nico Mak Computing,
Inc., Mansfield, CT
Утилита архивирования файлов, работающая в среде Windows. Поддерживает фор­
маты .zip и .tar.
[URL 42] The Z Shell
•=> zsh.sunsite.auc.dk/zsh
Оболочка, предназначенная для интерактивной работы, одновременно содержащая
мощный язык сценариев. В оболочку zsh было включено много полезных средств из
оболочек bash, ksh и tcsh и добавлен ряд оригинальных элементов.
43] A Free SMB Client for Unix Systems
<=> samba.anu.edu.au/pub/samba/
Дает возможность совместного использования файлов и других ресурсов из опера­
ционных систем Unix и Windows. Samba включает в себя:
•
Сервер SMB, предоставляющий средства работы с файлами и печати (схожие со
средствами, предоставляемыми Windows NT и LAN Manager) клиентам SMB,
в роли которых могут выступать Windows 95, Warp Server, smbfs и др.
•
Сервер имен Netbios, обеспечивающий, кроме всего прочего, поддержку функ­
ций браузера. По желанию пользователя Samba может быть главным браузером
в локальной сети.
•
Клиент SMB (схожий с клиентом ftp), позволяющий получать доступ к ресурсам
ПК (дискам и принтерам) из Unix, Netware и других операционных систем.
Статьи и публикации
[URL 44] The comp.object FAQ
•=>
www.cyberdyne-object-sys.com/oofaq2
Солидный, четко организованный список часто задаваемых вопросов по группе но­
востей comp.object.
[URL 45] eXtreme Programming
^> www.Xprogramming.com
Цитата с интернет-сайта: "При создании команды, способной быстро создать ис­
ключительно надежное, эффективное, четко структурированное программное обес­
печение, в ХР используется весьма легковесное сочетание методик. Многие из ме­
тодик ХР создавались и опробовались в части проекта СЗ фирмы "Крайслер",
представляющего собой весьма успешную систему расчета заработной платы, напи­
санную на языке Smalltalk."
[URL 46] Alistair Cockburn's Home Page
•=> www.members.aol.com/acockburn
Стоит посмотреть раздел "Structuring Use Cases with Goals" и так называемые шаб­
лоны сценариев использования

246
Приложение А
[URL 47] Martin Fowler's Home Page
•=> www.ourworld.Compuserve.com/homepages/martin_fowler
Мартин Фаулер является автором книги Analysis Patterns и соавтором книг UML
Distilled и Refactoring: Improving the Design of Existing Code. На домашней странице
автора обсуждаются его книги и работа с UML.
[URL 48] Robert С. Martin's Home Page
=> www.objectmentor.com/home
Неплохое собрание статей ознакомительного плана по объектно-ориентированным
методам, включая анализ зависимости и метрики.
[URL 49] Aspect-Oriented Programming
•=> www. pare, xerox, c o m / c s l / p г о j e c t s / а о р /
Описывается методика придания функциональности программному коду с позиций
ортогональности и описательности.
[URL 50] JavaSpaces Specifications
<=> www. j a v a . s u n . com/products/javaspaces
Linda-подобная система для Java, поддерживающая распределенное сохранение со­
стояния объекта и распределенные алгоритмы.
[URL 51 ] Netscape Source Code
•=> www.mozilla.org
Исходный текст браузера Netscape
[URL 52] The Jargon File
•=> www.jargon.org
Определения для многих общих (и не очень общих) терминов, применяемых в ком­
пьютерной индустрии, сдобренные хорошей дозой соответствующего фольклора.
[URL 53] Eric S. Raymond's Papers
•=> www.tuxedo.org/"esr
Статьи Эрика Раймона "The Cathedral and the Bazaar" и "Homesteading Noosphere",
в которых описаны психосоциальные основы и смысл движения Open Source.
[URL 54] The К Desktop Environment
<> www.kde.org
Цитата с web-страницы: "KDE представляет собой мощную графическую настоль­
ную среду для рабочих станций Unix. KDE является Интернет-проектом, открытым
в полном смысле этого слова".
[URL 55] The GNU Image Manipulation Program
www.gimp.org
Gimp является бесплатной программой по созданию, композиции и ретушированию
изображений.

Информационные ресурсы
247
[URL 56] The Demeter Project
•=> www.ccs.neu.edu/research/demeter
Исследовательский проект, призванный упростить поддержку и развитие программ­
ного обеспечения с помощью адаптивного программирования.
Другие
источники
[URL 57] The GNU Project (Проект GNU)
•=> www.gnu.org
Фонд "Free Software Foundation" — это некоммерческая благотворительная орга­
низация, осуществляющей сбор средств на проект GNU. Целью проекта GNU явля­
ется создание завершенной, бесплатной UNIX-подобной операционной системы.
Многие из попутно разработанных инструментальных средств уже стали отраслевы­
ми стандартами.
[URL 58] Web Server Information
•=> www.netcraft.com/survey/servers.html
Ссылки на домашние страницы, находящиеся более чем на 50 web-серверах. Часть из
них представляет коммерческие продукты, другие же распространяются бесплатно.

Библиография
[Вак72]
F.T. Baker. Chief programmer team management of production programm­
ing, IBM Systems Journal, 11( 1 ):56-73, 1972.
[BBM96]
V. Basili, L. Brand, and W.L. Melo. A validation of object-oriented design
metrics as quality indicators, IEEE Transactions on Software
Engineering,
22(10):751-761, October 1996.
[Ber96]
Albert J. Bernstein. Dinosaur Brains: Dealing with All Those Impossible
People at Work, Ballantine Books, New York, NY, 1996.
[Bra95]
Marshall Brain. Win32 System Services, Prentice Hall, Englewood Cliffs,
NJ, 1995.
[Bro95]
Frederick P. Brooks, Jr. The Mythical Man Month: Essays on Software
Engineering, Addison-Wesley, Reading, MA, 1995.
[CG90]
N. Carriero and D. Gelenter. How to Write Parallel Programs: A First
Course, MIT Press, Cambridge, MA, 1990.
[CN91 ]
Brad J. Cox and Andrex J. Novobilski. Object-Oriented Programming, An
Evolutionary Approach, Addison-Wesley, Reading, MA, 1991.
[Coc97a]
Alistair Cockburn. Goals and use cases, Journal of Object Oriented
Programming, 9(7):35-40, September 1997.
[Coc97b]
Alistair Cockburn. Surviving
Object-Oriented Projects: A
Manager's
Guide, Addison Wesley Longman, Reading, MA, 1997.
[Cop92]
James O. Coplien. Advanced С++ Programming Styles and Idioms,
Addison-Wesley, Reading, MA, 1992.
[DL99]
Tom Demarco and Timothy Lister. Peopleware: Productive Projects and
Teams, Dorset House, New York, NY, 1999.
[FBB+99]
Martin Fowler, Kent Beck, John Brant, William Opdyke, and Don Roberts.
Refactoring: Improving the Design of Existing Code,. Addison Wesley
Longman, Reading, MA, 1999.
[Fow96]
Martin Fowler. Analysis Patterns: Reusable Object Models, Addison
Wesley Longman, Reading, MA, 1996.

Библиография
249
[FS97]
Martin Fowler and Kendall Scott. UML Distilled: Applying
the
Standard
Object Modeling
Language,
Addison Wesley Longman, Reading, MA,
1997.
[GHJV95]
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design
Patterns:
Elements
of Reusable
Object-Oriented
Software,
Addison-
Wesley, Reading, MA, 1995.
[Gla99a]
Robert L. Glass. Inspections — Some surprising findings.
Communi­
cations of the ACM, 42(4):17-19, April 1999.
[Gla99b]
Robert L. Glass. The realities of software technology payoffs.
Com­
munications
of the ACM, 42(2):74-79, February 1999.
[Hol78]
Michael Holt. Math Puzzles
and Games, Dorset Press, New York, NY,
1978.
[Jac94]
Ivar Jacobson. Object-Oriented
Software
Engineering:
A
Use-Case
Driven Approach,
Addison-Wesley, Reading, MA, 1994.
[KLM+97]
Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cris-
tina Videira Lopes, Jean-Marc Loingtier, and John Irwin.
Aspect-oriented
programming.
In European
Conference
on Object-Oriented
Program­
ming (ECOOP),
volume LNCS 1241. Springer-Verlag, June 1997.
[Knu97a]
Donald Ervin Knuth. The Art of Computer Programming:
Fundamental
Algorithms,
volume 1, Addison Wesley Longman, Reading, MA, 1997.
[Knu97b]
Donald Ervin Knuth. The Art of Computer Programming:
Seminumerical
Algorithms,
volume 2, Addison Wesley Longman, Reading, MA, 1997.
[Knu98]
Donald Ervin Knuth. The Art of Computer
Programming:
Sorting
and
Searching,
volume 3, Addison Wesley Longman, Reading, MA, 1998.
[KP99]
Brian W. Kernighan and Rob Pike. The Practice of Programming,
Addison
Wesley Longman, Reading, MA, 1999.
[Kru98]
Philippe Kruchten. The Rational
Unified
Process:
An
Introduction,
Addison Wesley Longman,. Reading, MA, 1998.
[Lak96]
John Lakos. Large-Scale
С++ Software
Design, Addison Wesley Long­
man, Reading, MA, 1996.
[LH89]
Karl J. Lieberherr and Ian Holland. Assuring good style for object-oriented
programs, IEEE Software,
pages 38—48, September 1989.
[Lis88]
Barbara Liskov. Data abstraction and hierarchy, SIGPLAN Notices, 23(5),
May 1988.
[LMB92]
John R. Levine, Tony Mason, and Doug Brown. Lex and Yacc, O'Reilly &
Associates, Inc., Sebastopol, CA, 1992.
[McC95]
Jim McCarthy. Dynamics
of Software
Development,
Microsoft Press,
Redmond, WA, 1995.

250
Библиография
[Меу96]
Scott Meyers. More Effective
С+ + : 35 New Ways to Improve
Your
Programs
and Designs, Addison-Wesley, Reading, MA, 1996.
[Mey97a]
Scott Meyers. Effective
С+ + : 50 Specific
Ways
to Improve
Your
Programs
and Designs, Addison Wesley Longman, Reading, MA, 1997.
[Mey97b]
Bertrand Meyer. Object-Oriented
Software
Construction,
Prentice Hall,
Englewood Cliffs, NJ, 1997.
[Pet 98]
Charles Petzold. Programming
Windows,
The Definitive
Guide to the
Win32 API, Microsoft Press, Redmond, WA, 1998.
[Sch95]
Bruce Schneier. Applied
Cryptography:
Protocols,
Algorithms,
and
Source Code in C, John Wiley & Sons, New York, NY, 1995.
[Sed83]
Robert Sedgewick. Algorithms,
Addison-Wesley, Reading, MA, 1983.
[Sed 92]
Robert Sedgewick. Algorithms
in С+ + , Addison-Wesley, Reading, MA,
1992.
[SF96]
Robert Sedgewick and Phillipe Flajolet. An Introduction
to the Analysis
of
Algorithms,
Addison-Wesley, Reading, MA, 1996.
[Ste92]
W. Richard Stevens. Advanced
Programming
in the Unix
Environment,
Addison-Wesley, Reading, MA, 1992.
[Ste98]
W. Richard Stevens. Unix Network Programming,
Volume 1:
Networking
APIs: Sockets andXti,
Prentice Hall, Englewood Cliffs, NJ, 1998.
[Ste99]
W.
Richard
Stevens.
Unix
Network
Programming,
Volume
2:
Interprocess
Communications,
Prentice Hall, Englewood Cliffs, NJ, 1999.
[Str35]
James Ridley Stroop. Studies of interference in serial verbal reactions,
Journal of Experimental
Psychology,
18:643—662, 1935.
[WK82]
James Q. Wilson and George Kelling. The police and neighborhood safety,
The Atlantic Monthly,
249(3):29-38, March 1982.
[YC86]
Edward
Yourdon
and
Larry
L.
Constantine.
Structured
Design:
Fundamentals
of a Discipline
of Computer
Program
and
Systems
Design, Prentice Hall, Englewood Cliffs, NJ, 1986.
[You95]
Edward Yourdon. Managing projects to produce good-enough software,
IEEE Software,
May 1995.

Приложение В
Ответы к упражнениям
Упражнение 1 из раздела "Ортогональность"
Ответ: По нашему разумению, более ортогональным является класс Split2. Он сосре­
доточен на собственной задаче — расщеплении строк и игнорирует подробности, свя­
занные с источником обрабатываемых им строк. Это не только упрощает разработку
программы, но и придает ей большую гибкость. Класс Split2 может расщеплять стро­
ки, считываемые из файла, сгенерированные другой программой или передаваемые
через операционную среду.
Упражнение 2 из раздела "Ортогональность"
Ответ: Если все сделано корректно, то, по всей вероятности, немодальное. Система,
которая использует немодальные диалоговые окна, испытывает меньшее беспокойст­
во о том, что происходит в любой конкретный момент времени. Скорее всего, она бу­
дет обладать лучшей инфрастуктурой взаимодействия между модулями по сравнению
с модальной системой. Последняя может содержать встроенные предположения о со­
стоянии системы — предположения, которые могут привести к большему связыва­
нию и уменьшению ортогональности.
Упражнение 3 из раздела "Ортогональность"
Ответ: Здесь есть элемент лукавства. Объектная технология может обеспечить нали­
чие более ортогональной системы, но, поскольку она имеет больше средств, которые
могут эксплуатироваться с нарушением режима, в реальности легче создать неорто­
гональную систему, используя объекты, чем создавать ее при помощи процедурного
языка. Ее особенности, такие как множественное наследование, исключительные си­
туации, перегрузка операторов и переопределение родительского метода (через меха­
низм подклассов) предоставляют достаточные возможности для увеличения связан­
ности не столь очевидными способами.
Применяя объектную технологию и приложив небольшое дополнительное усилие,
вы можете добиться наличия более ортогональной системы. И хотя вы всегда можете

252
Приложение В
написать неструктурированную программу на процедурном языке, объектно-ориенти­
рованные языки, используемые в малых дозах, могут сделать ее более насыщенной.
Упражнение 4 из раздела "Прототипы и памятные записки"
Ответ: Для спасения ситуации прибегнем к устаревшим технологиям! Нарисуйте на
лекционной доске несколько картинок — автомобиль, телефон и дом — с помощью
фломастера. Для этого не нужно быть великим художником, вполне достаточно ус­
ловных изображений. Поместите на доску памятные записки, описывающие содержи­
мое целевых страниц в активных областях экранах. В ходе встречи вы можете совер­
шенствовать рисунки и менять расположение памятных записок.
Упражнение 5 из раздела "Языки, отражающие специфику предметной области"
Ответ: Поскольку мы хотим, чтобы язык был расширяемым, то сделаем таблицу син­
таксического анализатора управляемой. Каждый элемент таблицы содержит символ
команды, флаг (говорящий о необходимости аргумента) и имя подпрограммы, вызы­
ваемой для обработки этой конкретной команды.
typedef struct {
char
cmd;
/ * the
command letter
*/
int hasArg;
/ * does
it
take
an argument
*/
void (*func)(int, i n t ) ;
/ * routine
to call
*/
} Command
s t a t i c Command cmds[] = {
{ ' P ' ,
ARG,
doSelectPen
{
' U \
N0_ARG,
doPenUp } ,
{
' D ' ,
N0_ARG,
doPenDown } ,
{
' N ' ,
ARG,
doPenDir } ,
{ ' E ' ,
ARG,
doPenDir } ,
{ ' S ' ,
ARG,
doPenDir } ,
{
' W ,
ARG,
doPenDir }
} ;
Основная программа довольно проста: считать строку, отыскать команду, при не­
обходимости принять аргумент, затем вызвать функцию обработчика.
while ( f g e t s ( b u f f ,
s i z e o f ( b u f f ) ,
s t d i n ) )
{
Command *cmd = findCommand(*buff);
i f
(cmd) {
int arg = 0;
i f (cmd->hasArg && !getArg(buff+1, &arg)) {
f p r i n t f ( s t d e r r ,
" ' % c ' needs an argument\n",
* b u f f ) ;
continue;
}
cmd->func(*buff,
a r g ) ;
}
}
Функция, которая ищет команду, исполняет последовательный перебор таблицы,
возвращая либо совпадающий элемент, либо NULL.

Ответы к упражнениям
253
Command *findCommand(int cmd) {
int i;
for (i = 0; i < ARRAY_SIZE(cmds); i++) {
i f (cmds[i].cmd == cmd)
return cmds + i;
>
fprintf(stderr,
"Unknown command '%c'\n", cmd);
return 0;
}
И наконец, считывание числового аргумента довольно просто, если использовать
подпрограмму sscanf.
int getArg(const char *buff, int *result) {
return sscanf(buff,
"%d". result) == 1;
}
Упражнение 6 из раздела "Языки, отражающие специфику предметной области"
Ответ: При использовании BNF спецификация времени могла бы выглядеть следую­
щим образом:
<time>
:: = <hour> <атрт> |
<hour> : <minute>
<атрт> \
<hour> :
<minute>
<атрт>
: = am|pm
<hour>
:: = <digit>
\
<digit>
<digit>
<minute>
:: = <digit>
<digit>
<digit>
:: =
0|1|2|3|4|5|6|7|8|9
Упражнение 7 из раздела "Языки, отражающие специфику предметной области"
Ответ: В нашем примере мы составили программу, используя генератор bison, кото­
рый представляет собой GNU-версию генератора уасс. Для ясности здесь показано
только тело программы синтаксического анализатора. Полная версия имеется на сай­
те www.pragmaticprogrammmer.com.
time:
spec EOF
{ i f ($1 >= 24*6C) yyerror("Time is
too
large");
printf{"%d minutes
past
midnight\n",
$1);
exit(O);
}
spec:
hour ' : ' minute
{ $$ = $1 + $3;
}
| hour ' : ' minute ampm
{ i f ($1 > 11*60) yyerror("Hour out
of
range");
$$ = $1 + $3 + $4;

254
Приложение В
hour:
ampm:
hour ampm
i f
($1 > 11*60) yyerror("/four out
of
range");
$$ = $1 + $2;
hour_num
i f ($1 > 23) yyerror("Hour
out
of
range"
$$ = $1 * 60;
minute:
DIGIT DIGIT
$$ = $1.10 + $2;
i f
($$ > 59) yyerror("minute
out
of
range"
AM
| PM
hour_num: DIGIT
I DIGIT DIGIT
{ $$,= AM_MINS; }
{ $$ = PM_MINS; }
{ $$ = $1; }
{ $$ = $1*10 + $2; }
Упражнение 8 из раздела "Языки, отражающие специфику предметной области''
Ответ:
$_ = shift;
/ " ( \ d \ d ? ) ( a m | p m ) $ /
&& doTime($1, 0,
$2, 12);
/ - ( \ d \ d ? ) : ( \ d \ d ) ( a m | p m ) $ / && doTime($1, $2, $3, 12);
/ " ( \ d \ d ? ) : ( \ d \ d ) $ /
&& doTime($1, $2,
0, 24);
die "Invalid
time
$_\n";
#
# doTime(hour,
min, ampm, maxHour)'
#
sub doTime($$$$) {
my ($hour,
$min, $offset,
$maxHour) = @_;
die "Invalid
hour:
$hour"
i f ($hour >= $maxHour);
$hour += 12 i f
($offset eq "pm");
print $hour*60 + $min, " minutes
past
midnight\n";
exit(O);
>
Упражнение 9 из раздела "Оценка"
Ответ: Ответ должен быть изложен, исходя из нескольких допущений:
•
Лента содержит информацию, которую необходимо передать.
•
Нам известна скорость ходьбы человека.
•
Нам известно расстояние между компьютерами.
•
Временем, необходимым для переноса информации на ленту и с ленты, мож­
но пренебречь.

Ответы к упражнениям
255
•
Потери данных при хранении на ленте примерно равны их потерям при пере -
даче по каналу связи.
Упражнение 10 из раздела "Оценка"
Ответ: Учитывая допущения ответа 9: Объем информации, содержащейся на стрим-
мерной кассете (4 Гбайт), составляет 32 х 10
9 бит, так что передача эквивалентного
объема по каналу со скоростью 1 Мбайт/с заняла бы примерно 32 ООО сек. (пример­
но 9 ч). Если человек движется с постоянной скоростью 3,5 мили в час, то для того,
чтобы канал связи превзошел нашего курьера, два компьютера должны располагать­
ся друг от друга на расстоянии не менее 31 мили. Если это расстояние меньше, то по­
беда остается за человеком.
Упражнение 11 из раздела "Обработка текста" на стр. 102
Ответ: Ответ к данному упражнению составлен на языке Perl.
my @consts;
my $name = <>;
die "Invalid
format
- missing
name"
unless
defined($name);
chomp $name;
# Read in
the
rest
of
the
file
while (<>) <
chomp;
s / ~ \ s * / / ;
s / \ s * $ / / ;
die "Invalid
line:
$_" unless / " ( \ w + ) $ / ;
push ©consts,
$_;
}
# Now generate the
f i l e
open(HDR, ">$name.h")
or die "Can't
open
$name.h:
$!";
open(SRC, ">$name. c " ) or die
"Can't
open
$name.c:
$!";
my $uc_name = uc($name);
print HDR " / * File
generated
automatically
- do not
edit
*/\n";
print HDR "extern
const
char
*$
{uc_name}_name[];"\
print HDR "typedef
enum {\n
";
print HDR join " , \ n
", @consts;
print HDR " \ n }
$uc_name;\n\n";
print SRC " / * File
generated
automatically
- do not
edit
*/\n";
print SRC "const
char
*$ {uc_name}_name[]
= {\n
\"";
print SRC join " \ " , \ n
\ " " , @consts;
print SRC " \ " \ n } ; \ n " ;
close(SRC);
close(HDR);
Используя принцип DRY, мы не будет вырезать и вклеивать этот вновь написан­
ный файл в нашу программу. Вместо этого мы "включим" его — данный плоский
файл является главным источником этих констант. Это означает, что нам понадобится
файл сборки для восстановления заголовка при изменении файла. Следующий фраг­
мент содержится в системе отладки в исходном дереве (имеется на web-сайте).

256
Приложение В
e t e s t . c e t e s t . h :
e t e s t . i n c
enumerated.pl
perl enumerated.pl
e t e s t . i n c
Упражнение 12 из раздела "Обработка текста"
Ответ: Вот ответ, написанный на языке Perl.
ray $dir = shift or die "Missing
directory";
for my $ f i l e (glob("$dir/*.pi"))
{
open(IP, " $ f i l e " ) or die "Opening
$file:
$!";
undef $/;
# Turn off
input
record
separator
-
my $content = <IP>; # read
whole
file
as one
string.
close(IP);
i f ($content ! " /"use s t r i c t / m ) {
rename $ f i l e ,
"$file.bak"
or die "Renaming
$file:
$!";
open(0P, " > $ f i l e " ) or die "Creating
$file:
$!";
# Put
'use strict'
on first
line
that
# doesn 't start
'#'
$content =" s / " ( ? ! # ) / \ n u s e strict;
\n\n/m;
print OP Scontent;
close(OP);
print "Updated
$file\n";
>
else {
print "$file
already
strict\n";
}
}
Упражнение 13 из раздела "Генераторы исходных текстов"
Ответ: Решение реализовано на языке Perl. В программе происходит динамическая
загрузка модуля для генерации требуемого языка, так что добавление новых язьжов
не представляет труда. Главная программа загружает внутреннюю часть (основанную
на параметре командной строки), затем считывает ее входные данные и вызывает под­
программы генерации текста, основанные на содержимом каждой из строк. Мы осо­
бенно не суетимся, если речь идет об обработке ошибок: если что-то не так, то мы уз­
наем об этом довольно быстро.
my $lang = shift or die "Missing
language";
$lang .-
"_cg.pm";
require "$lang" or die "Couldn't
load
$lang";
П Head and parse
the
file
my $name;
while (<>) {
chomp;
i f
( / ~ \ s . $ / )
{ C G : : b l a n k L i n e ( ) ; }
e l s i f ( / ~ \ # ( . * ) / )
{ CG:
-.comment($1); }
e l s i f ( / ~ M \ s * ( . + ) / )
{ CG::startMsg($1); $name = $1; }
e l s i f
( / ~ E / )
{ CG::endMsg($name); }
e l s i f
( / ~ F \ s * ( \ w + ) \ s + ( \ w + ) $ / )

Ответы к упражнениям
257
{ CG::simpleType($1,$2); }
e l s i f (/T\s.(\w+)\s+(\w+)\[(\d+)\]$/)
{ CG::arrayType($1,$2,$3); }
else {
die "Invalid
line:
$__";
)
}
Написание языковой серверной части не составит труда: создайте модуль, который
реализует шесть точек входа. Вот генератор текста на языке С:
#!/usr/bin/perl
-w
package CG:
use strict;
# Code generator
for
'C
(see
cg__base.pl)
sub blankLine() { print "\n";
}
sub comment()
{ print "/*$_[0]
*/\n"\
}
sub startMsgO
{ print "typedef
struct
{\n"\
}
sub endMsg()
{ print
"} $_[0];\n\n"\
}
sub arrayType() {
my ($name, $type, $size) = @_;
print "
Stype
$name\[$size];\n";
>
sub simpleType() {
my ($name, $type) = @_;
print "
$type
$name;\n";
)
1;
А вот генератор текста на языке Pascal:
U!/usr/bin/perl
-w
package CG;
use strict;
# Code generator
for
'Pascal'
(see
cg_base.pl)
sub blankLineQ { print "\n";
}
sub comment()
{ print "{$_[0]
}\n";
}
sub startMsgO
{ print "$_[0]
= packed
record\n"\
}
sub endMsgO
{ print "end;\n\n";
}
sub arrayType() {
my ($name, $type, $size) = §_;
$size--;
print "
$name:
array[0..
$size]
of $type;
\n";
}
sub simpleType() {
my ($name, Stype) = @_;
print "
$name:
Stype;\n";
}
1;

258
Приложение В
Упражнение 14 из раздела "Проектирование по контракту"
Ответ: Этот пример на языке Eiffel удачен. Мы требуем передачи непустых данных и га­
рантируем, что семантика циклического двунаправленного списка будет соблюдена. Это
также способствует нахождению сохраненной строки. Поскольку это некий отложенный
класс, то действительный класс, его реализующий, допускает использование любого ос­
новного механизма по своему усмотрению. Он может использовать указатели или мас­
сив, или что-то еще; пока он соблюдает контракт, мы не беспокоимся.
Упражнение 15 из раздела "Проектирование по контракту"
Ответ: Это неудачно. Математическое действие в индексном выражении (index-1) не
будет работать с граничными условиями, подобными первой точке входа.
Постусловие предполагает определенную реализацию; контракты должны быть
более абстрактными по сравнению с указанным выше.
Упражнение 16 из раздела "Проектирование по контракту"
Ответ: Это удачный контракт, но неудачная реализация. Здесь высовывает свою
уродливую
голову ошибка типа "Heisenbug" [URL52]. Вероятно, программист до­
пустил опечатку — набрал pop вместо top. Хотя это простой и надуманный пример,
весьма трудно диагностировать побочные эффекты в утверждениях (или в любом са­
мом неожиданном месте в программе).
Упражнение 17 из раздела "Проектирование по контракту"
Ответ: Мы продемонстрируем функциональные сигнатуры на языке Java, обозначая
предусловия и постусловия в соответствии с iContract.
Сначала инвариант для класса:
/ * *
* §invariant
getSpeed()
> О
*
implies
isFull()
* ^invariant
getSpeed()
>= 0 &&
getSpeed()
" 10
*/
//
He запускать
пустое
//
Проверка
границ
Затем предусловия и постусловия:
/**
* @рге Math.abs(getSpeed()
- х) <
* @рге х >= 0 && х > 10
* ©post getSpeed()
== х
1 / /
/ /
/ /
Единственный
выбор
Проверка
границ
Проверка
скорости
public void s e t S p e e d ( f i n a l int
x)
/**
* @pre
!isFull()
* @post
isFullO
*/
He заполнять
дважды
Убедитесь,
что было
выполнено
void
f i l l ( )
/ / END:
ans_prepost
* §pre
isFullO
* @post
!isFull()
He очищать дважды
Убедитесь,
что было
выполнено

Ответы к упражнениям
259
void empty()
Упражнение 18 из раздела "Проектирование по контракту"
Ответ: В этом ряду содержится 21 число. Если вы ответили "20", то допустили так на­
зываемую ошибку "поста охраны".
Упражнение 19 из раздела "Программирование утверждений"
Ответ:
1.
В сентябре 1752 г. было всего лишь 19дней. Это было сделано с целью син­
хронизации при переходе с юлианского на григорианский календарь.
2.
Каталог мог быть удален другим процессом, у вас нет прав доступа на его чте­
ние, выражение &sb может быть недопустимым — вы все уловили.
3.
Мы проявили малодушие, не указав типов а и Ь. Во время перегрузки операто­
ров могло случиться так, что поведение знаков +, = или ! = стало непредска­
зуемым. Кроме того, а и b могут быть псевдонимами одной и той же перемен­
ной, так что при втором присвоении произойдет перезапись значения,
сохраненного во время первого,
4.
В неевклидовой геометрии сумма углов треугольника не будет составлять 180°.
Подумайте о треугольнике, отображаемом на поверхности сферы.
5.
Минуты, приходящиеся на високосный год, могут состоять из 61 или 62 секунд.
6.
Переполнение может оставить результат операции а + 1 отрицательным (это
также может произойти в языках С и С + + ).
Упражнение 20 из раздела "Программирование утверждений"
Ответ: Мы решили реализовать очень простой класс с единственным статическим ме­
тодом TEST, который выводит на печать сообщение и след стека, если переданный
параметр condition является ложным.
package com.pragprog.util;
import java.lang.System;
/ / для
exit()
import java.lang.Thread;
/ / для
dumpStack()
public class Assert {
/** Write a message,
print
a stack
trace
and exit
if
* our parameter
is
false.
4
public s t a t i c void TEST(boolean condition) {
i f (!condition) {
System.out.println("==== Assertion
Failed
====");
Thread.dumpStack();
System.exit(1);
}
}
//
Testbed.
If our argument
is
'okay',
try an assertion
that
II
succeeds,
if
fail'
try one that
fails
public s t a t i c f i n a l void main(String args[]) {

260
Приложение В
i f
(args[0].compareTo("okay")
== 0) {
TEST(1
= = 1 ) ;
}
else i f
(args[0].compareTo("fail")
== 0) {
TEST(1 == 2);
}
else {
throw new RuntimeException("Bad
argument");
}
}
}
Упражнение 21 из раздела "Случаи, когда используются исключения"
Ответ: Нехватка памяти является исключительным состоянием, поэтому мы полага­
ем, что в случае (1) должно возбуждаться исключение.
Невозможность отыскания точки входа — вполне нормальная ситуация. Прило­
жение, вызывающее наш класс-набор, может написать программу, которая проверя­
ет наличие точки входа перед тем, какдобавить потенциальный дубликат. Мы полага­
ем, что в случае (2) нужно просто осуществить возврат ошибки.
Случай (3) более проблематичен — если указатель null играет существенную роль
в приложении, то его добавление к контейнеру может быть оправдано. Но если для
хранения пустых значений нет веских оснований, то, по всей вероятности, необходимо
возбудить исключительную ситуацию.
Упражнение 2 2 из раздела "Балансировка ресурсов"
Ответ: В большинстве реализаций языков С и С + + отсутствуют способы проверки
того, что указатель действительно указывает на допустимый блок памяти. Обычная
ошибка состоит в освобождении блока памяти и организации ссылки на этот блок да­
лее в тексте программы. К тому времени, этот блок памяти уже может быть перерас­
пределен для других целей. Обнуляя указатель, программисты надеются предотвра­
щать эти инородные ссылки — в большинстве случаев разыменование указателя null
генерирует ошибку в ходе выполнения программы.
Упражнение 23 из раздела "Балансировка ресурсов"
Ответ: Обнуляя ссылку, вы уменьшаете число указателей на упомянутый объект на
единицу. Как только этот счетчик становится равным нулю, объект получает право на
сбор "мусора". Обнуление ссылок может играть существенную роль в продолжитель­
ных по времени программах, где программистам приходиться удостоверяться, что ис­
пользование памяти со временем не возрастает.
Упражнение 24 из раздела "Несвязанность и закон Деметера"
Ответ: Файл заголовка предназначен для определения интерфейса между соответст­
вующей реализацией и внешним миром. Сам по себе файл заголовка не обязан обла­
дать информацией о внутренней организации класса Date — от него лишь требуется
сообщить компилятору о том, что конструктор принимает класс Date в качестве пара­
метра. Поэтому, если файл заголовка не использует Dates в подставляемых функци­
ях, второй фрагмент будет работать просто замечательно.

Ответы к упражнениям
261
А что же с первым фрагментом? Если он используется в небольшом проекте, то
все нормально, за исключением что вы без особой надобности заставляете все эле­
менты программы, которые используют класс Person 1, также включать файл заго­
ловка для класса Date. Как только подобное употребление становится обычной прак­
тикой в неком проекте, вы вскоре обнаружите, что включение одного файла заголовка
заканчивается включением большей части системы, что существенно увеличивает
время компиляции.
Упражнение 2 5 из раздела "Несвязанность и закон Деметера"
Ответ: Переменная acct передается в виде параметра, так что вызов getBalance яв­
ляется допустимым. Вызов amt.print_Format() таковым не является. Мы не владеем
amt, и он не был передан нам. Мы могли устранить связывание showBalance с Money
при помощи вставки, подобной представленной ниже:
void showBalance(BankAccount b) {
b. p r i n t B a l a n c e ( ) ;
}
Упражнение 2 6 из раздела "Несвязанность и закон Деметера"
Ответ: Поскольку класс Colada создает и владеет myBlender и myStuff, то обращения
к addlngredients и elements являются допустимыми.
Упражнение 27 из раздела "Несвязанность и закон Деметера"
Ответ: В этом случае processTransaction владеет amt — он создается на стеке. Про­
исходит передача
acct, поэтому допустимыми являются как setValue, так и
setBalance. Но processTransaction не владеет who, поэтому вызов who->name() явля­
ется нарушением. Закон Деметера предлагает заменить эту строку на следующую:
markWorkflow (acct.name ( ) , SET_BALANCE);
Программе в processTransaction не придется узнавать, какой дочерний объект в
пределах BankAccount носит это имя — эта информация о структуре не должна раз­
глашаться через контракт BankAccount. Вместо этого мы запрашиваем у BankAccount
имя на счету. Он знает, где хранится имя (может быть, в объекте Person, в объекте
Business или в полиморфном объекте Customer).
Упражнение 28 из раздела "Метапрограммирование"
Ответ: Здесь не приводятся категорические ответы — вопросы предназначались в ос­
новном для того, чтобы дать вам пишу для размышлений. И вот что мы думаем:
1.
Назначения коммуникационного порта. Ясно, что эта информация должна
сохраняться в виде метаданных. Но на каком уровне детализации? Некоторые
коммуникационные программы системы Windows позволяют выбирать только
скорость в бодах и порт (скажем, СОМ1 — COM4). Но, вероятно, вам при­
дется указать размер слова, четность, стоповые биты и настройку дуплексной
связи. Старайтесь допускать самый мелкий уровень детализации там, где это
разумно с практической точки зрения.

262
Приложение В
2.
Поддержка выделения синтаксических конструкций различных языков в
программе редактирования. Она должна быть реализована в виде метадан­
ных. Вы же не хотите, чтобы вам пришлось переделывать программу только
потому, что в последней версии языка Java было введено новое ключевое
слово.
3 .
Поддержка редактора для различных графических устройств. Эту поддерж­
ку было бы трудно реализовать исключительно в виде метаданных. Вам не хо­
телось бы нагружать ваше приложение многими драйверами устройств только
для того, чтобы выбрать один из них во время выполнения программы. Однако
вы могли воспользоваться метаданными для указания имени драйвера и дина­
мической загрузки программы. Это еще один аргумент для сохранении мета­
данных в удобочитаемом формате; если вы используете программу для уста­
новки дисфункционального видеодрайвера, то не сможете переустановить его,
пользуясь этой программой.
4.
Конечный автомат для программы синтаксического анализа или сканера.
Это зависит от того, анализируете вы или просматриваете. Если вы анализи­
руете некоторые данные, которые жестко определены в стандартах и скорее
всего не будут изменены без одобрения Конгресса США, то жесткое кодирова­
ние вполне годится. Но если вы сталкиваетесь с более изменчивой ситуацией,
то, может быть, более выгодным является внешнее определение таблиц со­
стояний.
5.
Типовые значения и результаты, используемые в модульном тестировании.
Большинство приложений определяет эти значения как встроенные в тестовый
стенд, но вы можете добиться большей гибкости, перемещая тестовые данные и
определение приемлемых результатов за пределы самой программы.
Упражнение 29 из раздела "Всего лишь представление"
Ответ: В программу Flight добавим ряддополнительных методов для поддержания двух
списков "слушателей": для уведомления о листе ожидания и о полной загрузке рейса.
public interface Passenger {
public void w a i t L i s t A v a i l a b l e ( ) ;
}
public interface F l i g h t {
public void addWaitl_istl_istener(Passenger
p);
public void removeWaitListListener(Passenger p);
public void a d d F u l l L i s t e n e r ( F u l l L i s t e n e r b);
public void removeFullListener(FullListener b);
}
public interface BigReport extends F u l l L i s t e n e r {
public void F l i g h t F u l l A l e r t ( F l i g h t
f ) ;
}
При неудачной попытке добавить Passenger, поскольку рейс полностью заброни­
рован, мы можем (как вариант) поместить Passenger в лист ожидания. При открытии

Ответы к упражнениям
263
вакансии производится вызов метода waitListAvailable. Затем этот метод может
осуществить выбор: либо добавить Passenger автоматически, либо дать указание со­
труднику авиакомпании позвонить заказчику и выяснить, заинтересован ли он еще в
рейсе, и т.п. Теперь мы обладаем достаточной гибкостью, чтобы избрать линию пове­
дения, исходя из пожеланий клиента.
Кроме того, мы хотим избежать ситуации, при которых BigReport разбирает тонны
записей, отыскивая полностью забронированные рейсы. Зарегистрировав BigReport
в качестве "слушателя" F l i g h t s , каждый индивидуальный Flight может сообщать,
когда он полностью (или почти полностью) забронирован. Теперь пользователи могут
мгновенно получить оперативные, с точностью до минуты, сообщения из BigReport, а
не ожидать часами окончания его работы, как это было раньше.
Упражнение 3 0 из раздела "Доски объявлений"
Ответ:
1.
Обработка изображения. Для простого распределения рабочей нагрузки между
параллельными процессами более чем адекватной может оказаться общедоступ­
ная очередь работ. Вы можете рассмотреть систему "доска объявлений" при
наличии обратной связи, т.е. если результаты обработки одного фрагмента изо­
бражения влияют на другие фрагменты так, как это происходит в системах искус­
ственного зрения или сложных трехмерных преобразованиях изображений.
2.
Календарное планирование для групп. Для этого "доска объявлений" очень
даже пригодится. Вы можете поместить назначенные собрания и готовность на
"доску объявлений". Есть объекты, функционирующие автономно; в данном
случае важна обратная связь с принимаемыми решениями и, участники могут
приходить и уходить.
Вы могли бы рассмотреть возможность разделения "доски объявлений"
этого типа в зависимости от того, кто осуществляет поиск: младший персонал
может заботиться только о локальном офисе, отдел кадров интересуется толь­
ко англоговорящими офисами во всем мире, а исполнительный директор инте­
ресуется всем сразу.
В форматах данных имеется некий элемент гибкости: мы можем проигно­
рировать форматы или языки, которых мы не понимаем. Нам придется пони­
мать различные форматы только для тех офисов, которые встречаются друг с
другом, и нам не придется подвергать всех участников полному транзитивному
замыканию всевозможных форматов. При этом связанность уменьшается там,
где нужно, и мы не имеем искусственных ограничений.
3.
Средство мониторинга компьютерной сети. Это весьма сходно с программой
обработки заявлений на ипотечный кредит/ссуду, описанной в примере прило­
жения (с. 153). На доску помещаются сообщения о неисправностях, присылае­
мые пользователями, и автоматические генерируемые статистические данные.
Сотрудник (или программный агент) может анализировать "доску объявлений",
чтобы осуществлять диагностику неисправностей в сети: две ошибки в линии
могут быть отнесены на счет космических лучей, но 20 ООО ошибок говорят о
проблеме в аппаратном обеспечении. Подобно детективам, разгадывающим

264
Приложение В
тайну убийства, вы можете использовать множественные объекты, анализируя
и внося свою лепту в решение проблем, связанных с компьютерной сетью.
Упражнение 31 из раздела "Программирование в расчете на стечение обстоятельств"
Ответ: Эта программа представляет ряд потенциальных проблем. Во-первых, она
предлагает наличие текстовой среды. Это, может быть, и прекрасно, если предполо­
жение истинно, но что если эта программа вызывается из графической среды, где не
открыты ни stderr, ни stdin?
Во вторых, имеется проблематичный оператор gets, который будет записывать
столько символов, сколько он получит в переданный буфер. Злонамеренные пользо­
ватели использовали это, когда им не удавалось проделать бреши типа buffer
overrun в защите многих различных систем. Никогда не пользуйтесь gets().
В третьих, программа предполагает, что пользователь понимает английский язык.
И наконец, никто, находясь в здравом уме, не станет прятать средство взаимодей­
ствия с пользователем в недра библиотечной подпрограммы.
Упражнение 32 из раздела "Программирование в расчете на стечение обстоятельств"
Ответ: Работа программы strcpy в системе POSIX не гарантируется при наличии пе­
рекрывающихся строк. С некоторыми архитектурами она, случается, и работает, но
лишь при стечении обстоятельств.
Упражнение 3 3 из раздела "Программирование в расчете на стечение обстоя­
тельств"
Ответ: Она не будет работать в контексте апплета при наличии ограничений доступа
по записи на локальный диск. Если вы можете выбирать, работать ли через графиче­
ский интерфейс, или если нет, то, вероятно, захотите осуществить динамический ана­
лиз текущей среды. В этом случае вы наверняка захотите поместить файл журнала
вне локального диска, если к нему нет доступа.
Упражнение 34 из раздела "Скорость алгоритма"
Ответ: Ясно, что мы не можем давать никаких абсолютных ответов к этому упражне­
нию. Однако мы можем дать вам пару намеков.
Если ваши результаты не ложатся на гладкую кривую, то вы захотите проверить,
не используется ли мощность вашего процессора каким-либо другим процессом. По
всей вероятности, вы не получите хороших показателей в многопользовательской
системе, и даже если вы окажетесь единственным пользователем, то можете заме­
тить, что фоновые процессы периодически отбирают циклы у ваших программ. Вы
также можете захотеть проверить использование памяти: если приложение начина­
ет использовать область свопинга, то производительность резко снижается.
Интересно поэкспериментировать с различными компиляторами и установочными
параметрами оптимизации. Мы обнаружили, что весьма впечатляющее ускорение
стало возможно благодаря использованию агрессивной оптимизации. Мы также об­
наружили, что на более распространенных архитектурах типа RISC компиляторы
фирмы изготовителя часто превосходили по быстродействию более переносимую
GCC. Возможно, изготовитель посвящен в тайны эффективной генерации программ
на этих машинах.

Ответы к упражнениям
265
Упражнение 35 из раздела "Скорость алгоритма"
Ответ: Программа printTree использует приблизительно 1000 байт стекового про­
странства для буферной переменной. Для движения вниз по древовидной схеме она
рекурсивно вызывает саму себя, и каждый вложенный вызов добавляет еще
1 ООО байт к стеку. Она также вызывает саму себя когда добирается до вершин, но за­
канчивает работу сразу, когда обнаружит что переданный указатель обнулен. Если
глубина дерева D, то отсюда максимальный объем, необходимый стеку, составляет
(грубо): Ю О О х ф + 1).
Сбалансированное двойное дерево содержит вдвое больше элементов на каждом
уровне. Дерево глубиной D содержит 1 + 2 + 4 + 8 +... + 2
( D _ 1 ) , или 2
D — 1 элементов.
Отсюда, нашему дереву, состоящему из миллиона элементов, будет необходимо
[lg( 1000001 ] или 20 уровней.
Поэтому мы рассчитываем, что наша подпрограмма будет использовать примерно
21 000 байт стекового пространства.
Упражнение 36 из раздела "Скорость алгоритма"
Ответ: На ум приходит несколько процедур оптимизации. Программа printTree
вызывает саму себя на вершинах дерева лишь для того, чтобы закончить работу
при отсутствии потомков. Этот вызов увеличивает максимальную глубину стека
примерно на 1000 байт. Мы также можем исключить рекурсию хвоста (второй ре­
курсивный вызов), хотя это и не будет затрагивать использование стека в наихуд­
шем случае.
while (node) {
i f (node->left)
printTree(node->left);
getNodeAsString(node,
b u f f e r ) ;
p u t s ( b u f f e r ) ;
node = node->right;
}
Но самая большая выгода возникает при назначении одного-единственного буфе­
ра, доступ к которому осуществляется при всех обращениях к printTree. Если пере­
дать этот буфер в виде параметра для рекурсивных обращений, то вне зависимости от
глубины рекурсии будет назначено всего 1000 байт.
void printTreePrivate(const
Node *node, char *buffer) {
i f
(node) {
printTreePrivate(node->left,
buffer);
getNodeAsString(node,
buffer);
p u t s ( b u f f e r ) ;
printTreePrivate(node->right,
buffer);
}
}
void newPrintTree(const Node *node) {
char
buffer[1000];
printTreePrivate(node,
b u f f e r ) ;
}

266
Приложение В
Упражнение 37 из раздела "Скорость алгоритма"
Ответ: Это можно сделать двумя путями. Один из них заключается в том, чтобы пере­
вернуть проблему с ног на голову. Если в массиве имеется лишь один элемент, то мы
не осуществляем итерации в цикле. Каждая дополнительная итерация удваивает раз­
мер массива, в котором мы можем осуществлять поиск. Отсюда общая формула раз­
мера массива: п = 2
т , где т — число итераций. Если прологарифмировать обе части
с основанием 2, то получим выражение lg(ft) = lg(2
r a), которое из определения лога­
рифма превращается в lg (п) = т.
Упражнение 3 8 из раздела "Реорганизация"
Ответ: Здесь мы могли бы предложить весьма умеренную реструктуризацию: убеди­
тесь, что каждый тест выполняется лишь один раз, и сделайте все вычисления стан­
дартными. Если выражение 2*basis ( . . . ) * 1.05 появляется в других местах про­
граммы, то вероятно его стоит сделать функцией. В данном случае мы этого делать не
стали.
Мы добавили массив rate_lookup, который инициализирован таким образом, что
элементам, отличным от Texas, Ohio и Maine присвоено значение 1. Этот подход об­
легчает добавление значений для других штатов в будущем. В зависимости от ожидае­
мой схемы использования мы могли бы сделать поле points также средством поиска в
массиве.
rate = rate_lookup[state];
amt
= base * rate;
calc = 2*basis(amt) + extra(amt)*1.05;
if ( s t a t e == OHIO)
points = 2;
Упражнение 3 9 из раздела "Реорганизация"
Ответ: Когда вы видите, что кто-либо использует перечислимые типы (или эквива­
лентные им в языке Java), для того чтобы провести различие между вариантами не­
коего типа, во многих случаях вы можете улучшить программу за счет создания под­
классов:
public class Shape {
private double size;
public Shape(double size) {
t h i s . s i z e = size;
>
public double getSizeQ { return size; }
>
public class Square extends Shape {
public Square(double size) {
super(size);
}
public double area() {
double size = getSizeQ;

Ответы к упражнениям
267
return
s i z e * s i z e ;
}
}
public c l a s s C i r c l e extends Shape {
public C i r c l e ( d o u b l e
s i z e ) {
s u p e r ( s i z e ) ;
}
public double a r e a ( ) {
double s i z e = g e t S i z e ( ) ;
return
M a t h . P I * s i z e * s i z e / 4 . 0 ;
>
}
//
etc...
Упражнение 40 из раздела "Реорганизация"
Ответ: Этот случай интересен. На первый взгляд, кажется разумным, что у окна
должна быть ширина и высота. Однако стоит подумать о будущем. Представим, что
мы хотим обеспечить поддержку окон произвольной формы (что будет весьма трудно,
если класс Window обладает всей информацией о прямоугольниках и их свойствах).
Мы бы предложили абстрагировать форму окна из самого класса Window.
public abstract c l a s s Shape {
/ /
. . .
public abstract boolean overlaps
(Shape
s ) ;
public abstract int
g e t A r e a Q ;
}
public c l a s s Window {
private Shape
shape;
public Window(Shape shape) {
t h i s . s h a p e
= shape;
}
public void setShape(Shape
shape) {
t h i s . s h a p e
= shape;
}
public boolean overlaps(Window
w) {
return
s h a p e . o v e r l a p s ( w . s h a p e ) ;
}
public i n t
g e t A r e a O
{
return shape.
g e t A r e a O ;
}
}
Заметим, что в этом подходе мы предпочли делегирование созданию подклассов:
окно не является "разновидностью" формы — окно "имеет" форму. Оно использует
форму для выполнения своей работы. Вы убедитесь, что во многих случаях делегиро­
вание оказывается полезным для реорганизации.

268
Приложение В
Мы могли бы расширить этот пример, внедрив интерфейс Java, указывающий на
методы, которые должны поддерживаться неким классом для поддержания функций
формы. Это удачная идея. Она означает, что, когда вы расширяете принцип формы,
компилятор предупредит вас о классах, которые вы затронули. Мы рекомендуем ис­
пользовать интерфейсы подобным способом при делегировании всех функций какого-
либо другого класса.
Упражнение 41 из раздела "Программа, которую легко тестировать"
Ответ: Вначале мы добавим подпрограмму main, которая будет действовать как веду­
щий элемент модульного тестирования. В качестве аргумента она примет простой
мини-язык: "Е" будет означать опорожнение смесителя, "F" —• его наполнение, циф­
ры 0 - 9 будут задавать скорость вращения ротора и т.д.
public s t a t i c void main(String a r g s [ ] ) {
//
Create
the
blender
to
test
dbc_ex blender = new dbc_ex();
//
And test
it
according
to
the
string
on standard
input
try {
int a;
char c;
while ((a
= System.in. readO) != -1) {
с = (char)a;
i f
(Character.isWhitespace(c)) {
continue;
}
i f
( C h a r a c t e r . i s D i g i t ( c ) )
{
blender.setSpeed(Character.digit(c, 10));
}
else {
switch ( c ) {
case ' F ' : b l e n d e r . f i l l ( ) ;
break;
case ' E ' : blender.empty();
break;
case ' s ' : System.out.println("SPEED:
" +
blender.getSpeed());
break;
case T :
System.out.println("FULL
" +
b l e n d e r . i s F u l l ( ) ) ;
break;
default: throw new RuntimeException(
"Unknown Test
d i r e c t i v e " ) ;
}
>
}
}
catch (Java.io.IOException e) {
S y s t e m . e r r . p r i n t l n ( ' T e s t jig
failed:
" + e.getMessage());
}

Ответы к упражнениям
269
System.err.println("Completed
blending\n");
System.exit(O);
}
Затем появится сценарий оболочки для управления тестированием.
P./bin/sh
CMD="java dbc.dbc_ex"
failcount=0
expect_okay() {
i f echo "$*" I $CMD n>/dev/null
2>&1
then
else
echo "FAILED!
$*"
failcount='expr Sfailcount + 1'
f i
}
e x p e c t _ f a i l ( ) {
i f echo " $ * " | $CMD >/dev/null 2>&1
then
echo "FAILED!
(Should
have
failed):
$*"
failcount='expr $failcount + 1'
f i
}
reportQ
{
i f [ $failcount -gt 0 ]
then
echo -e "\n\n***
FAILED $failcount
TESTS\n"
exit 1 # In case
we are part
of something
larger
else
exit 0 # In case
we are part
of something
larger
f i
}
#
# Start
the
tests
#
expect_okay F123456789876543210E # Should run thru
e x p e c t _ f a i l F5
# F a i l s ,
speed too high
e x p e c t _ f a i l 1
# F a i l s ,
empty
e x p e c t _ f a i l F10E1 # F a i l s ,
empty
e x p e c t j f a i l F1238 # F a i l s ,
skips
expect_okay FE
# Never turn on
e x p e c t _ f a i l F1E
# Emptying while running
expect_okay F10E # Should be ok
report
# Report r e s u l t s
При тестировании проверяется, не имеют ли место недопустимые переходы в ско­
рости вращения ротора, если вы пытаетесь опорожнить работающий блендер и т.д.
Мы помещаем эту процедуру в сборочный файл, так что можно провести компиляцию
и запустить регрессионный тест, просто введя команду:

270
Приложение В
% make
% make t e s t
Обратите внимание на то, что мы выходим из процедуры тестирования с 0 или 1,
так что мы можем использовать это и как часть более обширного теста.
В требованиях ничего не говорилось ничего о запуске этого компонента через сце­
нарий или даже с использованием языка. Конечные пользователи этого не увидят. Но
у нас есть мощный инструмент, который мы можем использовать для быстрого и ис­
черпывающего тестирования нашей программы.
Упражнение 42 из раздела "Ошибка в определении требований"
Ответ:
1.
Эта инструкция похоже на реальное требование: имеются ограничения, нала­
гаемые на приложение со стороны операционной среды.
2.
Это может быть корпоративным стандартом, но не является требованием. Его
лучше сформулировать так: "Фон диалогового окна должен настраиваться ко­
нечным пользователем. При поставке заказчику цвет будет серым". Еще луч­
ше было бы сформулировать его более широко: "Все визуальные элементы
приложения (цвета, шрифты и языки) должны настраиваться конечным поль­
зователем".
3.
Эта формулировка не является требованием, это архитектура. Когда вы стал­
киваетесь с подобным, вам придется копать очень глубоко, чтобы понять, что
думает пользователь.
4.
Основное требование вероятно выглядит примерно так: "Система предотвра­
щает ввод пользователем недопустимых значений в поля и предупреждает
пользователя, если ввод этих значений имеет место".
5.
Эта формулировка, по всей вероятности, является жестким требованием.
Решение головоломки с четырьмя точками, приведенной в разделе "Разгадка не­
вероятных головоломок".

Э . Х а н т , Д .
Т о м а с
ПРОГРАММИСТ-ПРАГМАТИК
Путь от подмастерья к мастеру
Тема: Программирование
Уровень пользователя: начинающий/опытный
Книга «Программист-прагматик» написана в виде последовательных законченных
разделов и изобилует анекдотами, серьезными примерами и разнообразными
аналогиями. В ней описываются самые интересные случаи из практики авторов
и основные ловушки, относящиеся к разным аспектам разработки программ.
Будь вы новичок, опытный программист или менеджер, ответственный за проекты
в области программного обеспечения, — в любом случае используйте в своей работе
уроки, описанные в книге, и вскоре ваша производительность, точность
и удовлетворение от сделанной работы возрастут. Вы получите навыки и сформируете
привычки, которые станут основой для долгосрочной успешной карьеры.
Вы станете программистом-прагматиком.
Энди Хант — энергичный столяр и музыкант, но (что интересно) пользуется
наибольшим спросом как консультант. Энди специализируется в сочетании
проверенных методик с новейшими технологиями, создавая непривычные,
но от того не менее практичные конструкции. Энди — владелец своей собственной
консалтинговой фирмы в Роли (штат Северная Каролина).
Дейв Томас любит совершать полеты на одномоторных самолетах и оплачивает свою
привычку, отыскивая элегантные решения трудных задач, работая консультантом
в таких разных областях, как аэрокосмическая промышленность, банковские
и финансовые услуги, связь, туризм и транспорт, а также Интернет.
До своего переезда в США (1994) Дейв стал основателем британской компьютерной
фирмы, прошедшей сертификацию по IS09001, которая осуществляла разработку
сложных проектов для конкретных заказчиков по всему миру. В настоящее время
Дейв является независимым консультантом в Далласе (штат Техас).
В настоящее время Дэйв и Энди работают под именем The Pragmatic Programmers,
L L C , предоставляя свои услуги клиентам в США и используя совместный опыт работы,
насчитывающий свыше 40 лет.

