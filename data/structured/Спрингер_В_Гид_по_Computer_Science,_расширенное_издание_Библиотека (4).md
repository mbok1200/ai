


Вильям Спрингер
ДЛЯ КАЖДОГО ПРОГРАММИСТА
ГИД
ПО COMPUTER
SCIENCE
РАСШИРЕННОЕ ИЗДАНИЕ
2021

Вильям Спрингер
Гид по Computer Science, расширенное издание
Перевел с английского А. Павлов

Руководитель дивизиона
Ю. Сергиенко

Руководитель проекта
А. Питиримов

Ведущий редактор
Н. Гринчик

Литературный редактор
Н. Хлебина

Художественный редактор
В. Мостипан

Корректор
Е. Павлович

Верстка
О. Богданович
ББК 32.973.2-018
УДК 004.3

Спрингер Вильям
С74
Гид по Computer Science, расширенное издание. — СПб.: Питер,

## — 304 с.: ил. — (Серия «Библиотека программиста»).


ISBN 978-5-4461-1825-0
Колосс на глиняных ногах — так можно назвать программиста без подготовки в области
Computer Science. Уверенное владение основами позволяет «не изобретать велосипеды»
и закладывать в архитектуру программ эффективные решения. Всё это избавляет от ошибок
и чрезмерных затрат на тестирование и рефакторинг. Не беда, если вы чувствуете себя не у дел,
когда другие программисты обсуждают аппроксимативный предел. Даже специалисты с опытом
допускают ошибки из-за того, что подзабыли Computer Science.
16+ (В соответствии с Федеральным законом от 29 декабря 2010 г. № 436-ФЗ.)
ISBN 978-1951204044 англ.
© William M. Springer II
ISBN 978-5-4461-1825-0
© Перевод на русский язык ООО Издательство «Питер», 2021

© Издание на русском языке, оформление ООО Издательство
«Питер», 2021

© Серия «Библиотека программиста», 2021

© Павлов А., перевод с английского языка, 2021
Права на издание получены по соглашению с William Springer. Все права защищены. Никакая
часть данной книги не может быть воспроизведена в какой бы то ни было форме без письменного
разрешения владельцев авторских прав.
Информация, содержащаяся в данной книге, получена из источников, рассматриваемых издатель­
ством как надежные. Тем не менее, имея в виду возможные человеческие или технические ошибки,
издательство не может гарантировать абсолютную точность и полноту приводимых сведений и не
несет ответственности за возможные ошибки, связанные с использованием книги. Издательство не
несет ответственности за доступность материалов, ссылки на которые вы можете найти в этой книге.
На момент подготовки книги к изданию все ссылки на интернет-ресурсы были действующими.
Изготовлено в России. Изготовитель: ООО «Прогресс книга».
Место нахождения и фактический адрес: 194044, Россия, г. Санкт-Петербург,
Б. Сампсониевский пр., д. 29А, пом. 52. Тел.: +78127037373.
Дата изготовления: 07.2021. Наименование: книжная продукция. Срок годности: не ограничен.
Налоговая льгота — общероссийский классификатор продукции ОК 034-2014, 58.11.12 —
Книги печатные профессиональные, технические и научные.
Импортер в Беларусь: ООО «ПИТЕР М», 220020, РБ, г. Минск, ул. Тимирязева, д. 121/3, к. 214,
тел./факс: 208 80 01.
Подписано в печать 25.06.21. Формат 60×90/16. Бумага офсетная. Усл. п. л. 19,000. Тираж 1000. Заказ 0000.

Оглавление
Введение................................................................................11
Зачем нужна эта книга........................................................11
Чего вы не найдете в издании.............................................12
Дополнительные ресурсы....................................................13
Что дальше.........................................................................14
От издательства..................................................................14
Часть I. Основы Computer Science
Глава 1. Асимптотическое время выполнения ....................... 16

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Насколько сложна задача?..........................................33

Глава 2. Структуры данных ................................................... 34

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Специализированные структуры данных.....................50

Глава 3. Классы задач ........................................................... 51

Часть II. Графы и графовые алгоритмы
Глава 4. Введение в теорию графов ...................................... 60

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Взвешенные и невзвешенные графы...........................79

Глава 5. Структуры данных на основе графов ....................... 80

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Кучи............................................................................85

Глава 6. Хорошо известные графовые алгоритмы ................. 96

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Кратчайшие пути......................................................104

Глава 7. Основные классы графов ....................................... 109

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Графы дуг окружности..............................................117

Часть III. Неграфовые алгоритмы
Глава 8. Алгоритмы сортировки .......................................... 120

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Сортировки для малых наборов данных....................123

6
Оглавление

7
Оглавление

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Сортировки без сравнения........................................130

Часть IV. Методы решения задач
Глава 9. А если в лоб? ......................................................... 136
Глава 10. Динамическое программирование ....................... 139

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Динамическое программирование

и кратчайшие пути..................................................143

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Примеры практического применения.......................145

Глава 11. Жадные алгоритмы .............................................. 148
Часть V. Теория сложности вычислений
Глава 12. Что такое теория сложности ................................ 152
Глава 13. Языки и конечные автоматы ................................ 155

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Рекурсивные и рекурсивно перечислимые языки....174

Глава 14. Машины Тьюринга ............................................... 175

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Проблема остановки...............................................178

Часть VI. Доказательства
Глава 15. Приемлемые доказательства ............................... 180

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Терминология ........................................................181

8
Оглавление
Глава 16. Методы доказательства  ...................................... 184

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Конструктивное доказательство, доказательство

методом исчерпывания вариантов..........................184

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Доказательство на основе закона контрапозиции...191

Глава 17. Сертификаты ....................................................... 192
Часть VII. Безопасность и конфиденциальность
Глава 18. Введение в безопасность ..................................... 196

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Цели.......................................................................199

Глава 19. Введение в криптографию  .................................. 200

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Квантовое распределение ключей..........................205

Глава 20. Криптографическая система с открытым ключом . 207

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Соображения производительности .........................211

Глава 21. Аутентификация пользователя ............................ 213
Часть VIII. Аппаратное и программное
обеспечение
Глава 22. Аппаратные абстракции ...................................... 218

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Данные и методы ввода/вывода..............................221

9
Оглавление

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Регистры.................................................................226

Глава 23. Программные абстракции .................................... 228

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Высокоуровневые языки программирования ..........229

Глава 24. Компьютерная арифметика.................................. 231

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Битовое исключающее ИЛИ....................................235

Глава 25. Операционные системы  ...................................... 237

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Безопасность..........................................................247

Глава 26. Распределенные системы  ................................... 250

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Ложные допущения относительно

распределенных вычислений .................................251

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Синхронизация и согласованность..........................255

Глава 27. Встроенные системы  .......................................... 257
Глава 28. Сети и Интернет .................................................. 260

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Алгоритмы маршрутизации ....................................267

Глава 29. Базы данных ........................................................ 269

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Иерархические базы данных (ИБД).........................272

10
Оглавление
Часть IX. Углубленные темы
Глава 30. Основная теорема о рекуррентных
соотношениях ...................................................... 274
Глава 31. Амортизированное время выполнения ................. 278
Глава 32. Расширяющееся дерево ....................................... 280

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Zig-zag....................................................................282

Глава 33. Декартово дерево  ............................................... 284
Глава 34. Искусственный интеллект  ................................... 287

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Примеры ................................................................293

Глава 35. Квантовые вычисления ........................................ 294

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Практические соображения ...................................296

Послесловие...........................................................................297
Приложения
Приложение A. Необходимая математика .......................... 300
Приложение Б. Классические NP-полные задачи ............... 302
Б.1.	 SAT и 3-SAT...............................................................302
Б.2.	 Клика........................................................................303
Б.3.	 Кликовое покрытие...................................................303
Б.4.	 Раскраска графа........................................................303
Б.5.	 Гамильтонов путь......................................................304
Б.6.	 Укладка рюкзака.......................................................304
Б.7.	 Наибольшее независимое множество........................304
Б.8.	 Сумма подмножества................................................304

Введение
Зачем нужна эта книга
Многие из моих знакомых разработчиков пришли в про­
фессию из самых разных областей. У одних — высшее
образование в области Computer Science; другие изучали
фотографию, математику или даже не окончили уни­
верситет.
В последние годы я заметил, что программисты все чаще
стремятся изучить Compu­ter Science по ряду причин:
z
z чтобы стать хорошими программистами;
z
z чтобы на собеседованиях отвечать на вопросы про
алгоритмы;
z
z чтобы удовлетворить свое любопытство в области
Com­puter Science или наконец перестать сожалеть
о том, что в свое время у них не было возможности
освоить этот предмет.
Эта книга для всех вас.
Многие найдут здесь темы, интересные сами по себе.
Я попытался показать, в каких реальных (неакадемиче­
ских) ситуациях эти знания будут полезны. Хочу, чтобы,
прочитав эту книгу, вы получили такие же знания, как

12
Введение
после изучения базового курса по Computer Science,
а также научились их применять.
Проще говоря, цель этой книги — помочь вам стать
более квалифицированным и опытным программи­
стом благодаря лучшему пониманию Computer Science.
Мне не под силу втиснуть в одну книгу 20-летний стаж
преподавания в колледже и профессиональный опыт...
однако я постараюсь сделать максимум того, на что
способен. Надеюсь, что вы найдете здесь хотя бы одну
тему, о которой сможете сказать: «Да, теперь мне это
понятно» — и применить знания в своей работе.
Разослав на рассмотрение черновой вариант книги,
я получил множество однотипных отзывов. Слишком
много материала. Слишком сложно для восприятия.
Слишком устрашающе.
Полученные комментарии способствовали внесению
нескольких изменений. Текст был сокращен и упро­
щен; подробности, не имеющие непосредственного
отношения к рассматриваемой теме, опущены. Книга
была разбита на части, причем самые важные темы
идут в первой половине. В результате она получилась
менее устрашающей и более понятной.
Чего вы не найдете в издании
Смысл книги состоит в том, чтобы читатель смог луч­
ше понимать Computer Science и применять знания на
практике, а вовсе не в том, чтобы полностью заменить
четыре года обучения.

13
Введение
В частности, это не книга с доказательствами. Дей­
ствительно, начиная с части VI, рассмотрены мето­
ды доказательства, однако стандартные алгоритмы
обычно приводятся здесь без доказательств. Идея
в том, чтобы читатель узнал о существовании этих
алгоритмов и научился их использовать, не вникая
в подробности. В качестве книги с доказательствами,
написанной для студентов и аспирантов, я настоя­
тельно рекомендую Introduction to Algorithms1 («Алго­
ритмы. Вводный курс») Кормена (Cormen), Лейзер­
сона (Leiserson), Ривеста (Rivest) и Стейна (Stein)
(этих авторов обычно объединяют под аббревиатурой
CLRS).
Это и не книга по программированию: вы не найдете
здесь рекомендаций, когда использовать числа типа
int, а ко­гда — double, или объяснений, что такое цикл.
Предполагается, что читатель сможет разобраться
в листингах на псевдокоде, используемых для опи­
сания алго­ритмов2. Цель книги — связать концепции
Computer Science с уже знакомыми читателю методами
программирования.
Дополнительные ресурсы
Для тех, кто хочет подробнее изучить ту или иную
тему, я включил в сноски ссылки на дополнительные
1
Cormen T. H., Leiserson C. E., Rivest R. L., Stein C. Introduction
to Algorithms, 3rd Edition. The MIT Press, 2009.
2
Все программы в этой книге написаны на псевдокоде на осно­
ве языка С.

14
Введение
материалы. Кроме того, по адресу http://www.whatwil­
liamsaid.com/books/ вы найдете тесты для самопроверки
к каждой главе.
Что дальше
Я был намеренно краток и старался опускать детали, ко­
торые, будучи интересными сами по себе, не требуются
для понимания описываемых концепций. В следующих
книгах я собираюсь более подробно остановиться на
некоторых областях, представляющих особый интерес.
Чтобы предложить тему для следующей книги, подпи­
саться на рассылку или просто задать вопрос, посетите
мой сайт: http://www.whatwilliamsaid.com/books. С нетерпени­
ем жду ваших сообщений.
От издательства
Ваши замечания, предложения, вопросы отправляйте
по адресу comp@piter.com (издательство «Питер», ком­
пьютерная редакция).
Мы будем рады узнать ваше мнение!
На веб-сайте издательства www.piter.com вы найдете по­
дробную информацию о наших книгах.

Часть I
Основы Computer
Science

1
Асимптотическое
время выполнения

## — 304 с.: ил. — (Серия «Библиотека программиста»).
### Что такое алгоритм

Предположим, вам нужно научить робота делать бутер­
брод с арахисовым маслом (рис. 1.1). Ваши инструкции
могут быть примерно такими.

## Взять банку с арахисовым маслом и вынуть ее из


шкафчика.

## Держа банку с арахисовым маслом в левой руке,


взять крышку в правую руку.

## Поворачивать правую руку против часовой стрелки,


пока крышка не откроется.

## И так далее...


Это программа: вы описали каждый шаг, который ком­
пьютер должен выполнить, и указали всю информа­
цию, которая требуется компьютеру для выполнения
каждого шага. А теперь представьте, что вы объясняете

17
Глава 1. Асимптотическое время выполнения
человеку, как сделать бутерброд с арахисовым маслом.
Ваши инструкции будут, скорее всего, такими.

## Намажьте ножом арахисовое масло на один ломтик


хлеба.

## Сложите два ломтика вместе. Приятного аппетита!


Это алгоритм: процесс, которому нужно следовать для
получения желаемого результата (в данном случае бу­
терброда с арахисовым маслом и джемом). Обратите
внимание, что алгоритм более абстрактный, чем про­
грамма. Программа сообщает роботу, откуда именно
нужно взять предметы на конкретной кухне, с точным
указанием всех необходимых деталей. Это реализация
алгоритма, которая предоставляет все важные детали,
Рис. 1.1. Робот — изготовитель бутербродов

18
Часть I. Основы Computer Science
но может быть выполнена на любом оборудовании
(в данном случае — на кухне), со всеми необходимыми
элементами (арахисовое масло, джем, хлеб и столовые
приборы).

## Сложите два ломтика вместе. Приятного аппетита!
### Почему скорость имеет

значение
Современные компьютеры достаточно быстры, поэто­
му во многих случаях скорость алгоритма не особенно
важна. Когда я нажимаю кнопку и компьютер реагирует
за 1/25 секунды, а не за 1/100 секунды, эта разница для
меня не имеет значения — с моей точки зрения, ком­
пьютер в обоих случаях реагирует мгновенно.
Но во многих приложениях скорость все еще важна, на­
пример, при работе с большим количеством объектов.
Предположим, что у вас есть список из миллиона элемен­
тов, который необходимо отсортировать. Эффективная
сортировка занимает одну секунду, а неэффективная
может длиться несколько недель. Возможно, пользова­
тель не захочет ждать, пока она закончится.
Мы часто считаем задачу неразрешимой, если не су­
ществует известного способа ее решения за разумные
сроки, где «разумность» зависит от различных реальных
факторов. Например, безопасность шифрования данных
часто зависит от сложности разложения на множите­
ли (факторизации) больших чисел. Если я отправляю
вам зашифрованное сообщение, содержимое которого
нужно хранить в секрете в течение недели, то для меня
не имеет значения, что злоумышленник перехватит это
сообщение и расшифрует его через три года. Задача

19
Глава 1. Асимптотическое время выполнения
не является неразрешимой — просто наш любитель под­
слушивать не знает, как решить ее достаточно быстро,
чтобы решение было полезным.
Важным навыком в программировании является уме­ние
оптимизировать только те части программы, которые
необходимо оптимизировать. Если пользовательский
интерфейс работает на 1/1000 секунды медленнее,
чем мог бы, это никого не волнует — в данном случае
мы предпочли бы незаметному увеличению скоро­
сти удобочитаемую программу. А вот код, располо­
женный внутри цикла, который может выполняться
миллионы раз, должен быть написан максимально
эффективно.

## Сложите два ломтика вместе. Приятного аппетита!
### Когда секунды (не) считаются

Рассмотрим алгоритм приготовления бутербродов из
раздела 1.1. Поскольку мы хотим, чтобы этот алгоритм
можно было использовать для любого количества раз­
личных роботов — изготовителей бутербродов, мы
не хотим измерять количество секунд, затрачиваемое
на выполнение алгоритма, поскольку для разных робо­
тов оно будет различаться. Один робот может дольше
открывать шкафчик, но быстрее вскрывать банку с ара­
хисовым маслом, а другой — наоборот.
Вместо того чтобы измерять фактическую скорость
выполнения каждого шага, которая будет различаться
для разных роботов и кухонь, лучше подсчитать (и ми­
нимизировать) количество шагов. Например, алгоритм,
который требует, чтобы робот сразу брал и нож и ложку,
эффективнее, чем алгоритм, в котором робот открывает

20
Часть I. Основы Computer Science
ящик со столовыми приборами, берет нож, закрывает
ящик, кладет нож на стол, снова открывает ящик, до­
стает ложку и т. д.
Измерение времени: алгоритм или программа?
Напомню, что алгоритмы являются более обобщенны­
ми, чем программы. Для нашего алгоритма приготов­
ления бутербродов мы хотим посчитать число шагов.
Если бы мы действительно использовали конкретного
робота — изготовителя бутербродов, то нас бы больше
интересовало точное время, которое требуется для из­
готовления каждого бутерброда.
Следует признать, что не все шаги потребуют одинакового
времени выполнения; скорее всего, взять нож — быстрее,
чем намазать арахисовое масло на хлеб. Поэтому мы хо­
тим не столько узнать точное количество шагов, сколько
иметь представление о том, сколько шагов потребуется
в зависимости от размера входных данных. В случае с на­
шим роботом время, необходимое для приготовления
бутерброда, при увеличении количества бутербродов
не увеличивается (при условии, что нам хватит джема).
Два компьютера могут выполнять алгоритм с разной
скоростью. Это зависит от их тактовой частоты, объ­
ема доступной памяти, количества тактовых циклов,
требуемого для выполнения каждой инструкции, и т. д.
Однако обоим компьютерам, как правило, требуется
приблизительно одинаковое число инструкций, и мы
можем измерить скорость, с которой количество тре­
буемых инструкций увеличивается в зависимости от
размера задачи (рис. 1.2). Например, при сортировке

21
Глава 1. Асимптотическое время выполнения
массива чисел, если увеличить его размер в тысячу раз,
один алгоритм может потребовать в тысячу раз больше
команд, а второй — в миллион раз больше1.
Рис. 1.2. Более эффективный робот — изготовитель
бутербродов
Часто мы хотим измерить скорость алгоритма несколь­
кими способами. В жизненно важных ситуациях —
например, при запуске двигателей на зонде, который
приземляется на Марсе, — мы хотим знать время выпол­
нения при самом неблагоприятном раскладе. Мы можем
выбрать алгоритм, который в среднем работает немного
медленнее, но зато гарантирует, что его выполнение ни­
когда не займет больше времени, чем мы считаем при­
емлемым (и наш зонд не разобьется вместо того, чтобы
приземлиться). Для более повседневных сценариев мы
1
Конкретные примеры см. в главе 8.

22
Часть I. Основы Computer Science
можем смириться со случайными всплесками времени
выполнения, если при этом среднее время не растет;
например, в видеоигре мы бы предпочли генерировать
результаты в среднем быстрее, смирившись с необхо­
димостью время от времени прерывать длительные
вычисления. А бывают случаи, когда мы хотели бы
знать наилучшую производительность. Однако в боль­
шинстве ситуаций мы просто рассчитываем наихудшее
время выполнения, которое все равно часто совпадает
со средним временем выполнения.

## Сложите два ломтика вместе. Приятного аппетита!
### Как мы описываем скорость

Предположим, у нас есть два списка целых чисел,
которые мы хотим отсортировать: {1, 2, 3, 4, 5, 6, 7, 8}
и {3, 5, 4, 1, 2}. Сортировка какого списка займет меньше
времени?
Ответ на вопрос: неизвестно. Для одного алгоритма
сортировки тот факт, что первый список уже отсорти­
рован, позволит почти сразу завершить работу. Для дру­
гого алгоритма решающим фактором может быть то, что
второй список короче. Но обратите внимание, что оба
свойства входных данных — размер списка и последова­
тельность расположения чисел — влияют на количество
шагов, необходимых для сортировки.
Если некоторое свойство, например «отсортирован­
ность», изменяет время выполнения конкретного алго­
ритма только на постоянную величину, мы можем про­
сто его игнорировать, поскольку его влияние незаметно
по сравнению с влиянием размера задачи. Например,
робот может делать бутерброды с виноградным или

23
Глава 1. Асимптотическое время выполнения
малиновым джемом, но банка с малиновым джемом от­
крывается немного дольше. Если робот делает миллион
бутербродов, то влияние выбора джема на время приго­
товления бутерброда незаметно на фоне количества бу­
тербродов. Поэтому мы можем его игнорировать и про­
сто сказать, что приготовление миллио­на бутербродов
занимает примерно в миллион раз больше времени, чем
приготовление одного бутерброда.
С точки зрения математики мы вычисляем асимпто­
тическое время выполнения алгоритма, то есть ско­
рость увеличения времени выполнения в зависимости
от размера входных данных. Нашему роботу, который
делает бутерброды, требуется некоторое постоянное
время c для приготовления одного бутерброда и в n раз
больше времени, то есть cn, чтобы сделать n бутербро­
дов. Мы отбрасываем константу и говорим, что наш
алгоритм приготовления бутербродов занимает время
O(n) (произносится как «О большое от n» или просто
«О от n»). Это означает, что время выполнения в худ­
шем случае пропорционально количеству бутербро­
дов, которое будет сделано. Нас интересует не точное
количество необходимых шагов, а скорость, с которой
это число увеличивается по мере роста размера задачи
(в данном случае — количества бутербродов).

## Сложите два ломтика вместе. Приятного аппетита!
### Скорость типичных алгоритмов

Сколько бы бутербродов ни делал наш робот, это не уве­
личивает время, необходимое для изготовления одного
бутерброда. Это линейный алгоритм — общее время вы­
полнения пропорционально количеству обрабатываемых
элементов. Для большинства задач это лучшее, чего

24
Часть I. Основы Computer Science
можно добиться1. Типичный пример линейного алго­
ритма в программировании — чтение списка элементов
и выполнение некоторой задачи для каждого элемента
списка: время, затрачиваемое на обработку каждого
элемента, не зависит от других элементов. Есть цикл,
который выполняет постоянный объем работы и осу­
ществляется один раз для каждого из n элементов, по­
этому все вместе занимает O(n) времени.
Но чаще количество элементов списка влияет на объем
работы, которую необходимо выполнить для отдельного
элемента. Алгоритм сортировки может обрабатывать
каждый элемент списка, разделяя список на два мень­
ших списка, и повторять это до тех пор, пока все элемен­
ты не окажутся в своем собственном списке. На каждой
итерации алгоритм выполняет O(n) операций и требует
O(lg n) итераций, что в общей сложности составляет
O(n) × O(lg n) = O(n lg n) времени.2
Математическое предупреждение
Логарифм описывает, в какую степень необходимо возве­
сти число, указанное в основании, чтобы получить желае­
мое значение. Например, log10 1000 = 3, так как 103 = 1000.
В компьютерах мы часто делим на 2, поэтому обычно
используются логарифмы по основанию 2. Сокращенно
log2 n обозначается как lg n.2 Таким образом, lg 1 = 0,
lg 2 = 1, lg 4 = 2, lg 8 = 3 и т. д.
1
Поскольку n — это размер входных данных, то в общем случае
только для их чтения требуется время O(n).
2
Строго говоря, lg — это логарифм по основанию 10, но часто
именно в Computer Science принимают, что это логарифм по
основанию 2. — Примеч. науч. ред.

25
Глава 1. Асимптотическое время выполнения
С этого момента время выполнения начинает ухуд­
шаться. Рассмотрим алгоритм, в котором каждый эле­
мент множества сравнивается со всеми остальными
элементами множества, — здесь мы выполняем работу,
занимающую O(n) времени, O(n) раз, то есть общее
время выполнения алгоритма — O(n2). Это квадра­
тичное время.
Все алгоритмы, у которых время выполнения пропор­
ционально количеству входных данных, возведенному
в некоторую степень, называются полиномиальными
алгоритмами; такие алгоритмы принято считать бы­
стрыми. Конечно, алгоритм, решение которого пропор­
ционально количеству входных данных в сотой степе­
ни, хоть и является полиномиальным, все же не будет
считаться быстрым даже при большом воображении!
Однако на практике задачи, о которых известно, что они
имеют полиномиальное время решения, как правило,
решаются за биквадратное (четвертой степени) время
или еще быстрее.
Это не означает, что асимптотически более эффек­
тивный алгоритм всегда будет работать быстрее, чем
асимптотически менее эффективный. Например, ваш
жесткий диск вышел из строя и вы потеряли несколько
важных файлов. К  счастью, вы сделали их резервную
копию в Сети1.
Вы можете загрузить файлы из облака со скоростью
10 Мбит/с (при условии, что у вас хорошее соединение).
1
В этом примере я использовал цифры для резервного ко­
пирования из облака Carbonite, но есть и много других.
Это ни в коем случае не реклама, а всего лишь первый по­
павшийся сервис, который я обнаружил при поиске.

26
Часть I. Основы Computer Science
Это линейное время — количество времени, которое
требуется для извлечения всех потерянных файлов,
и оно более или менее прямо пропорционально за­
висит от размера файлов. Служба резервного копиро­
вания также предлагает загрузить файлы на внешний
диск и отправить их вам — это действие занимает по­
стоянное время, или O(1), потому что время получе­
ния этих данных не зависит от их размера1. Если речь
идет о восстановлении всего нескольких мегабайтов,
то загрузить их напрямую будет намного быстрее.
Но, как только файл достигнет такого размера, что его
загрузка будет занимать столько же времени, сколь­
ко и отправка, удобнее будет использовать внешний
диск.
Если полиномиальные алгоритмы быстрые, то какие же
алгоритмы медленные? Для некоторых алгоритмов
(называемых экспоненциальными) число операций огра­
ничено не размером входных данных, возведенным
в некоторую постоянную степень, а константой, воз­
веденной в степень, равную размеру входных данных.
В качестве примера рассмотрим попытку угадать чис­
ловой код доступа длиной n символов. Если это десять
1
Ну хорошо, почти не зависит — это занимает 1–3 рабочих
дня. «Не зависит» в данном случае означает не то, что некая
операция всегда занимает одинаковое время, а лишь то, что
время выполнения не зависит от количества входных дан­
ных. Мы также предполагаем, что компания, занимающаяся
резервным копированием, может подготовить вашу копию
достаточно быстро, так что они не пропустят отправку почты
из-за очень большого размера файла.

27
Глава 1. Асимптотическое время выполнения
цифр от 0 до 9, то количество возможных кодов со­
ставляет 10n. Обратите внимание, что это число растет
намного быстрее, чем n10: если n равно всего 20, полино­
миальный алгоритм работает уже почти в 10 миллионов
раз быстрее (рис. 1.3)!
Рис. 1.3. Даже при небольшом количестве входных
данных различия в асимптотическом времени
выполнения быстро становятся заметными

## Сложите два ломтика вместе. Приятного аппетита!
### Всегда ли полиномиальное

время лучше?
Как правило, специалисты по Computer Science заин­
тересованы получить полиномиальное решение зада­
чи, особенно если оно выполняется за квадратичное
время или еще быстрее. Однако для задач разумного

28
Часть I. Основы Computer Science
(небольшого) размера экспоненциальные алгоритмы
также могут быть приемлемы.
Зачастую мы можем найти приближенное решение
задачи за полиномиальное время, однако получить
точный (или близкий к точному) ответ можем лишь
за экспоненциальное время. Рассмотрим в качестве
примера задачу коммивояжера: продавец хотел бы
посетить каждый город на своем маршруте ровно один
раз и вернуться домой, преодолев минимальное рас­
стояние. (Представьте себе, сколько денег сэкономи­
ли бы службы доставки UPS и FedEx, если бы сделали
свои маршруты всего лишь немного более эффектив­
ными!)
Чтобы получить точный ответ, нужно вычислить все
возможные маршруты и сравнить их суммарные рас­
стояния, то есть O(n!) возможных путей. Очень близкое
к оптимальному (в пределах до 1 %) решение может
быть найдено за экспоненциальное время1. Но возмож­
ное «достаточно хорошее» (в пределах 50 % от опти­
мального) решение может быть найдено за полиноми­
альное время2. Это обычный компромисс: мы можем
быстро получить достаточно хорошее приближение или
медленнее — более точный ответ.
1
Подробный обзор различных подходов вы найдете в статье:
Applegate D. L., Bixby R. E., Chva'tal V., Cook W. J. The Traveling
Salesman Problem.
2
На момент написания этой книги были известны алго­
ритмы, позволяющие найти решение хуже оптимального
не более чем на 50 % за время O(n3). См., например, статью:
Sebo.. A., Vygen J. Shorter Tours by Nicer Ears, 2012.

29
Глава 1. Асимптотическое время выполнения

## Сложите два ломтика вместе. Приятного аппетита!
### Время выполнения алгоритма

Рассмотрим следующий код:
foreach (name in NameCollection)
{
Print "Hello, {name}!";
}
Здесь у нас есть коллекция из n строк; для каждой строки
выводится короткое сообщение. Вывод сообщения за­
нимает постоянное время1, то есть O(1). Мы делаем это
n раз, то есть O(n). Умножив одно на другое, получим
результат: время выполнения кода составляет O(n).
А теперь рассмотрим другую функцию:
DoStuff (numbers)
{
sum = 0;
foreach (num in numbers)
{
sum += num;
}
product = 1;
foreach (num in numbers)
{
product *= num;
}
Print "The sum is {sum} and the
product is {product}";
}
1
Это не означает, что для каждой строки требуется одинаковое
время; время, необходимое для вывода каждой строки, не за­
висит от количества строк.

30
Часть I. Основы Computer Science
Здесь есть два цикла; каждый из них состоит из O(n)
итераций и на каждой итерации выполняет постоянную
работу, то есть общее время выполнения каждого цикла
составляет O(n). Сложив O(n) и O(n) и отбросив кон­
станту, мы снова получим не O(2n), а O(n). Представлен­
ную выше функцию также можно написать так:
DoStuff (numbers)
{
sum = 0 , product = 1;
foreach (num in numbers)
{
sum += num;
product *= num;
}
Print "The sum is {sum} and the
product is {product}";
}
Теперь у нас есть только один цикл, который снова вы­
полняет постоянную работу; просто у него константа
больше, чем раньше. Помните, что нас интересует, на­
сколько быстро растет время выполнения задачи при
увеличении ее размера, а не точное число операций для
данного размера задачи.
Теперь попробуем что-нибудь более сложное. Каково
время выполнения этого алгоритма?
CountInventory (stuffToSell, colorList)
{
totalItems = 0;
foreach (thing in stuffToSell)
{
foreach (color in colorList)

31
Глава 1. Асимптотическое время выполнения
{
totalItems += thing[color];
}
}
}
Здесь у нас есть два цикла, причем один вложен в дру­
гой. Поэтому мы будем умножать их время выполнения,
а не складывать. Внешний цикл запускается один раз
для каждого элемента каталога, а внутренний — один
раз для каждого предоставленного цвета. Для n элемен­
тов и m цветов общее время выполнения равно O(nm).
Обратите внимание, что это не O(n2); у нас нет оснований
полагать, что между n и m существует взаимосвязь.
Рассмотрим еще одну функцию:
doesStartWith47 (numbers)
{
return (numbers[0] == 47);
}
Эта функция проверяет, равен ли 47 первый элемент
целочисленного массива, и возвращает результат. Объ­
ем работы, который выполняет функция, не зависит от
количества входных данных и поэтому равен O(1)1.
Мы часто пишем программы, которые включают в себя
двоичный поиск, следовательно, в нашем анализе будут
логарифмы.
1
Здесь, конечно, предполагается, что массив передается по
ссылке; если массив передается по значению, то время вы­
полнения составит O(n).

32
Часть I. Основы Computer Science
Например, рассмотрим следующий код1:
binarySearch (numarray, left, right, x)
{
if (left > right) { return -1; }
int mid = 1 + (right - 1)/2;
if (numarray[mid] == x) { return mid; }
if (numarray[mid] > x)
{ return binarySearch (numarray, left,
mid -1, x); }
return binarySearch (numarray, mid + 1, right, x);
}
Исходя из предположения, что массив отсортирован,
мы проверяем, является ли средний элемент массива
тем, что мы ищем. Если это так, то возвращаем ин­
декс среднего элемента. Если же нет и средний эле­
мент больше требуемого значения, то мы проделыва­
ем то же самое с первой половиной массива, а если
больше — то со второй половиной. Для каждого ре­
курсивного вызова выполняется постоянный объем
работы (проверка, что значение left не больше, чем
right; это подразумевает, что мы выполнили поиск
по всему массиву и искомое значение не было найде­
но; затем вычисление средней точки и сравнение ее
значения с тем, что мы ищем). Мы выполняем O(lg n)
вызовов, каждый из которых занимает O(1) времени,
поэтому общая сложность двоичного поиска состав­
ляет O(lg n).
1
Как показывает практика, лучше перенести проверку left > right
в конец, поскольку это менее распространенный случай; мы
поступили так, чтобы обойтись без вложенности.

33
Глава 1. Асимптотическое время выполнения
Углубленные темы
Представьте, что у нас есть рекурсивная функция, ко­
торая разбивает задачу на две части, размер каждой из
них составляет 2/3 от размера оригинала? Формула для
вычисления такой рекурсии действительно существует;
подробнее о ней и об основной теореме (Master Theorem)
вы узнаете в главе 31.

## Сложите два ломтика вместе. Приятного аппетита!
### Насколько сложна задача?

Если есть алгоритм для решения задачи, определить
время выполнения этого алгоритма обычно довольно
просто. Но что, если у нас еще нет алгоритма, но уже
нужно понять, насколько сложно будет решить задачу?
Мы можем это сделать, сравнивая задачу с другими по­
добными задачами, для которых известно время выпол­
нения. Мы можем разделить задачи на классы — наборы
задач, имеющих сходные характеристики. Нас интере­
суют два основных класса: задачи, которые решаются
за полиномиальное время, и задачи, решение которых
можно проверить за полиномиальное время. Оба этих
класса мы рассмотрим в следующей главе.

2
Структуры данных

## Сложите два ломтика вместе. Приятного аппетита!
### Организация данных

Одно из главных понятий Computer Science — структу­
ры данных. Говоря о времени выполнения алгоритмов,
мы предполагаем, что данные хранятся в соответству­
ющей структуре, которая позволяет эффективно их
обрабатывать. Какая структура лучше, зависит от типа
данных и от того, какой доступ к ним нужен.
z
z Необходим ли произвольный доступ, или достаточно
последовательного?
z
z Будут ли данные при записи всегда добавляться
в конец списка, или нужна возможность вставлять
значения в середину?
z
z Допускаются ли повторяющиеся значения?
z
z Что важнее: наименьшее возможное время доступа
или строгая верхняя граница времени выполнения
каждой операции?
Ответы на все эти вопросы определяют то, как должны
храниться данные.

35
Глава 2. Структуры данных

## Сложите два ломтика вместе. Приятного аппетита!
### Массивы, очереди и другие

способы построиться
Возможно, самая известная структура данных — это
массив, набор элементов, проиндексированных ключом.
Элементы массива хранятся последовательно, причем
ключ имеет форму смещения относительно начальной
позиции в памяти, благодаря чему можно вычислить
положение любого элемента по его ключу. Именно по­
этому индексы массива1 обычно начинаются с нуля;
первый элемент массива находится на нулевом расстоя­
нии от начала, следующий — на расстоянии одного эле­
мента от начала и т. д. «На расстоянии одного элемента»
может означать один байт, одно слово и т. д., в зависи­
мости от размера данных. Важно, что каждый элемент
массива занимает одинаковое количество памяти.
Польза массивов состоит в том, что получение или со­
хранение любого элемента массива занимает постоян­
ное время, а весь массив занимает O(n) места в памяти2.
Если количество элементов заранее известно, то память
не расходуется зря; поскольку позиция каждого эле­
мента вычисляется просто по смещению относительно
начала, нам не нужно выделять место для указателей.
Поскольку элементы массива расположены в смежных
областях памяти, перебор значений массива, очевидно,
1
В английском языке есть два варианта множественного числа
от слова index (индекс): array indices для индексов массива,
но database indexes — для индексов базы данных.
2
Помните: если не указано иное, буквой n обозначается коли­
чество элементов.

36
Часть I. Основы Computer Science
выполняется гораздо быстрее, чем для многих других
структур данных из-за меньшего количества неудачных
обращений к кэш-памяти1.
Однако требование выделения непрерывного блока
памяти может сделать массивы плохим выбором, когда
число элементов заранее не известно. С ростом размера
массива может понадобиться скопировать его в другое
место памяти (при условии, что оно есть). Избежать
этой проблемы, предварительно выделив гораздо боль­
ше места, чем необходимо, бывает довольно затратно2.
Другая проблема — вставка и удаление элементов мас­
сива занимает много времени (O(n)), поскольку при­
ходится перемещать все элементы массива.
На практике массивы используются как сами по себе,
так и для реализации многих других структур данных,
которые накладывают дополнительные ограничения на
манипулирование данными. Например, строка может
быть реализована в виде массива символов. Очередь —
это последовательный список, в котором элементы до­
бавляются только в один конец списка (постановка
в очередь), а удаляются из другого (извлечение из оче­
реди); таким образом, очередь может быть реализована
1
Это так называемая локальность ссылок: как только мы по­
лучили доступ к элементу, вполне вероятно, что в ближай­
шем будущем также понадобится доступ к другим элемен­
там, находящимся поблизости. Поскольку мы уже загрузили
страницу, содержащую первый элемент, в кэш, то получение
ближайших элементов (которые, вероятно, находятся на
той же странице) происходит быстрее.
2
Это особенно актуально при работе со встроенными система­
ми, которые, как правило, имеют ограниченный объем памяти.

37
Глава 2. Структуры данных
как массив, в котором «начало» перемещается вместе
с началом очереди при условии, что максимальное ко­
личество элементов в очереди никогда не превышает
размер массива. Однако очередь неопределенной дли­
ны лучше реа­лизовать на основе двусвязного списка
(см. раздел 2.3). К другим структурам, реализуемым на
основе массивов, относятся списки, стеки и кучи (см.
раздел 2.4), очереди с приоритетом (которые часто соз­
даются на основе куч) и хеш-таблицы (см. раздел 2.5).

## Сложите два ломтика вместе. Приятного аппетита!
### Связные списки

Связный список — это структура данных, в которой
каждый элемент содержит данные и указатель на сле­
дующий элемент списка (а если это двусвязный список,
то также ссылку на предыдущий элемент). Указатель
на связный список — это просто указатель на первый
элемент, или head, списка; поскольку элементы могут
размещаться в разных местах выделенной памяти, для
поиска указанного элемента необходимо начать с пер­
вого элемента и пройтись по всему списку.
Как уже говорилось, многие структуры данных реа­
лизованы на основе массивов или связных списков.
Во многом связный список является дополнением мас­
сива. Если сильная сторона массива — быстрый доступ
к любому элементу (по его ключу), то для того, чтобы
найти элемент списка, необходимо пройти по всем
ссылкам, пока не будет найден нужный элемент, что
в худшем случае займет O(n) времени. С другой сторо­
ны, массив имеет фиксированный размер, а элементы
связного списка могут размещаться в любом месте

38
Часть I. Основы Computer Science
памяти, и список может произвольно увеличиваться
до тех пор, пока не будет исчерпана доступная память.
Кроме того, вставка и удаление элементов массива
очень затратны, а в связном списке эти операции вы­
полняются за постоянное время, если есть указатель на
предыдущий узел (рис. 2.1).
Рис. 2.1. Удаление узла из связного списка
Практическое применение
Представьте себе поезд как пример двусвязного списка:
каждый вагон связан с предыдущим и (если он суще­
ствует) со следу­ющим. В конец поезда можно легко
добавить вагоны, но можно вставить вагон и в середину
поезда, отсоединив и (пере)присоединив существую­
щие вагоны перед и после добавляемых, или же можно
отсоединить вагоны в середине поезда, откатить их на
боковой путь и присоединить оставшиеся вагоны. А вот
извлечь вагон напрямую не получится; для этого нужно
сначала пройти по всему поезду и отделить нужный
вагон от предыдущего.

39
Глава 2. Структуры данных
Теоретическая глупость
Как-то мой преподаватель спросил у группы студентов,
как определить, содержит ли связный список цикл. Есть
несколько классических решений этой задачи. Один из
способов — обратить указатели на элементы списка, когда
мы их проходим; если цикл существует, то мы в итоге вер­
немся к началу списка. Другой способ: обходить список
с двумя указателями, так что один указатель ссылается
на следующий элемент, а второй — через один элемент.
Если в списке существует цикл, то в итоге оба указателя
когда-нибудь будут ссылаться на один и тот же элемент.
Однако преподаватель добавил условие: он сказал, что
ему все равно, сколько времени займет выполнение на­
шего метода. Я предложил несколько глупый вариант:
вычислить объем памяти, необходимый для хранения
одного узла списка, и разделить на него общую память
системы. Потом вычислить количество посещенных
элементов. Если число посещенных элементов превы­
шает количество узлов, которые могут быть сохранены
в памяти, список должен содержать цикл.
Преимущество этого решения неоднозначно: оно тре­
бует безумно много времени (определяемого размером
памяти, а не списка) и является абсолютно правильным.

## Сложите два ломтика вместе. Приятного аппетита!
### Стеки и кучи

2.4.1.  Стеки
Стек — это структура данных типа LIFO (Last In, First
Out — «последним пришел, первым ушел»), в которой
элементы добавляются или удаляются только сверху;
это называется «поместить элемент в стек» (push) или
«извлечь его из стека» (pop) (рис. 2.2).

40
Часть I. Основы Computer Science
Стек можно реализовать на основе массива (отслежи­
вая текущую длину стека) или на основе односвязно­
го списка (отслеживая head списка1). Как и в случае
с очередями, реализация на основе массива проще, но
она накладывает ограничение на размер стека. Стек,
реализованный на основе связного списка, может расти
до тех пор, пока хватает памяти.
Рис. 2.2. Элементы всегда помещаются в вершину стека
Стеки поддерживают четыре основные операции, каждая
из которых может быть выполнена за время O(1): push
(поместить элемент в стек), pop (извлечь элемент из сте­
ка), isEmpty (проверить, пуст ли стек) и size (получить
количество элементов в стеке). Часто также реализуют
операцию peek (просмотреть верхний элемент стека, но
1
Вместо того чтобы добавлять новые элементы в конец списка,
их можно просто помещать в начало. Тогда извлекаемый
элемент всегда будет первым в списке.

41
Глава 2. Структуры данных
не удалять его), что эквивалентно извлечению верхнего
элемента и его повторному помещению в стек.
При помещении элемента в стек может возникнуть ис­
ключение, если размер стека ограничен, и в настоящее
время стек заполнен (ошибка переполнения), а при
извлечении элемента из стека возникает исключение,
если в данный момент стек пуст (ошибка обнуления).
Несмотря на то что в стеках не допускается произволь­
ный доступ, они очень полезны в тех компьютерных
вычислениях, для которых требуется ведение истории,
от операций Undo до рекурсивных вызовов функций.
В этом случае стек обеспечивает возможность обрат­
ного перебора, если необходимо вернуться к предыду­
щему состоянию. В разделе 13.3 вы увидите, как стеки
используются для реализации магазинных автоматов,
способных распознавать контекстно свободные языки.
Типичным примером использования стека является про­
верка сбалансированности фигурных скобок. Рассмо­
трим язык, в котором скобки должны быть парными:
каждой правой скобке (}) предшествует соответству­
ющая левая скобка ({). Мы можем прочитать строку
и каждый раз, когда встречается левая скобка, помещать
ее в стек. Все­гда, когда встречается правая скобка, мы
будем извлекать левую скобку из стека. Если попытать­
ся извлечь фигурную скобку из стека, но стек окажет­
ся пустым, это будет означать, что у правой фигурной
скобки нет соответствующей левой скобки. Если в конце
строки стек окажется непустым, это будет означать, что
считано больше левых скобок, чем правых. В противном
случае все скобки в строке окажутся парными.

42
Часть I. Основы Computer Science
2.4.2.  Кучи
Кучи, подобно стекам, как правило, реализуются на
основе массивов. Как и в стеке, в куче можно удалить
за один раз только один элемент. Однако это будет
не последний добавленный, а наибольший (для max-
кучи) или наименьший элемент (для min-кучи). Куча
частично упорядочена по ключам элементов, так что
элемент с наивысшим (или низшим) приоритетом все­
гда хранится в корне кучи (рис. 2.3).
Рис. 2.3. Узлы-братья (узлы с одним и тем же родителем)
в куче никак не взаимосвязаны; просто каждый узел имеет
более низкий приоритет, чем его родитель
Словом «куча» называют структуру данных, которая
удовлетворяет свойству упорядоченности кучи: неубы­
вания (min-куча) (значение каждого узла не меньше, чем
у его родителя) либо невозрастания (max-куча) (значение
каждого узла не больше, чем у родителя). Если не указа­
но иное, то, говоря о куче, мы имеем в виду двоичную
кучу, которая является полным двоичным деревом1, ко­
торое удовлетворяет свойству упорядоченности кучи;
1
Двоичное дерево, в котором каждый уровень, за исключением,
возможно, нижнего, имеет максимальное количество узлов.
Подробнее о деревьях читайте в главе 5.

43
Глава 2. Структуры данных
в число других полезных видов кучи входят левосторон­
ние кучи, биномиальные кучи и кучи Фибоначчи.
Max-куча поддерживает операции поиска максималь­
ного значения (find-max) (peek), вставки (insert) (push),
извлечения максимального значения (extract-max)
(pop) и увеличения ключа (increase-key) (изменения
ключа узла с последующим перемещением узла на но­
вое место на графе). Для двоичной кучи после создания
кучи из списка элементов за время O(n) каждая из этих
операций занимает время O(lg n)1.
Кучи используются в тех случаях, когда нужен быстрый
доступ к наибольшему (или наименьшему) элементу
списка без необходимости сортировки остальной части
списка. Именно поэтому кучи используются для реали­
зации очередей с прио­ритетом: нас интересует не отно­
сительный порядок всех элементов, а только то, какой
элемент является следующим в очереди, — это всегда
текущий корень кучи. Более подробно кучи рассмотре­
ны в разделах 5.3 и 8.3.

## Сложите два ломтика вместе. Приятного аппетита!
### Хеш-таблицы

Предположим, мы хотим определить, содержится ли
в массиве некий элемент. Если массив отсортирован,
можно выполнить двоичный поиск и найти этот эле­
мент за время O(lg n); если же нет, можно перебрать
весь массив за время O(n). Конечно, если бы мы знали,
где находится этот элемент, то мы бы просто обратились
туда напрямую за время O(1).
1
Подробнее о временной сложности каждой операции читайте
в книге Introduction to Algorithms.

44
Часть I. Основы Computer Science
В некоторых случаях, таких как сортировка подсчетом
(см. подраздел 8.4.1), в качестве индекса массива ис­
пользуется сам сохраняемый элемент или его ключ, и по­
этому можно просто перейти в нужное место без поиска.
А что, если бы для произвольного объекта у нас была
функция, которая бы принимала ключ этого объекта
и преобразовывала его в индекс массива, так что мы бы
точно знали, где находится объект? Именно так работа­
ют хеш-таблицы.
Первая часть хеш-таблицы — это хеш-функция; она
преобразует ключ элемента, который помещается в хеш.
Этому ключу соответствует определенное место в та­
блице. Например, наши ключи представляют собой на­
бор строк, а хеш-функция ставит в соответствие каждой
строке количество символов этой строки1. Тогда слово
cat попадет в ячейку 3, а penguin — в ячейку 7. Если ме­
сто ограничено, то мы делим хеш-код по модулю на
размер массива; тогда, если массив ограничен десятью
ячейками (0–9), строка sesquipedalophobia (хеш-код
которой равен 18) попадет в ячейку 72, 3.
Что произойдет, если мы уже поместили в хеш-таблицу
слово cat, но попытаемся вставить туда слово cat еще
раз? В хеш-таблицах допускается хранить только один
1
Это не очень хорошая хеш-функция.
2
Если бы мы хешировали слова sesquipedalophobia и hippopo­
tomonstrosesquippedaliophobia по модулю 9, то оба слова попа­
ли бы в точку ноль и образовалась бы коллизия, к удовольствию
любителей длинных слов и к ужасу страдающих логофобией.
3
На практике мы будем использовать массив, размер которого
является простым числом.

45
Глава 2. Структуры данных
экземпляр каждого элемента; в некоторых реализациях
в каждой ячейке хранится счетчик, который увеличи­
вается по мере необходимости, чтобы отслеживать ко­
личество копий элемента. Но что, если мы попытаемся
вставить слово dog, которое попадет в ту же ячейку?
Есть два способа решить эту проблему. Можно рас­
сматривать каждую ячейку как группу объектов, пред­
ставленных в виде связного списка (который нужно
пройти, чтобы найти правильное животное); это назы­
вается методом цепочек. Или же можно просмотреть
близлежащие ячейки, найти свободную и поместить
dog туда — это называется открытой адресацией. Размер
хеш-таблицы с цепочками не ограничен, однако произ­
водительность будет снижаться по мере увеличения ко­
личества элементов в ячейке. При открытой адресации
таблица имеет фиксированный максимальный размер;
как только все ячейки будут заполнены, в таблицу нель­
зя будет вставить новые элементы.
Способ организации хеш-таблицы зависит от того,
предпочитаем ли мы свести к минимуму коллизии (не­
сколько значений, которые попали в одну ячейку) или
объем памяти. Чем больше места выделено под табли­
цу относительно количества вставляемых элемен­тов,
тем меньше вероятность коллизий. За счет увеличения
памяти мы получаем повышение скорости: после того
как ключ захеширован, сохранение или извлечение
элемента (при условии отсутствия коллизий) занимает
O(1) времени. Однако при коллизиях наихудшее время
извлечения в хеш-таблице (когда для каждого элемента
возникает коллизия) составляет O(n).

46
Часть I. Основы Computer Science
Практическое применение
В C# есть класс Hashtable, позволяющий хранить произ­
вольные объекты. Каждый объект, добавляемый в Hash­
table, должен реализовывать функцию GetHashCode(),
она возвращает значение int32, которое можно исполь­
зовать для хеширования объекта. Dictionary<TKey,
TValue> предоставляет тот же функционал, но только
для объектов типа TValue, который (при условии, что
TValue не установлен в Object) позволяет программисту
избегать упаковки и распаковки сохраненных элементов.
Для внутреннего представления в обоих случаях исполь­
зуется структура данных хеш-таблицы, но с разными
методами предотвращения коллизий. В Hashtable при­
меняется перехеширование (поиск другой ячейки, если
первая занята), а в Dictionary — метод цепочек (несколь­
ко элементов с одинаковым хешем просто добавляются
в одну ячейку).
Как правило, хеш-таблицы используют в тех случаях,
ко­гда нужен прямой доступ к неотсортированным дан­
ным на основе ключа и при этом существует быстро­
действующая функция генерации ключа для каждого
объекта (при условии, что сами объекты не являются
такими ключами). Мы не будем использовать хеш-
таблицы, когда нужно сохранять порядок сортировки,
или элементы не распределены (то есть много элемен­
тов хешируется в малое количество ячеек), или часто
необходим доступ к блокам последовательно размещен­
ных элементов. Поскольку элементы (как мы надеемся)
равномерно распределены по памяти, выделенной для
хеш-таблицы, мы теряем преимущество от локальности
ссылки.

47
Глава 2. Структуры данных

## Сложите два ломтика вместе. Приятного аппетита!
### Множества и частично

упорядоченные множества
Множество — это неупорядоченная коллекция уникаль­
ных предметов. Существует три основные операции над
множествами, каждая из которых принимает два мно­
жества в качестве аргументов и возвращает еще одно
множество в качестве результата.
Uni­on(A, B) — объединение мно­
жеств — это множество, со­де­
ржащее каждый элемент, ко­
то­рый принадлежит хотя бы
од­ному из множеств A и B. Обы­
чно объединение обозначается
как A ∪ B (рис. 2.4).
Inter­sec­tion(A, B) — пересече­
ние множеств — это множество
элементов, содержащихся как
в A, так и в B, обозначается как
A ∩ B (рис. 2.5).
Differen­ce(A, B) — разность мно­
жеств (рис. 2.6) — обозначает­
ся как A – B — это множество,
в которое входят все элемен­
ты, содержащиеся в A, но от­
сутствующие в B.
Наконец, есть еще одна опера­
ция, которая возвращает логи­
ческое ­значение: подмножество
Рис. 2.4. Объединение
множеств A и B
Рис. 2.5. Пересечение
множеств A и B
Рис. 2.6. Разность
множеств A и B (A – B)

48
Часть I. Основы Computer Science
Subset(A, B). Ее результатом будет истина (true), если
A является подмножеством B (то есть каждый элемент
множества A — элемент множества B). Если A является
подмножеством B и не равно B, то такое подмноже­
ство называется собственным. Мы используем обо­
значения A ⊆ B (A является подмножеством B), A ⊆/ B
(A не является подмножеством B), A ⊂ B (A является
собственным подмножеством B) и A ⊂/ B (A не является
собственным подмножеством B). Если A ⊆ B и B ⊆ A, то
A = B. Существуют также дополнительные операции,
которые применяются к множествам строк; они рас­
смотрены в подразделе 13.2.2.
Существует несколько видов мно­жеств (рис. 2.7).
Мульти­множество — это множество, в котором допу­
скается дублирование элементов, то есть хранятся не­
сколько копий одного и того же значения либо просто
ведется подсчет того, сколько раз данное значение при­
сутствует в множестве.
Рис. 2.7. Множество целых чисел
Частично упорядоченное множество — множество, в ко­
тором некоторые элементы расположены в определен­
ном порядке. Это означает, что для некоторой двоичной
операции1 ≤ между элементами b и c может быть ис­
тиной b ≤ c, в других — c ≤ b или же между b и c может
не существовать отношений.
1
Двоичная операция — это такая операция, которая работает
с двумя операндами. Например, операция «плюс» использу­
ется для получения суммы двух значений.

49
Глава 2. Структуры данных
Если все элементы множества связаны операцией ≤,
то есть для любых двух элементов f и g множества
либо f ≤ g, либо g ≤ f, то операция ≤ определяет полный
порядок множества. Например, стандартная операция
«меньше или равно» — это порядок для множества дей­
ствительных чисел: любые два числа либо равны, либо
одно больше другого.
Необходимо, чтобы отношение было рефлексивным
(каждый элемент множества меньше или равен самому
себе), антисимметричным (если b меньше или равно c,
то c не может быть меньше или равно b, если только b
не равно c) и транзитивным (если b меньше или равно c,
а c меньше или равно d, то b меньше или равно d).
Практический пример
Пусть ≤ означает отношение «является потомком», при­
чем по определению каждый человек является потомком
самого себя. Тогда такое отношение является антисим­
метричным (если я твой потомок, то ты не можешь быть
моим потомком) и транзитивным (если я твой потомок,
а ты потомок дедушки, то я тоже потомок дедушки).
Это частичное, а не полное упорядочение, поскольку, воз­
можно, ни я не являюсь твоим потомком, ни ты — моим.
Обратите внимание, что ку­ча — частично упорядоченное
мультимножество (рис. 2.8): в ней может существовать
несколько копий одного и того же значения и каждое
значение имеет определенную связь только со своим
родителем и потомками.
Рис. 2.8. Мультимножество целых чисел

50
Часть I. Основы Computer Science
Практическое применение
Реляционные базы данных1 содержат таблицы, в которых
хранятся наборы строк. Упорядоченность может быть
задана при выводе данных (в SQL это делается с по­
мощью оператора ORDER BY), но такое ограничение
не накладывается на фактически сохраненные данные,
поэтому нельзя считать, что строки в базе данных хра­
нятся в каком-либо определенном порядке.

## Сложите два ломтика вместе. Приятного аппетита!
### Специализированные

структуры данных
Далее в книге мы рассмотрим более специализирован­
ные структуры данных. В главе 5 описаны некоторые
распространенные графовые структуры данных. В гла­
ве 32 представлена концепция амортизированного вре­
мени выполнения (общего времени, затрачиваемого на
серию операций, а не времени выполнения отдельной
операции), а в главе 33 описана структура данных, кото­
рую мы проанализируем с использованием амортизиро­
ванного времени выполнения.1
1
Реляционная база данных структурирована в соответствии
с отношениями между хранимыми элементами. Реляцион­
ные и иерар­хические базы данных рассмотрены в главе 30.

3
Классы задач
Специалисты в Computer Science классифицируют за­
дачи по времени, которое занимает их решение, в за­
висимости от количества входных данных. Благодаря
такой классификации задач мы определяем сложность
их решения. На практике это позволяет не тратить вре­
мени на задачи, которые не решаются достаточно бы­
стро, чтобы ответ был полезным.
Самые простые задачи, класса P, могут быть решены за
полиномиальное время. Это все задачи, у которых вре­
мя решения — количество входных данных, возведенное
в некоторую постоянную степень. Принято считать, что
такие задачи имеют эффективные решения. К этому
классу относятся многие широко известные задачи, на­
пример такие, как сор­тировка списков. Задачи класса P
также называют легкоразрешимыми. Как правило, если
можно доказать, что задача относится к классу P, значит,
ее можно решить за разумное время.
Класс P является собственным подмножеством множе­
ства задач EXP, которые решаются за экспоненциальное
время; любая задача, которая может быть решена за
время O(n2), также может быть решена за время O(2n).

52
Часть I. Основы Computer Science
Математическое предупреждение: возвращаясь
к главе 2
Для двух множеств A и B множество A является подмно­
жеством B, а B — надмножеством A, если каждый элемент
множества A также является элементом множества B.
Это обозначается так: A ⊆ B и B ⊇ A.
Если множество B содержит все элементы множества A,
а также что-то еще, то B является собственным надмно­
жеством множества A, а A — собственным подмноже­
ством B. Это обозначается так: A ⊂ B и B ⊃ A.
Например, множество {1, 2, 3} является собственным
подмножеством множества {1, 2, 3, 4, 5}.
Но в множество EXP входят и другие классы, кроме P.
Один из них — это недетерминированный полином
(Non­de­terministic Polynomial, NP). Задача относится
к классу NP, если она может быть решена недетермини­
рованно1 за полиномиальное время. Другими словами,
существует алгоритм, который решает эту задачу путем
принятия ряда решений, причем в каждой точке приня­
тия решения алгоритм случайным образом (и удачно)
делает правильный выбор. Пока остается ряд шагов,
1
Детерминированный алгоритм с фиксированными вход­
ными данными каждый раз проходит через одну и ту же
последовательность состояний и возвращает один и тот же
результат. С математической точки зрения такой алгоритм
отображает область экземпляров задачи на ряд решений.
Недетерминированный алгоритм может демонстрировать
различное поведение для одного и того же набора входных
данных.

53
Глава 3. Классы задач
ведущих к ответу, алгоритм выбирает правильные шаги.
Другой (более полезный) способ показать, что задача
относится к классу NP, — убедиться, что ее решение
можно проверить (детерминированно, то есть следуя
предварительно определенной последовательности ша­
гов) за полиномиальное время. NP является надмноже­
ством P; любое решение, которое может быть найдено за
полиномиальное время, также может быть проверено за
полиномиальное время.
Один из важнейших вопросов Computer Science, на
который до сих пор не получен ответ: является ли NP
собственным надмножеством P? Существуют ли зада­
чи, которые относятся к NP, но не принадлежат P, или
это одно и то же множество задач? Другими словами:
любая ли задача, решение которой быстро проверяется
компьютером, также быстро решается компьютером?
Большинство специалистов в области Computer Science
считают, что P ≠ NP, но никаких математических дока­
зательств найдено не было1 (рис. 3.1).
Рассмотрим задачу разбиения множества чисел (рис. 3.2).
Для заданного мультимножества (множества, в котором
могут присутствовать повторяющиеся элементы) нату­
ральных чисел нужно определить, можно ли разбить такое
множество на два подмножества таким образом, чтобы
сумма чисел в первом множестве равнялась сумме чисел
во втором. Если мультимножество разделено на два под­
множества {S1, S2}, то задача решается тривиально: нужно
1
Вопрос о том, справедливо ли утверждение P = NP, является
одной из семи задач тысячелетия — важных математических
вопросов, ответы на которые не найдены. За решение каждого
из них установлен приз 1 миллион долларов.

54
Часть I. Основы Computer Science
сложить значения в каждом множестве и определить,
идентичны ли эти две суммы. Но выяснить, какие зна­
чения следует поместить в каждое из множеств, за поли­
номиальное время невозможно (при условии, что P ≠ NP).
Рис. 3.2. Простой пример задачи разбиения множества
чисел. Мультимножество {1, 1, 2, 3, 4, 5, 6} можно разделить
на мультимножества {1, 1, 2, 3, 4} и {5, 6}. Сумма элементов
каждого из них равна 11
Некоторые задачи класса NP называются NP-сложными;
NP-сложная задача (несколько рекурсивно) определяет­
ся как любая задача, которая по крайней мере столь же
сложна, как и самая сложная задача класса NP. Чтобы
понять, что это значит, рассмотрим принцип сокращения.
Рис. 3.1. Проблема P = NP: это одно и то же
множество (слева) или же P является собственным
подмножеством NP (справа)?

55
Глава 3. Классы задач
Углубляясь в подробности
Выше мы говорили о том, что задача разбиения не может
быть решена за полиномиальное время при условии, что
P ≠ NP. Это верно только в том случае, если обратить
внимание на важное различие между значением и раз­
мером входных данных.
Сложность задачи часто зависит от того, как входные дан­
ные закодированы. С технической точки зрения задача
относится к классу P, если ее можно решить с помощью
алгоритма, который выполняется за полиномиальное
время, в зависимости от длины входных данных, то есть
от числа битов, необходимых для представления входных
данных. Алгоритм выполняется за псевдополиномиаль­
ное время, если он является полиномиальным, в зависи­
мости от числового значения входных данных, длина ко­
торых изменяется экспоненциально. Рассмотрим задачу
с количеством входных данных 1 миллиард и алгоритмом,
который требует n операций. Если n — это количество
цифр, необходимое для представления числа (в данном
случае 10, при условии, что основанием системы счисле­
ния является 10), то алгоритм является полиномиаль­
ным. Если n — значение входных данных (1 000 000 000),
то алгоритм будет псевдополиномиальным. В последнем
случае количество требуемых операций растет намного
быстрее, чем количество битов входных данных.
Задача B может быть сокращена до задачи C, если ре­
шение задачи C позволило бы решить задачу B за по­
линомиальное время. Другими словами, если у нас есть
оракул, который дает ответ на задачу C, то мы можем
(за полиномиальное время) преобразовать его в ответ
на задачу B. Решение задачи является NP-сложным,
если любая задача класса NP может быть сведена к этому

56
Часть I. Основы Computer Science
решению, то есть эффективное решение задачи также
приведет к эффективному решению любой задачи клас­
са NP.
Обратите внимание, что сама NP-сложная задача не обя­
зательно должна принадлежать к классу NP; она должна
быть как минимум такой же сложной, как все задачи
класса NP. Это означает, что некоторые NP-сложные
задачи (не принадлежащие классу NP) могут быть на­
много сложнее, чем другие задачи, которые принадле­
жат к классу NP.
Задача, которая и является NP-сложной, и относится
к классу NP, называется NP-полной. Поскольку каждая
NP-полная задача может быть сокращена до любой дру­
гой NP-полной задачи, сокращение NP-полной задачи
к новой задаче и демонстрация того, что новая задача
принадлежит к классу NP, достаточны, чтобы доказать,
что данная задача является NP-полной.
Углубляясь в подробности
Если NP-полная задача имеет псевдополиномиальное
решение, она называется слабо NP-полной. Если же
это не так (или P = NP), то задача называется сильно
NP-полной.
Для того чтобы ответить на вопрос, действительно ли
P = NP, нужно либо предоставить алгоритм, который бы
решал NP-полную задачу за (детерминированное) по­
линомиальное время (в этом случае P = NP), либо дока­
зать, что такого алгоритма не существует (в таком случае
P ≠ NP).

57
Глава 3. Классы задач
Углубленные темы: NP-полное сокращение
Предположим, что у нас есть следующие задачи.
Сумма подмножества. Для заданного мультимноже­
ства S целых чисел и значения w определить, суще­
ствует ли непустое подмножество множества S, сумма
элементов которого равна w?
Разделение. Можно ли разделить мультимножество S
целых чисел на два подмножества — S1 и S2, суммы эле­
ментов которых равны?
Поскольку сумма подмножества — NP-полная задача,
можно доказать, что разбиение также является NP-
полной задачей, следующим образом.
Первый шаг — показать, что задача разбиения относится
к классу NP. Для данных подмножеств S1 и S2 можно най­
ти сумму элементов каждого множества и сравнить их за
время, пропорциональное общему количеству значений.
Поскольку решение может быть проверено за линейное
(полиномиальное) время, задача принадлежит к классу NP.
Второй шаг — показать, что разбиение является NP-
сложным. Для этого мы покажем, что решение новой
задачи за полиномиальное время также даст решение
за полиномиальное время задачи, которая, как изестно,
является NP-сложной, поэтому разбиение — столь же
сложная задача, как и эта задача.
Допустим, что у нас есть алгоритм, который решает за
полиномиальное время и задачу разбиения, и задачу
суммы подмножества, которую мы хотели бы решить.
Есть множество S, и мы хотим знать, существует ли
у него подмножество, сумма элементов которого рав­
на w. Это эквивалентно вопросу, можно ли разбить
множество S с суммой |S| на мультимножество S1 с сум­
мой w1 и мультимножество S2 с суммой w2 = |S| – w.

58
Часть I. Основы Computer Science
Пусть x — разность между w1 и w2. Добавим это число
в множество S, а затем выполним алгоритм разбиения для
нового множества. Если задача разрешима, то алгоритм
вернет два разбиения с одинаковой суммой, которая равна
половине от |S| + x. Вследствие того, как мы выбрали зна­
чение x, удаление этого элемента теперь дает множества
S1 и S2, одно из которых является решением исходной за­
дачи суммы подмножества. Поскольку дополнительная
работа заняла линейное время, решение задачи суммы
подмножества заняло полиномиальное время.
Пример:
S = {5, 10, 10, 30, 45}, w = 25
|S| = 100, w2 =100 – 25 = 75, x = 75 – 25 = 50
Sa = {5, 10, 10, 30, 45, 50}
S1 = {5, 10, 10, 50}
S2 = {30, 45}
Решение: {5, 10, 10}
Этот пример показывает, что задача разбиения являет­
ся NP-полной, а ее решение за полиномиальное время
было бы доказательством того, что P = NP.
Существует еще несколько классов сложности, но те
два, которые мы обсудили в этом разделе, наиболее
известны. Другие классы, как правило, определяются
в терминах машин Тьюринга, которые мы рассмотрим
позже в этой книге.
Дополнительные источники информации
Некоторые наиболее известные NP-полные задачи рас­
смотрены в приложении Б. Более подробную информа­
цию о классах задач вы найдете в главах 13 и 14.

Часть II
Графы и графовые
алгоритмы

4
Введение в теорию
графов

## Сложите два ломтика вместе. Приятного аппетита!
### Семь кенигсбергских мостов

Я считаю, что введение в теорию графов обязательно
должно начинаться с задачи о кенигсбергских мостах.
Эта задача важна не сама по себе, а потому, что с нее на­
чался новый раздел математики — теория графов.
В городе Кенигсберге (ныне Калининград) протекает
река. Она делит город на четыре части, которые соединя­
ются семью мостами (рис. 4.1). Вопрос: можно ли прогу­
ляться по городу, проходя каждый мост ровно один раз?
Однажды этот вопрос задали математику Леонарду
Эйлеру. Он объявил задачу тривиальной, но она все же
привлекла его внимание, поскольку ни одна из суще­
ствующих областей математики не была достаточной
для ее решения. Главным заключением является то,
что топологические деформации неважны для реше­
ния; другими словами, изменение размера и формы
различных деталей не меняет задачу при условии, что
не меняются соединения1.
1
Эйлер назвал это геометрией положения.

61
Глава 4. Введение в теорию графов
Рис. 4.1. Находящаяся в открытом доступе карта
Кенигсберга. Merian-Erben, 1652
Таким образом, мы можем упростить карту, изображен­
ную на рис. 4.1, заменив каждую часть города вершиной,
а каждый мост — ребром, соединяющим две вершины.
В результате получим граф, показанный на рис. 4.2.
Ключевым логическим заключением1 является тот
факт, что для того, чтобы сначала попасть на сушу, а за­
тем покинуть ее, требуется два разных моста. Поэтому
1
Solutio Problematis ad Geometriam Situs Pertinentis // Commen­
tarii academiae scientiarum Petropolitanae 8, 1741. P. 128–140.
(«Решение одной проблемы, относящейся к геометрии по­
ложения»). Английский перевод доступен в книге: Biggs N.,
Lloyd E. K., Wilson R. J. Graph Theory, 1736–1936.

62
Часть II. Графы и графовые алгоритмы
любой участок суши, который не является начальной
или конечной точкой маршрута, должен быть конечной
точкой для четного числа мостов. В случае Кенигсберга
к каждой из четырех частей города вело нечетное число
мостов, что делало задачу неразрешимой. Путь через
граф, который проходит через каждое ребро ровно один
раз, теперь называется эйлеровым путем.
Рис. 4.2. Кенигсбергские мосты в виде графа. Обратите
внимание, что каждая вершина имеет нечетную степень,
то есть ее касается нечетное количество ребер

## Сложите два ломтика вместе. Приятного аппетита!
### Мотивация

Графы в Computer Science чрезвычайно важны: очень
многие задачи можно представить в виде графов. В слу­
чае с кенигсбергскими мостами представление города
в виде графа позволяет игнорировать неважные де­
тали — фактическую географию города — и сосредо­
точиться на важном — на связях между различными
частями города. Во многих случаях возможность свести

63
Глава 4. Введение в теорию графов
постановку задачи к эквивалентной задаче для опре­
деленного класса графов дает полезную информацию
о том, насколько сложно ее решить. Некоторые задачи
являются NP-сложными на произвольных графах, но
имеют эффективные (часто O(n)) решения на графах,
имеющих определенные свойства.
В этой и последующих главах вы познакомитесь с тер­
минами, связанными с графами и некоторыми распро­
страненными структурами данных, которые используют
графы. Вы узнаете, как представлять графы визуально,
а также в форматах, более удобных для вычислений.
После этого вы узнаете об известных графовых алгорит­
мах и некоторых основных графовых классах. К тому
времени, когда вы закончите читать часть II, вы будете
понимать, в каких случаях можно применять методы
построения графов при решении задач.
Определение
Класс графов — это (как правило, бесконечный) набор
графов, который обладает определенным свойством;
принадлежность данного графа к этому классу зависит
от того, есть ли у этого графа это свойство.
Пример
Двудольные графы — это такие графы, в которых верши­
ны можно разделить на два множества, так что каждое
ребро соединяет вершину из одного множества с верши­
ной из другого множества.

64
Часть II. Графы и графовые алгоритмы

## Сложите два ломтика вместе. Приятного аппетита!
### Терминология

Граф — это способ представления взаимосвязей в мно­
жестве данных. Графы часто изображаются в виде круж­
ков, которыми обозначаются вершины, и линий между
ними, представляющих ребра. Но вы узнаете и о других
способах представления графов. Две вершины являются
смежными, если между ними есть ребро, и несмежными,
если между ними нет ребра.
Вершины графа также называются узлами; эти два
термина, как правило, взаимозаменяемы. Однако точ­
ка многоугольника, в которой встречаются два ребра
и более, всегда будет вершиной, а участок памяти,
в котором содержится вершина и ее набор ребер, —
узлом.
4.3.1.  Части графов
Я буду часто ссылаться на подграф или порожденный
подграф графа. Подграфом графа является любое ко­
личество вершин графа вместе с любым количеством
ребер (которые также принадлежат исходному графу)
между этими вершинами. Порожденный подграф — это
любое подмножество вершин вместе со всеми ребрами
графа, соединяющими эти вершины.
Строгое подмножество множества содержит меньше
элементов, чем исходное множество; другими словами,
собственное подмножество вершин графа содержит
меньше вершин, чем исходный граф, в то время как
регулярное подмножество может содержать все мно­
жество вершин.

65
Глава 4. Введение в теорию графов
4.3.2.  Графы со всеми ребрами
или без ребер
Полный (под)граф, или клика, — это такой граф, кото­
рый содержит все возможные ребра между его верши­
нами. Независимое (или внутренне устойчивое) множе­
ство — это множество вершин без ребер между ними.
На рис. 4.3 показан граф K8; в теории графов буква K
с целочисленным индексом означает полный граф с со­
ответствующим количеством вершин.
Рис. 4.3. K8 — полный граф из восьми вершин
Граф или подграф, в котором существует путь от любой
вершины к любой другой вершине, называется связным;
граф, который не является связным, состоит из несколь­
ких компонент связности1.
1
Компонентой связности графа является максимально связный
подграф — множество вершин графа такое, для которого су­
ществует путь от любой вершины множества к любой другой
вершине множества, и при этом ни у одной вершины нет ре­
бра, ведущего к вершине, не принадлежащей этому мно­жеству.

66
Часть II. Графы и графовые алгоритмы
Для данного графа G его дополнение G' также является
графом с теми же вершинами; для любой пары вер­
шин G' ребро между ними существует тогда и только
тогда, когда такого ребра нет в графе G. На рис. 4.4 по­
казан граф, который является дополнением к графу K6;
вместо того чтобы содержать все возможные ребра, он
не имеет ни одного ребра.
Рис. 4.4. Разъединенный граф с шестью компонентами
связности размером 1
Математическое предупреждение
Символ штриха (') используется в  математике для
представления объекта, который был получен из дру­
гого объекта. Здесь я использую этот символ для обо­
значения графа G', который мы получаем из G, удаляя
из него все ребра и добавляя ребра там, где их раньше
не было. Это похоже на использование данного сим­
вола в теории множеств для обозначения дополнения
множества.

67
Глава 4. Введение в теорию графов
При обсуждении языков в главе 13 используется аль­
тернативная нотация — обозначение дополнения язы­
ка А как А-. Эта нотация (также широко распространен­
ная) облегчает работу с дополнениями дополнений.
4.3.3.  Петли и мультиграфы
Обычно мы работаем с простыми графами, то есть с гра­
фами, которые не содержат петель (ребро, которое за­
канчивается в той же вершине, в которой началось) или
кратных ребер (несколько ребер, соединяющих одни
и те же вершины). Говоря «граф» и не указывая иное,
мы всегда имеем в виду простой граф. Граф с петлями
можно назвать непростым графом, а граф с кратными
ребрами — мультиграфом. Далее в книге, встретив слово
«граф», считайте, что оно означает простой неориенти­
рованный граф1, если не указано иное.

z
z Аксиома — утверждение, которое принимается без
доказательств; остальная часть доказательства за­
висит от правильности аксиом.
z
z Математическая гипотеза (conjecture) — утвержде­
ние, которое представляется верным, но для которого
еще не получено математическое доказательство.
1
Математическая гипотеза — это утверждение, которое мы
считаем верным, но пока не можем доказать.
2
Вторая теорема Евклида.

182
Часть VI. Доказательства
Когда математическая гипотеза доказана, она стано­
вится теоремой1.
z
z Следствие — утверждение, которое непосредственно
вытекает из другой теоремы или определения. Не­
редко представляет собой просто частный случай
теоремы.
z
z Гипотеза (hypothesis) — предположение, которое
считается верным, несмотря на отсутствие доказа­
тельств. Иногда гипотеза полагается верной и исполь­
зуется для выстраивания условных доказательств
других утверждений.
z
z Лемма — вспомогательная теорема, используемая
для доказательства другой теоремы. Если искомое
доказательство — это вершина горы Эверест, то лем­
ма — это остановка на пути к ней. Доказательство
леммы должно приблизить вас к желаемому пункту
назначения2.
z
z Доказательство (математическое доказательство) —
это цепочка логических умозаключений, показыва­
ющая, что при условии истинности некоего набора
1
Опровергнутая гипотеза считается просто ложным предпо­
ложением.
2
Например, согласно лемме Евклида, если произведение двух
целых чисел a и b делится на простое число p, то по крайней
мере один из этих сомножителей делится на p. Эта простая
лемма используется для доказательства основной теоремы
арифметики, согласно которой любое целое число, превыша­
ющее 1, либо является простым, либо может быть выражено
в виде произведения простых чисел, причем это представ­
ление является единственным, если не учитывать порядок
следования множителей.

183
Глава 15. Приемлемые доказательства
предположений утверждение верно. Часто для обо­
значения конца доказательства используется аб­
бревиатура QED1 или символ в виде заполненного
квадрата.
z
z Теорема — утверждение, которое было доказано
на основе аксиом и/или ранее доказанных теорем.
Доказанная математическая гипотеза становится
теоремой.
1
Quod erat demonstrandum — латинская фраза, означающая
«что и требовалось доказать».

16
Методы
доказательства

Рассмотрим стандартную ситуацию. Алиса отправляет
сообщение Бобу. Третье лицо, Ева, хочет перехватить
это сообщение.
У Алисы и Боба есть некий фрагмент информации,
обеспечивающий безопасность их коммуникации. Если
они применяют алгоритм симметричного шифрования,
то имеют копию ключа, который используется как для
шифрования, так и для расшифровки. Симметричное
шифрование предполагает, что у участников есть воз­
можность безопасным образом согласовать ключ, пре­
жде чем задействовать его для передачи сообщений.
Этот обязательный обмен ключами — основной недо­
статок симметричного шифрования, поскольку требует
того, чтобы две стороны заранее договорились относи­
тельно алгоритма шифрования или нашли уже суще­
ствующий метод безопасной коммуникации. Данную
проблему можно обойти с помощью квантового рас­
пределения ключей, предполагающего использование
квантовых явлений для безопасной передачи ключей.
Алгоритмы асимметричного шифрования, также из­
вестные как алгоритмы с открытым ключом, исполь­
зуют разные ключи для шифрования и расшифровки.

203
Глава 19. Введение в криптографию
Сообщение, зашифрованное с помощью открытого
ключа, можно расшифровать с помощью закрытого.
В некоторых ситуациях верно обратное: один человек
может зашифровать сообщение с помощью закрытого
ключа, а любой обладатель открытого ключа может его
расшифровать. В этом случае закрытый ключ может
использоваться для аутентификации: обладатель за­
крытого ключа может подписать документ, а любой об­
ладатель открытого может проверить данную подпись1.

## Сложите два ломтика вместе. Приятного аппетита!
### Представление графов

Когда мы говорим о размере графа, то обычно исполь­
зуем обозначение n для числа вершин и m — для числа
ребер2. На рис. 4.3 n = 8 и m = 28, на рис. 4.4 — n = 6
и m = 0. Количество места в памяти, необходимое для
хранения графа, зависит от того, как именно мы его
1
Ориентированные графы мы рассмотрим в разделе 4.5.
2
Обычно множество вершин обозначают буквой V, а множе­
ство ребер — буквой E, поэтому |V| = n, а |E| = m; то есть n —
размер множества V, а m — размер множества E.

68
Часть II. Графы и графовые алгоритмы
храним; как правило, графы хранятся в виде списков
смежности и матриц смежности.
4.4.1.  Представление графов в виде
списков смежности
При использовании представления в виде списка смеж­
ности каждая вершина графа сохраняется вместе со
списком смежных с ней вершин (рис. 4.5, 4.6). Если
реализовать это в виде множества связных списков, то
объем занимаемого пространства составит O(n + m)1.
В случае разреженного графа (с очень небольшим чис­
лом ребер) этот объем сократится до O(n). Для плотного
графа (графа с большим количеством ребер, такого как
полный или почти полный граф) этот объем составит
O(n2).
Рис. 4.5. Представление
списка смежности графа,
показанного на рис. 4.3
Рис. 4.6. Представление
списка смежности графа,
показанного на рис. 4.4
1
У нас есть n связных списков, некоторые из них могут быть
пустыми (если граф разъединенный). Каждое ненаправ­
ленное ребро присутствует в обоих списках, поэтому общее
количество узлов в списках составляет 2m. В сумме это дает
O(n + m) объема памяти.

69
Глава 4. Введение в теорию графов
4.4.2.  Представление графов в виде
матрицы смежности
Еще одним популярным способом хранения графа яв­
ляется матрица смежности (рис. 4.7, 4.8), которая пред­
ставляет собой матрицу со следующими свойствами:
z
z каждая ячейка матрицы равна либо 0, либо 1;
z
z ячейка в позиции (i, j) равна 1 тогда и только тогда,
когда существует ребро между вершинами i и j. Это
верно и для ячейки в положении (j, i);
z
z из предыдущего пункта следует, что число единиц
в матрице равно удвоенному числу ребер в графе;
z
z диагональные ячейки всегда равны нулю, потому что
ни у одной вершины нет ребра, которое и начинается,
и заканчивается в ней1;
Рис. 4.7. Представление
матрицы смежности графа,
показанного на рис. 4.3
Рис. 4.8. Представление
матрицы смежности графа,
показанного на рис. 4.4
1
Диагональ матрицы — это ячейки, для которых номер столб­
ца совпадает с номером строки: (0, 0), (1, 1) и т. д. На рис. 4.7
приведен пример матрицы, которая имеет нулевые значения
только на диагонали.

70
Часть II. Графы и графовые алгоритмы
z
z матрица состоит из n строк и n столбцов и поэтому
занимает n2 места. Для плотного графа линейная за­
висимость от размера матрицы сохраняется1.
В мультиграфе, где присутствуют петли, некоторые из
этих условий не выполняются. В частности, значения
могут быть больше 1 (потому что между двумя вер­
шинами может существовать несколько ребер) и диа­
гональ может быть ненулевой (петли могут соединять
вершину с самой собой).
4.4.3.  Представление графов в памяти
В памяти граф часто хранится в виде набора узлов.
Каждый узел представляет одну вершину и содержит
набор указателей на другие узлы, так что каждый указа­
тель соответствует ребру, ведущему к другой вершине.
4.4.4.  Выбор представлений
Выбор представления графа зависит от плотности графа
и от того, как вы планируете его использовать. Для разре­
женного графа список смежности намного эффективнее
по объему памяти, чем матрица смежности, поскольку
нам не нужно хранить O(n2) нулей и можно легко пере­
брать все существующие ребра. Кроме того, в случае ди­
намического графа (который изменяется со временем)
в списке смежности проще добавлять и удалять вершины.
С другой стороны, в матрице смежности более эффек­
тивно организован доступ к ребрам. Чтобы определить,
1
Размер матрицы — это сумма количества вершин (n) и коли­
чества ребер (m), но для плотного графа m = O(n2).

71
Глава 4. Введение в теорию графов
являются ли вершины i и j смежными, достаточно про­
верить, равно ли A[i] [j] единице. Не нужно сканировать
весь список, что может занять до O(n) времени. Та­
ким образом, в матрице смежности поиск выполняется
не только быстрее, но и занимает постоянное количе­
ство времени, что делает матрицы смежности лучшими
для приложений, где необходима предсказуемость1.

## Сложите два ломтика вместе. Приятного аппетита!
### Направленные

и ненаправленные графы
В задаче о кенигсбергских мостах все ребра графа были
ненаправленными; если по мосту можно идти в одном
направлении, то можно идти и в обратном. Графы, для
которых это верно, называются ненаправленными или
просто графами и описывают ситуации, в которых если
(вершина) A связана с B, то B также связана с A. Напри­
мер, если Алиса — двоюродная сестра Веры, то Вера
также является двоюродной сестрой Алисы.
В ориентированном графе, или орграфе, каждое ребро
имеет направление, в котором следует данная связь. Если
Алиса любит проводить время с Верой и мы обозначаем
это стрелкой из A в B, это еще не говорит о том, что Вера
тоже любит проводить время с Алисой. Если это так,
то также существует стрелка из B в A. Орграф является
симметричным, когда для каждого ориентированно­
го ребра в нем существует ребро, соединяющее те же
две вершины, но направленное в противоположную
1
В приложениях реального времени следует быть готовыми
пожертвовать некоторой производительностью, чтобы полу­
чить более жесткие ограничения на максимальное время,
которое может потребоваться для выполнения операции.

72
Часть II. Графы и графовые алгоритмы
сторону. Такой граф эквивалентен ненаправленному
графу с одним ребром между каждой парой вершин, где
есть пара направленных ребер, поэтому обычные графы
можно рассматривать как особый случай орграфов.
И наоборот, возможна ситуация, при которой между
любыми двумя вершинами может существовать только
одно ориентированное ребро; такой граф называется
направленным или антисимметричным. Например, если
Алиса является родителем Влада, то Влад не может быть
родителем Алисы (по крайней мере никаким социально
приемлемым способом). Если взять ненаправленный
граф и задать направление каждому из ребер (превратить
ребро в ориентированное), получим направленный граф.

## Сложите два ломтика вместе. Приятного аппетита!
### Циклические

и ациклические графы
Один из способов классификации графов — разде­
лить их на циклические или ациклические. Ацикличе­
ский граф имеет не более одного пути между любыми
двумя вершинами; другими словами, не существует
пути a-b-c-a, где {a, b, c} — различные вершины гра­
фа1. Циклический граф имеет хотя бы один цикл: мож­
но найти путь, который начинается и заканчивается
в одной и той же вершине (рис. 4.9). В случае ориентиро­
ванных графов добавляется условие, что все ребра цикла
должны иметь одинаковое направление — по часовой
1
В данном случае на месте c также может быть несколько
вершин — это может быть цикл a-b-c-d-e-f-g-h-a. Обратите
внимание, что каждое ребро можно использовать только
один раз: переход по пути a-b-c и затем возвращение назад
по тем же ребрам — это не цикл!

73
Глава 4. Введение в теорию графов
стрелке или против часовой стрелки; другими словами,
в циклическом орграфе можно найти путь от верши­
ны к самой себе, следуя по направлению стрелок. При
программировании графовых алгоритмов необходимо
соблюдать осторожность при обработке циклов, иначе
программа может попасть в бесконечный цикл.
Рис. 4.9. Любой полный граф является циклическим
4.6.1.  Деревья
Многие важные алгоритмы в теории графов опери­
руют с деревьями. Дерево — это просто связный граф,
не имеющий циклов. Как правило, удобно описывать
дерево, начиная с корня; мы назначаем одну вершину
корнем дерева и определяем остальные вершины по
их отношению к корню. Следующие определения для
дерева являются эквивалентными:
z
z ациклический граф, в котором появится простой
(без повторяющихся вершин) цикл, если добавить
в него любое ребро1;
1
Это должен быть связный граф; понимаете ли вы почему?

74
Часть II. Графы и графовые алгоритмы
z
z связный граф, который перестанет быть связным,
если удалить из него любое ребро;
z
z граф, в котором любые две вершины связаны уни­
кальным простым путем.
Узлы дерева бывают двух типов: внутренние узлы (у ко­
торых есть хотя бы один дочерний элемент) и листья
(у которых нет дочерних элементов) (рис. 4.10).
Рис. 4.10. Дерево с десятью вершинами. Это звезда,
представляющая собой дерево ровно с одним
внутренним узлом
4.6.2.  Бесхордовые циклы
В большинстве случаев нас особенно интересуют бес­
хордовые циклы. Хорда — это ребро между двумя вер­
шинами цикла, которое само не является частью цикла.
Бесхордовый цикл — это цикл, который состоит хотя бы
из четырех вершин и не содержит хорд (рис. 4.11).
Другими словами, это такой цикл, в котором нет ребер

75
Глава 4. Введение в теорию графов
между любыми двумя вершинами, не являющимися
последовательными в цикле1.
Рис. 4.11. C5, бесхордовый цикл из пяти вершин
В главе 7 речь пойдет о нескольких классах графов, ко­
торые (по крайней мере частично) определяются отсут­
ствием порожденных бесхордовых циклов, являющихся
порожденными подграфами, содержащими циклы без
хорд. Граф без порожденных бесхордовых циклов на­
зывается, что неудивительно, хордальным графом.

## Сложите два ломтика вместе. Приятного аппетита!
### Раскраска графа

Многие графовые задачи связаны с раскраской — спо­
собом маркировки вершин (или ребер) графа. Правиль­
ная раскраска вершин — такая, при которой смежные
1
Например, если у нас есть бесхордовый цикл A-B-C-D-E-A,
то у A нет ребра, ведущего к C или D, поскольку эти вершины
не стоят непосредственно перед или после A в цикле.

76
Часть II. Графы и графовые алгоритмы
вершины (то есть вершины, между которыми есть ребро)
раскрашены в разные цвета. Другими словами, раскрас­
ка — это разделение вершин на независимые множества.
Математическое предупреждение
Когда мы говорим о поиске раскраски графа, это не зна­
чит, что мы должны в буквальном смысле использовать
цвета. Иногда при создании раскраски в роли цветов
может выступать набор целых чисел.
Даже если мы используем реальные цвета, компьютер
все равно будет обрабатывать их как список целых чи­
сел, а затем при визуализации преобразовывать целые
числа в цвета.
Аналогично правильная раскраска ребер — это такая,
при которой два ребра, инцидентные1 одной и той же
вершине, раскрашены в разные цвета. Если не указано
иное, то, говоря о раскраске графа, мы будем иметь
в виду правильную раскраску вершин.
Первые результаты раскраски графов включали в себя
раскраску плоских графов2 в виде карт. В гипотезе о че­
тырех цветах3, выдвинутой в 1852 году, говорится, что
для правильной раскраски любой карты, состоящей
1
Два ребра называются инцидентными, если они имеют общую
вершину; аналогично две вершины, соединенные общим реб­
ром, называются смежными.
2
Это графы, которые можно нарисовать так, чтобы никакие
два ребра не пересекались, кроме как в вершине; подробнее
см. в разделе 7.2.
3
Доказано, теперь это теорема о четырех цветах.

77
Глава 4. Введение в теорию графов
только из связных областей1 с границами конечной
длины, требуется не более четырех цветов.
Доказательство этого утверждения было представлено
Альфредом Кемпе в 1879 году и считалось общепри­
нятым, пока в 1890 году не было доказано, что оно не­
верно2. В итоге задачу решили с помощью компьютера
в 1976 году; теперь у нас есть алгоритмы квадратичного
времени для любой четырехцветной карты3. До сих пор
не существует доказательств, не требующих использо­
вания компьютера.
Несмотря на то что задача раскраски карты, в сущности,
не представляла особого интереса для создателей карт,
она интересна с теоретической точки зрения и имеет
практическое применение. Так, судоку — это форма
раскраски графа, «цветами» которого являются числа
от единицы до девяти.
Хроматическое число графа — это количество цветов, не­
обходимых для его правильной раскраски. Другая форму­
лировка теоремы о четырех цветах состоит в том, что хро­
матическое число плоского графа — не больше четырех.
Очевидно, что хроматическое число графа, не имеющего
ребер, равно единице (все вершины могут быть одно­
1
В соответствии с этим требованием континентальная часть
США, Аляска и Гавайи будут считаться отдельными регио­
нами. На самом деле Гавайи были бы несколькими регионами.
2
Первая опубликованная исследовательская работа автора этой
книги была посвящена контрпримеру к ошибочному доказа­
тельству Кемпе.
3
Или же для любого плоского графа.

78
Часть II. Графы и графовые алгоритмы
го цвета). Для полного графа из n вершин хроматиче­
ское число равно n (каждая вершина смежна со всеми
остальными вершинами, поэтому все вершины должны
быть разных цветов).
Проверка того, может ли произвольный граф быть
двухцветным, занимает линейное время1 — достаточно
окрасить одну вершину в красный цвет, затем окрасить
все ее соседние вершины в синий, потом все соседние
вершины этих вершин, которые еще не были окраше­
ны, — в красный и т. д. Работа прекращается, когда либо
все вершины окрашены, либо обнаружена вершина,
у которой соседняя вершина имеет тот же цвет. А вот
трехцветная раскраска является NP-полной задачей!
Известно, что алгоритмы, определя­ющие, является ли
граф k-раскрашиваемым, занимают экспоненциальное
время. Однако, если знать, что граф принадлежит кон­
кретному классу2, найти раскраску можно за полино­
миальное время.
Алгоритмы раскраски обычно используются в таких
приложениях, как планирование, анализ данных, работа
в сетях и т. п. Например, рассмотрим задачу назначения
времени для собраний длительностью один час, когда
на разные собрания приглашаются разные люди и ис­
пользуется разное оборудование. Мы представляем
каждое собрание в виде вершины и добавляем ребро
между двумя вершинами, если в них задействованы
одни и те же человек или оборудование. Нахождение
1
То есть время пропорционально сумме количества вершин
и ребер.
2
Например, идеальные графы, описанные в разделе 7.3.

79
Глава 4. Введение в теорию графов
минимальной раскраски говорит нам о необходимости
назначить разное время для встреч (рис. 4.12).
Рис. 4.12. Граф C5 с минимальной раскраской

## Сложите два ломтика вместе. Приятного аппетита!
### Взвешенные

и невзвешенные графы
Вершины графа можно представить как локации, а реб­
ра — как пути между ними, но в действительности
не все пути имеют одинаковую длину. В невзвешен­
ном графе ребра просто показывают, между какими
вершинами есть прямой путь, но существуют также
взвешенные графы, в которых каждому ребру присвоен
вес. Обычно, но не всегда эти веса являются неотрица­
тельными целыми числами. Вес часто воспринимается
как стоимость использования этого ребра.
То, что конкретно означает вес, зависит от того, что опи­
сывает граф. На графе крупных городов ребра с весами
могут представлять расстояния в милях по кратчайшему
шоссе между двумя городами. На электрической схеме
веса — это максимальный ток через данное соединение.

5
Структуры данных
на основе графов
При проектировании алгоритмов мы часто используем
абстрактные структуры данных в том смысле, что знаем
свойства, которыми должна обладать структура, а не ее
точная организация. Например, очередь с приоритетом —
это структура данных FIFO (first in, first out — «первым
пришел, первым ушел»), в которой элементы с более вы­
соким прио­ритетом проходят вне очереди и обслужива­
ются раньше, чем элементы с более низким приоритетом.
При выполнении реального алгоритма мы должны пре­
вратить эту абстрактную структуру данных в реальную.
Так, очередь с приоритетом может быть реа­лизована с по­
мощью двоичного дерева поиска или же с помощью кучи.
С кучей вы познакомились в подразделе 2.4.2; в этой гла­
ве более подробно рассмотрим ее внутреннее устройство.

## Сложите два ломтика вместе. Приятного аппетита!
### Двоичные деревья поиска

Двоичное дерево поиска (Binary Search Tree, BST)
(рис. 5.1) — это корневое двоичное дерево1, которое
рекурсивно определяется следующим образом: ключ
1
Двоичное дерево — это дерево, каждый узел которого имеет
не более двух дочерних узлов.

81
Глава 5. Структуры данных на основе графов
корня у него больше или равен ключу его левого потом­
ка и меньше или равен ключу правого потомка (если он
есть). Это также верно для поддерева, корнем которого
является любой другой узел.
Рис. 5.1. Двоичное дерево поиска
Операции над двоичным деревом поиска занимают вре­
мя, пропорциональное высоте дерева — длине самой
длинной цепочки от корня (высота которого равна нулю)
до листа. В общем случае1 это Θ(lg n)2, но в худшем слу­
чае (когда у каждого узла есть только один дочерний
элемент, что, по существу, превращает дерево в связный
список) высота составляет O(n). Некоторые вариации
двоичного дерева поиска гарантируют, что высота дерева
будет Θ(lg n), поэтому мы можем быть уверены, что все
1
Предположим, что вы назначили корнем случайный узел.
Тогда в среднем половина оставшихся узлов окажется слева
от него, а половина — справа. Таким образом, ожидается, что
количество узлов на каждом уровне дерева будет примерно
вдвое больше, чем на предыдущем, следовательно, во всем
дереве будет примерно lg n уровней.
2
Θ означает, что время выполнения ограничено как сверху, так
и снизу; высота дерева должна быть не менее lg n.

82
Часть II. Графы и графовые алгоритмы
операции завершатся за O(lg n) времени. На рис. 5.2 изо­
бражено несбалансированное двоичное дерево поиска.
Рис. 5.2. Несбалансированное двоичное дерево поиска.
Операции с ним занимают O(n) времени
Двоичное дерево поиска может быть реализовано как
коллекция связанных узлов, где каждый узел имеет
ключ и указатели на левый и правый дочерние элемен­
ты и на родительский элемент. Поскольку узлы распо­
ложены так, что любой узел не меньше, чем любой из
узлов его левого поддерева, и не больше, чем любой из
узлов его правого поддерева, то можно вывести все клю­
чи по порядку, выполнив упорядоченный обход дерева.

83
Глава 5. Структуры данных на основе графов
Поиск по двоичному дереву выполняется просто: на­
чиная с указателя на корень дерева и имея заданный
ключ, мы сначала проверяем, есть ли у корня этот ключ.
Если ключ корня меньше заданного, мы выбираем пра­
вый дочерний узел, если же он больше, то левый. По­
иск прекращается, когда либо обнаружено совпадение
ключей, либо поддерево, для которого мы пытаемся
выполнить рекурсию, пусто. Чтобы найти наименьший
элемент, мы просто всегда выполняем рекурсию для
левого дочернего элемента, а чтобы найти наиболь­
ший элемент — для правого. В каждом случае мы бу­
дем проверять не более одного узла на каждом уровне
дерева, поэтому время выполнения в худшем случае
пропорцио­нально высоте дерева.
Как создать и модифицировать двоичное дерево по­
иска? Первый добавленный узел становится корнем
дерева. Чтобы добавить другие узлы, мы ищем значение
ключа для вставки; обнаружив нулевой указатель, меня­
ем его так, чтобы он указывал на новый узел, и делаем
текущий узел родительским для нового узла1.
Чтобы удалить узел d, нужно найти его в дереве и затем
выполнить следующее:
z
z если у d нет потомков, просто присвоить null указа­
телю родительского узла, который сейчас ссылается
на d;
1
Если в дереве допускаются дубликаты, нам может встре­
титься еще один или несколько узлов с таким же значением
ключа, прежде чем мы найдем нулевой указатель.

84
Часть II. Графы и графовые алгоритмы
z
z если у d есть один потомок, этот потомок занимает
место d;
z
z если у d два потомка, то найти его предшественника
или преемника (узлы, которые будут появляться
непосредственно перед или после d при упорядо­
ченном обходе) и также переместить его вверх, на
место d (после чего может потребоваться обрабо­
тать потомков этого узла так, как если бы он был
удален).

## Сложите два ломтика вместе. Приятного аппетита!
### Сбалансированные

деревья двоичного
поиска
Для того чтобы гарантировать, что операции над дво­
ичным деревом поиска занимают O(lg n), а не O(n)
времени, необходимо ограничить высоту дерева. Если
все ключи заранее известны, мы, конечно же, можем
построить сбалансированное дерево (имеющее мини­
мально возможную высоту).
На практике элементы дерева время от времени ме­
няются, поэтому мы допускаем, что его высота мо­
жет быть больше минимальной, но при этом составит
Θ(lg n).
Двоичное дерево поиска с автоматической баланси­
ровкой — это дерево, которое автоматически сохраняет
небольшую высоту (по сравнению с количеством тре­
буемых уровней) независимо от добавления или удале­
ния узлов. Деревьями с автоматической балансировкой

85
Глава 5. Структуры данных на основе графов
являются, в частности, красно-черные деревья1, косые
деревья2 и декартовы деревья (treaps).

## Сложите два ломтика вместе. Приятного аппетита!
### Кучи

Как показано в подразделе 2.4.2, куча — это структура
данных, а именно почти полное двоичное дерево с кор­
нем, ключ которого больше, чем ключ любого из его до­
черних элементов (рис. 5.3). И это правило рекурсивно
выполняется для любого поддерева, корнем которого
является любой дочерний элемент3. «Почти полное»
означает, что дерево максимально заполнено, за исклю­
чением, возможно, самого нижнего уровня, который
заполняется слева направо.
1
Красно-черное дерево — это двоичное дерево поиска, в ко­
тором все ключи хранятся во внутренних узлах, а листья —
это нулевые узлы. Для таких деревьев также существуют
дополнительные требования: каждый узел должен быть
красным или черным, корень и все листья — черными, по­
томки красного узла — черными и каждый путь от узла
к листу должен содержать одинаковое количество черных
узлов. В результате этих ограничений путь от корня до само­
го дальнего листа не более чем в два раза превышает длину
пути от корня до ближайшего листа, поскольку кратчайший
возможный путь — это все черные узлы, а в самом длинном
из возможных путей красные и черные узлы чередуются,
поэтому ни один путь не может быть более чем в два раза
длиннее другого.
2
Косые деревья подробно рассмотрены в главе 33.
3
Или же корень может быть меньше, чем его дочерние элемен­
ты, такая куча называется неубывающей. Для согласованно­
сти далее мы будем использовать невозрастающую кучу.

86
Часть II. Графы и графовые алгоритмы
Рис. 5.3. Max-куча с узлами, помеченными их позицией
Предположим, что мы хотим реализовать кучу. В этой
куче вершины нумеруются начиная с корня, а затем на
каждом уровне — слева направо: корень — вершина 0,
его левый потомок — вершина 1, правый потомок —
вершина 2, самый левый внук корня — вершина 3 и т. д.
(рис. 5.4).
Рис. 5.4. В этом неупорядоченном двоичном дереве узлы
с 5-го по 9-й являются корнями кучи размером 1
Обратите внимание, что каждая строка содержит в два
раза больше узлов, чем строка, расположенная над ней.

87
Глава 5. Структуры данных на основе графов
Это озна­чает, что метка левого дочернего элемента каж­
дого узла как минимум вдвое плюс еще на единицу
больше, чем номер родительского элемента1. Для лю­
бого узла k номер его родителя равен k – 1
2
, а его до­
черние элементы (если они есть), имеют номера 2k + 1
и 2k + 2.
Математическое предупреждение
Приведенные выше L-образные операторы представ­
ляют функцию округления до ближайшего целого
в меньшую сторону, что означает усечение любой дроби;
2.8  = 2. Обратная функция, округление до ближайшего
целого в большую сторону, записывается как 2.1  = 3.
Если вы предпочитаете использовать массив с отсчетом
от 1, то родительским узлом для k будет узел номер k
2
,
а его дочерние элементы будут иметь номера 2k и 2k + 1.
Можно эффективно определить позицию родительско­
го или дочернего узла, выполнив умножение посред­
ством сдвига битов; если куча реализована на основе
массива, то мы сразу получим положение нужного узла.
5.3.1.  Построение кучи
Теперь, когда мы определили, как куча хранится в памя­
ти, мы готовы ее построить. Куча строится ­рекурсивно:
1
Или же просто удвоить массив с отсчетом от 1.

88
Часть II. Графы и графовые алгоритмы
создаются маленькие кучи и объединяются в большие.
Для начала предположим, что у нас есть массив A раз­
мером n, который мы интерпретируем как описанное
ранее двоичное дерево (см. рис. 5.4). Обратите внима­
ние, что каждый лист дерева (любой элемент в позиции
от n
2  до n – 1) является корнем кучи размером 1.
Теперь рассмотрим внутренние узлы на втором снизу
уровне дерева. Если ключ такого узла больше, чем ключ
любого из его дочерних элементов, то он является кор­
нем невозра­стающей кучи. Если же нет, то мы поменяем
его с дочерним элементом, ключ которого больше, что­
бы этот дочерний элемент стал корнем невозрастающей
кучи, и перейдем к новому дочернему элементу, чтобы
убедиться, что новое поддерево сохраняет свойство
кучи.
Затем мы продолжим объединять кучи таким образом,
пока не будет обработан весь массив (рис. 5.5–5.7).
Рис. 5.5. Если лист больше, чем его родитель
и сестра, то этот лист меняется местами
с родителем

89
Глава 5. Структуры данных на основе графов
Рис. 5.6. Перенос дочернего элемента на более
высокий уровень может уничтожить свойство
кучи поддерева, корневым элементом которого
был этот дочерний элемент. В данном случае
новый узел 1 меньше, чем один
из его дочерних узлов
Рис. 5.7. В итоге ни одно значение узла не превышает
значение его родительского элемента, так что граф
удовлетворяет свойству кучи
Этот процесс можно представить в виде следующего
кода (алгоритм 1). Кроме .length, который, как обычно,

90
Часть II. Графы и графовые алгоритмы
означает количество элементов массива, мы опреде­
ляем .heapSize — число элементов массива, которые
являются частью кучи.
В BuildMaxHeap мы перебираем все внутренние узлы,
начиная с самого нижнего. Для каждого выбранного
узла мы проверяем, больше ли он, чем каждый из его
дочерних узлов, которых может быть не более двух.
Если это так, то, поскольку каждый дочерний элемент
уже является корнем невозрастающей кучи, этот узел
теперь является корнем новой невозраста­ющей кучи
большего размера.
Если это не так, то мы меняем данный элемент на боль­
ший из двух его дочерних элементов. Это может при­
вести к тому, что поддерево с корнем в данном дочернем
элементе больше не будет удовлетворять свойству кучи
(в случае если новый элемент был меньше не только
чем его дочерний элемент, но также и дочерний элемент

91
Глава 5. Структуры данных на основе графов
этого дочернего элемента, как было в случае, показан­
ном на рис. 5.5), поэтому мы снова вызываем алгоритм
MaxHeapify для этого поддерева (алгоритм 2).
В худшем случае каждый раз при объединении куч
новый корень должен перемещаться в самое основание
дерева. Каждый узел, который обрабатывается таким
образом, может быть сравнен с O(lg n) потомками, при­
чем каждое сравнение занимает постоянное количество
времени. Умножив это на n узлов, получим общее время
выполнения алгоритма O(n lg n).

92
Часть II. Графы и графовые алгоритмы
В алгоритмах BuildMaxHeap и MaxHeapify параметр
.heapSize может показаться избыточным. Проверка
того, является ли какой-либо узел меньше A.heapSize,
всегда будет возвращать true, поскольку размер кучи
задан равным размеру массива. Однако при запуске
Heapsort этот узел отмечает конец оставшихся неотсор­
тированных элементов кучи.
В алгоритме Heapsort (см. алгоритм 3) после построения
кучи корень (который является самым большим эле­
ментом) перемещается в конец массива, где он и оста­
ется. Затем мы уменьшаем значение heapSize и снова
вызываем MaxHeapify для остальной части массива.
Каждый раз, когда значение heapSize уменьшается,
оставшиеся heapsize – 1 элементов массива, отличные
от корня, образуют кучу и вызов Heapify для корня вос­
станавливает свойство кучи. Элемент, перемещенный
в конец массива, был самым большим из оставших­

93
Глава 5. Структуры данных на основе графов
ся элементов, поэтому после k-й итерации в позициях
[heapsize ... n] находятся k самых больших элементов
в отсортированной последовательности.
5.3.2.  Добавление элементов
в кучу
Элемент, добавляемый в кучу, вставляется в ближай­
шее доступное место (то есть в первую пустую ячей­
ку массива) (рис. 5.8). Если при этом новый элемент
больше родительского элемента, это может нарушить
свойство неубывания. В таком случае нужно поднять
этот элемент вверх, рекурсивно меняя его местами
с родительскими элементами, пока они меньше этого
элемента.
Поскольку максимальная высота дерева равна O(lg n)
и каждое сравнение/обмен занимает время O(1), общее
время вставки равно O(lg n).
5.3.3.  Удаление корня из кучи
Чтобы извлечь первый элемент из кучи, достаточно уда­
лить первый элемент массива; однако при этом в куче
остается пустое место, которое мы заменяем последним
элементом кучи, при необходимости оставляя почти
полное дерево (рис. 5.9). Затем мы поднимаем новый
корень вверх, заменяя его дочерними узлами с бóль­
шими значениями, пока дерево снова не приобретет
свойство кучи.

94
Часть II. Графы и графовые алгоритмы
Рис. 5.8. Добавление элемента в кучу

95
Глава 5. Структуры данных на основе графов
Рис. 5.9. Удаление корня из кучи

6
Хорошо известные
графовые алгоритмы

## Сложите два ломтика вместе. Приятного аппетита!
### Введение

Есть алгоритмы на графах, которые встречаются в раз­
личных приложениях настолько часто, что знать о них
вы просто обязаны. Многие из них представляют со­
бой различные способы сортировки графа или поис­
ка подграфа с определенным свойством. Понимание
относительных преимуществ этих фундаментальных
алгоритмов — ключ к определению, когда использовать
каждый из них в практических приложениях.
Эта глава начинается с описания алгоритмов поис­
ка в ширину (Breadth-First Search, BFS) и в глуби­
ну (Depth-First Search, DFS), которые превращают
произвольный граф в дерево поиска. В обоих случаях
мы назначаем одну из вершин графа корнем дерева
и рекурсивно исследуем ребра каждой вершины, пока
все вершины графа1 не будут добавлены в остовное
1
То есть любая вершина, которой можно достичь, переходя
по ребрам от корня; в случае связного графа это будут все
вершины.

97
Глава 6. Хорошо известные графовые алгоритмы
де­рево1. Рассмотрим, для каких типов приложений по­
лезен каждый вид дерева поиска, а затем перейдем к по­
иску кратчайших путей.
При анализе времени выполнения алгоритмов на гра­
фах обычно используются две системы обозначений.
Одна из них — это обозначение числа вершин буквой n,
а числа ребер — буквой m. Другая — указать размеры
множеств вершин и ребер.
Для графа G множество вершин обозначается как V(G)
[читается «вершины G»), а множество ребер — как E(G)
(читается «ребра G»), поэтому n = |V(G)|, а m = |E(G)|.
Математическое предупреждение
Напомню, что в  математике заключение значения
в  прямые скобки означает получение абсолютного
значения или размера; здесь это означает размер мно­
жества, поэтому |V(G)| можно прочитать как «размер
множества вершин G». Если G подразумевается по
умолчанию, то можно обращаться к множествам про­
сто как V и E.

## Сложите два ломтика вместе. Приятного аппетита!
### Поиск в ширину

При поиске в ширину мы сначала исследуем все вер­
шины, которые примыкают к корню; затем исследуем
1
Остовное дерево графа — это дерево, которое содержит все
вершины графа.

98
Часть II. Графы и графовые алгоритмы
все вершины, смежные с соседями корня, которые еще
не были исследованы, и т. д. Таким образом, вначале мы
исследуем все вершины, которые находятся на расстоя­
нии k от корня (который обычно обозначается буквой s,
от слова source — «источник»), и лишь затем переходим
к вершинам на расстоянии k + 1.
Когда алгоритм завершает работу, глубина каждо­
го узла дерева — это минимальное количество ребер
(то есть длина кратчайшего пути), по которому можно
добраться до этого узла из s как в дереве, так и в ис­
ходном графе. Чтобы найти этот путь, нужно идти по
указателям на родительские узлы, пока не будет до­
стигнут узел s.
Каково время выполнения поиска в ширину? При ини­
циализации для каждой вершины инициализируются
три упомянутых выше свойства, что занимает посто­
янное время для каждой вершины, в сумме O(n). За­
тем каждая вершина добавляется в очередь, удаляется
из очереди, и каждое из свойств изменяется не более
одного раза — каждая из этих операций занимает O(1)
времени, так что для всех вершин снова получаем O(n).
Наконец, мы перебираем всех соседей каждой верши­
ны, чтобы проверить, отмечены ли они, что занимает
еще O(m) времени (алгоритм 4). В сумме получаем об­
щее время выполнения O(n + m).
Для хранения графа требуется n + m места в памяти,
а очередь занимает O(n) места, поэтому в сумме тре­
буется пространство объемом O(n + m). Это также
означает, что алгоритм поиска в ширину работает за

99
Глава 6. Хорошо известные графовые алгоритмы
линейное время по отношению к размеру входных
данных (который равен n + m).

100
Часть II. Графы и графовые алгоритмы

## Сложите два ломтика вместе. Приятного аппетита!
### Применение поиска

в ширину
Как показано ранее, поиск в ширину позволяет найти
длину кратчайшего пути от исходной вершины s до
любой другой вершины графа за линейное время. За­
тем мы можем найти сам путь, следуя по родительским
указателям от исходного узла до корня дерева, за вре­
мя, пропорциональное длине пути. Это означает, что
алгоритм поиска в ширину полезен для всех задач, где
нужен поиск кратчайших путей. Вот несколько при­
меров таких задач.
6.3.1.  Навигационные системы
Рассмотрим задачу построения маршрутов с помощью
GPS. Если картографическая система хранит данные
о локальной области в виде графа, вершинами которого
являются адреса (или пересечения), а ребрами — улицы
(или, точнее, короткие отрезки улиц), то она может вы­
полнять поиск в ширину для дерева, источник которо­
го — ваше текущее местоположение.
6.3.2.  Проверка, является ли граф
двудольным
При запуске поиска в ширину, если существует ребро
между данной вершиной и уже отмеченной вершиной,
расстояние которой либо такое же, либо меньше в степе­
ни 2, этим двум вершинам будет присвоен один и тот же
цвет и граф не будет двудольным. Кроме того, ребро

101
Глава 6. Хорошо известные графовые алгоритмы
вместе с одним или несколькими путями к наимень­
шему общему предку двух вершин является нечетным
циклом, который будет признаком того, что граф не дву­
дольный1. Двудольные графы используются в теории
кодирования2, в сетях Петри3, в анализе социальных
сетей и облачных вычислениях.

## Сложите два ломтика вместе. Приятного аппетита!
### Поиск в глубину

Как и при поиске в ширину, при поиске в глубину мы
начинаем с исходной вершины и рекурсивно проходим
остальную часть графа (алгоритм 5). Но только теперь
мы продвигаемся настолько глубоко, насколько можем,
по одному пути и только потом исследуем другие пути.
Представьте, что вы изучаете собак. Студент, использу­
ющий алгоритм поиска в ширину, может начать с изуче­
ния названий всех пород — от австралийской коротко­
хвостой пастушьей собаки до японского шпица — и лишь
потом углубиться в детали. Тот же, кто использует поиск
в глубину, начнет с австралийской коротко­хвостой, кото­
рая является пастушьей породой, поэтому он прочитает
все о пастушьих собаках, что приведет его к чтению
1
Сертификат — это доказательство того, что ответ, возвраща­
емый программой, является правильным; подробнее об этом
вы прочитаете в главе 19.
2
Теория кодирования изучает, в частности, криптографию,
сжатие данных и исправление ошибок.
3
Сети Петри используются для моделирования поведения
систем.

102
Часть II. Графы и графовые алгоритмы
о стадах, это, в свою очередь, — к истории о домашних
животных, что приведет к… В общем, идею вы поняли.
Если область поиска слишком велика или даже беско­
нечна, может использоваться модифицированная версия
поиска в глубину, которая работает только до указанной
глубины.

103
Глава 6. Хорошо известные графовые алгоритмы
Практическое применение
Недавно меня попросили помочь решить задачу плани­
рования. Было несколько заданий, которые требовалось
выполнить, со следующими ограничениями:
•	ни одно задание нельзя начать раньше определенно­
го времени;
•	каждое задание имеет максимальное время выпол­
нения;
•	у задания может быть ноль или более заданий, от
которых оно зависит, и ноль или более заданий, ко­
торые зависят от него; выполнение задания нельзя
начать, пока не будут выполнены все задания, от
которых оно зависит. Циклических зависимостей
нет (поэтому это орграф частично упорядоченного
множества);
•	на выполнение всех заданий может уйти не более
24 часов.
Поиск кратчайшего пути — распространенная задача,
но в данном случае мы фактически хотели найти са­
мый длинный путь для каждой задачи, что и сделали,
используя модификацию алгоритма поиска в глубину.
Это позволило нам построить такой порядок выпол­
нения заданий, который гарантировал, что во время
выполнения любого задания все предки этого задания
в графе зависимостей уже были выполнены, так что
самое длительное время выполнения задания было
равно сумме самого позднего времени, требуемого для
выполнения любого из родителей данного задания,
и количества времени, отведенного для самого задания.
Повторное выполнение алгоритма в обратном порядке

104
Часть II. Графы и графовые алгоритмы
позволило выявить все цепочки зависимостей, которые
будут выполняться после выделенного времени, что
позволило выяснить, какие задачи необходимо опти­
мизировать.

## Сложите два ломтика вместе. Приятного аппетита!
### Кратчайшие пути

Рассмотрим задачу наискорейшего перемещения из
одного места в другое. В теории графов это задача крат­
чайшего пути: найти маршрут между двумя вершина­
ми, имеющий наименьший вес. В невзвешенном графе
это просто путь с наименьшим количеством ребер; во
взвешенном графе это путь с наименьшим суммарным
весом ребер.
Рассмотрим вариации этой задачи.
z
z Кратчайший путь из одной вершины. Найти крат­
чайший путь от исходного узла ко всем остальным
узлам графа. Пример: узнать кратчайший путь от
пожарной части до каждой точки города.
z
z Кратчайший путь в заданный пункт назначения.
Найти кратчайший путь от каждого узла графа до
данной точки назначения. Это просто задача поиска
кратчайшего пути из одной вершины, для которой
направление всех ребер изменено на противополож­
ное. Например, мы можем захотеть узнать кратчай­
ший путь до больницы из любой точки города.
z
z Кратчайший путь между всеми парами вершин.
Найти кратчайший путь между всеми парами узлов
графа. В идеа­ле наш GPS сможет построить наилуч­
ший маршрут из любой точки в любую точку.

105
Глава 6. Хорошо известные графовые алгоритмы
6.5.1.  Алгоритм Дейкстры
Алгоритм Дейкстры1 изначально определял кратчай­
ший путь между двумя узлами графа, но был расширен
таким образом, что теперь он решает задачу поиска
кратчайшего пути из одной вершины (алгоритм 6). Этот
алгоритм применим к любому взвешенному графу (на­
помню, что невзвешенный граф — это просто взвешен­
ный граф, у которого вес каждого ребра равен 1), у ко­
торого все ребра имеют неотрицательный вес.
1
www-m3.ma.tum.de/twiki/pub/MN0506/WebHome/dijkstra.pdf.

106
Часть II. Графы и графовые алгоритмы
В алгоритме Дейкстры мы начинаем с исходной верши­
ны s и множества узлов S (в настоящее время пустого),
расстояние до которых было определено. Мы добав­
ляем все элементы графа в очередь с приоритетом на
основе их расстояния от s; сначала расстояние для s
равно нулю; у всех остальных узлов расстояние равно
бесконечности. Мы удаляем из очереди наименьший
элемент (которым первоначально будет s) и «ослабляем»
все его ребра. Далее мы продолжаем удалять наимень­
шие элементы и «ослаблять» его ребра до тех пор, пока
очередь не станет пустой, после чего каждому узлу при­
сваивается длина его кратчайшего пути (алгоритм 7).
«Ослабление» ребра в данном случае означает, что мы
берем приоритет текущего узла u, прибавляем к нему
расстояние w до нового узла v и сравниваем сумму с теку­
щим приоритетом v. Если сумма оказывается меньше су­
ществующего значения v.d, это значит, что мы нашли бо­
лее короткий путь к v и можем заменить старое значение;

107
Глава 6. Хорошо известные графовые алгоритмы
мы также помечаем u как нового родителя для v. Каждый
раз, когда узел удаляется из очереди с приоритетом, мы
знаем, что уже нашли кратчайший путь к этому узлу,
потому что любой более короткий путь должен был бы
пройти через уже обработанные узлы.
Рис. 6.1. Поиск всех кратчайших путей из множества S
с помощью алгоритма Дейкстры. Каждая строка таблицы
представляет один шаг, на котором мы обрабатываем ранее
необработанную вершину с наименьшим весом
Это жадный алгоритм1, то есть на каждом шаге он делает
все, что кажется лучшим на данный момент. Поскольку
1
Подробнее о жадных алгоритмах и других подходах к реше­
нию задач рассказывается в части IV.

108
Часть II. Графы и графовые алгоритмы
мы считаем, что каждый узел в множестве S помечен
длиной его кратчайшего пути, алгоритм Дейкстры (в от­
личие от многих других жадных алгоритмов) гаранти­
рованно возвращает оптимальное решение.
«Ослабление» ребра занимает постоянное время, что
в сумме дает время O(m) для обработки всех ребер.
Поиск элемента с наименьшим приоритетом для после­
дующей обработки занимает время O(n), и это выполня­
ется O(n) раз, что дает общее время O(n2). В сумме это
дает O(n2 + m), где m ≤ n2, поэтому сложность алгоритма
Дейкстры составляет O(n2).

7
Основные классы
графов
Многие задачи достаточно сложны для произвольных
графов (являются NP-сложными), но имеют эффектив­
ные (или даже тривиальные) решения для графов опре­
деленного класса. И наоборот, задача может не иметь
решения на графах определенного класса. Таким об­
разом, мы часто можем избежать проблем, если удастся
показать, что данная задача относится к определенному
классу графов.

## Сложите два ломтика вместе. Приятного аппетита!
### Запрещенные подграфы

Характеризация запрещенными подграфами для класса
графов — метод, определяющий набор структур, кото­
рые не должны появляться в графе; наличие или отсут­
ствие таких структур говорит о том, принадлежит ли
данный граф к этому классу. Такие запрещенные под­
структуры могут быть определены несколькими спо­
собами.
z
z Графы. Граф может принадлежать к классу, толь­
ко если он не содержит подграфа из (возможно,
бесконечного) множества. Например, двудольные

110
Часть II. Графы и графовые алгоритмы
­графы — это только такие графы, которые не содер­
жат нечетных циклов.
z
z Индуцированные графы. То же самое, что и в пре­
дыдущем случае, за исключением того, что здесь
нас интересуют только индуцированные подграфы
(напомню, что это некоторое подмножество вершин
графа вместе со всеми ребрами между этими верши­
нами). Например, хордальные графы — это такие
графы, которые не содержат индуцированного бес­
хордового цикла длиной не менее четырех.
z
z Гомеоморфные графы. Два графа называются гоме­
оморфными, если один из них можно получить из
другого, удалив вершины второй степени1 и свернув
все ребра в одно.
z
z Миноры графа. Минором графа называется под­
граф, получаемый посредством стягивания ребер,
где стягивание ребер происходит, когда мы выби­
раем две смежные вершины и объединяем их в одну.
Как вы увидите в следующем разделе, класс графов
может иметь несколько характеризаций запрещенными
подграфами разных типов.

## Сложите два ломтика вместе. Приятного аппетита!
### Планарные графы

В главе 4 описана задача о кенигсбергских мостах, кото­
рая включает в себя представление карты в виде графа.
Класс графов, представляющих карты на плоскости
1
Степень вершины — это количество ее ребер. В данном случае
это означает, что все вершины имеют ровно два ребра.

111
Глава 7. Основные классы графов
(или сфере1), имеет специальное название: планарные
графы. Формально планарный граф — это граф, кото­
рый может быть построен на плоскости, следовательно,
он может быть нарисован так, что все его ребра пересе­
каются только в вершинах графа. Любая плоская карта
может быть представлена в виде плоского графа: для
этого достаточно заменить каждую область вершиной
и провести ребра там, где раньше были общие границы.
Теорема Куратовского классифицирует планарные
графы в терминах запрещенных подграфов: планарные
графы — это только такие графы, которые не содержат
подграфов, гомеоморфных K5 (полный граф из пяти
вершин, приведен на рис. 7.1) или K3,3 (полный двудоль­
ный граф из шести вершин, см. раздел 7.4, рис. 7.2).
Рис. 7.1. K5 — полный граф
из пяти вершин
Рис. 7.2. Граф K3,3, также
известный как «домики
и колодцы»
Теорема Вагнера классифицирует планарные графы как
те, что не содержат те же подграфы в качестве миноров.
1
Плоскость — это просто сфера с удаленным северным по­
люсом. Прости, Санта.

112
Часть II. Графы и графовые алгоритмы
Рассмотрим следующее
Предположим, у нас есть граф K5, который не являет­
ся планарным, — нет возможности нарисовать его на
плоскости хотя бы без одного пересечения ребер. Если
добавить вершину в середину только одного ребра, это
не устранит пересечение, поэтому новый граф также
не будет планарным. Именно поэтому запрещенным
является любой подграф, гомеоморфный K5 или K3,3.
Формула Эйлера гласит, что если конечный связный
граф из v вершин, e ребер и f граней можно представить
на плоскости без пересечений ребер1, то v − e + f = 2.
Определение планарного графа (такого, который может
быть построен на плоскости без пересечения ребер),
естественно, означает, что такие графы удобны для ото­
бражения, так как легче увидеть, куда ведут все ребра
(и фактически каждый такой граф можно нарисовать
так, чтобы все ребра были отрезками прямых линий2).
Приложение для рисования графов может разбить граф
на плоские компоненты и объединить их, чтобы полу­
чить «более приятную» визуализацию. Это также имеет
практическое применение в таких областях, как проек­
тирование электронных схем.
Планарные графы можно разбить на более мелкие части,
удалив O(√ n ) вершин, что помогает в разработке алго­
ритмов типа «разделяй и властвуй» и при динамическом
программировании (см. главу 10) на планарных графах.
1
Это, конечно, доказывает, что граф планарный.
2
Теорема Фари.

113
Глава 7. Основные классы графов

## Сложите два ломтика вместе. Приятного аппетита!
### Совершенные графы

В разделе 4.7 представлена концепция раскраски гра­
фа, где хроматическое число графа — это минимальное
количество цветов, необходимое для его правильной
раскраски. Для графа, который содержит полный под­
граф (порожденный подграф, содержащий все возмож­
ные ребра) размером k, очевидно, хроматическое число
должно быть не менее k. Совершенным графом назы­
вается такой граф, для которого это строгое равенство
(хроматическое число строго равно k) и в котором это
строгое равенство для хроматического числа также вы­
полняется для всех порожденных подграфов. Другими
словами, граф совершенен тогда и только тогда, когда
для этого графа и для всех его порожденных подграфов
хроматическое число равно размеру наибольшей клики1.
Свойство совершенности является наследуемым; это
озна­чает, что если граф совершенен, то все его поро­
жденные подграфы также совершенны. Наследуемость
совершенных графов следует из приведенного выше
определения: если все порожденные подграфы графа
удовлетворяют условию совершенности, то очевидно,
что все порожденные подграфы этих подграфов также
должны удовлетворять этому условию.
В действительности существует несколько эквива­
лентных определений совершенного графа2. Сильная
1
Словами «клика» и «полный подграф» обозначается одно
и то же понятие. Так бывает.
2
Чтобы доказать, что эти определения действительно экви­
валентны, потребовалось приложить усилия. Подробно­
сти читайте в книге Мартина Голамбика (Martin Golumbic)
Algorithmic Graph Theory and Perfect Graphs.

114
Часть II. Графы и графовые алгоритмы
теорема о совершенных графах характеризует их как
такие графы, которые не содержат нечетных отверстий
(порожденных бесхордовых циклов нечетной длины)
или антиотверстий (дополнений этих циклов). Слабая
теорема о совершенных графах характеризует их как
дополнения к совершенным графам (то есть дополнение
каждого совершенного графа само по себе является со­
вершенным). Эта теорема непосредственно следует из
доказательства сильной теоремы о совершенных графах.
Еще одной характеристикой совершенных графов яв­
ляется то, что для таких графов произведение разме­
ров наибольшей клики и наибольшего независимого
множества больше или равно числу вершин графа. Это
также верно для всех порожденных подграфов.
В число задач, которые являются NP-сложными на про­
извольных графах, но решаются за полиномиальное
время на совершенных графах, входит раскраска гра­
фа, определение максимальной клики и максимально­
го независимого множества. Подклассы совершенных
графов (некоторые из них рассмотрены в этой главе)
включают в себя двудольные графы (то есть такие, у ко­
торых хроматическое число равно двум), хордальные
графы (такие, у которых нет хордовых циклов длиной
больше трех), графы сравнимости (которые отражают
частично упорядоченное множество) и подмножества
этих классов1. Как мы увидим в следующем разделе,
1
Эти подмножества включают в себя интервальные графы —
хордальные графы, которые можно изобразить в виде набора
последовательных интервалов и лесов — графов, в которых
каждый связный компонент представляет собой дерево.

115
Глава 7. Основные классы графов
эти подклассы являются совершенными графами с до­
полнительными ограничениями.

## Сложите два ломтика вместе. Приятного аппетита!
### Двудольные графы

Двудольные графы — это графы, для которых хроматиче­
ское число равно двум. Здесь они рассмотрены главным
образом для того, чтобы вы увидели, насколько легко
можно распо­знать класс графа. Для этого нужно выбрать
одну вершину графа из каждого связного компонента,
присвоить ей первый цвет и добавить ее в очередь. Каж­
дый раз, когда вершина удаляется из очереди, рассма­
триваются все ее соседки и, если какая-либо из них еще
не окрашена, ей присваивается противоположный цвет,
после чего она добавляется в очередь. Если соседняя
вершина уже раскрашена в тот же цвет, что и выбранная
вершина, то граф не является двудольным (и две верши­
ны образуют часть нечетного цикла); в противном случае
мы получаем на выходе 2-раскраску графа.
Двудольные графы применяются в сетях Петри (кото­
рые используются для описания распределенных си­
стем) и для множества других известных задач, включая
задачу об устойчивом браке1 и задачу назначения2.
1
В задаче об устойчивом браке каждый человек из группы A
сопоставляется с человеком из группы B таким образом, что­
бы не было пар, в которых бы он предпочитал того, кто также
предпочитает его.
2
В задаче назначения каждый агент выполняет ровно одно за­
дание (разные задания могут стоить по-разному, в зависимо­
сти от того, какой агент их выполняет); задания назначаются
таким образом, чтобы свести к минимуму общую стоимость.

116
Часть II. Графы и графовые алгоритмы

## Сложите два ломтика вместе. Приятного аппетита!
### Интервальные графы

Интервальные графы — это графы, которые можно
изобразить в виде набора пересекающихся отрезков,
расположенных вдоль общей линии, где каждый от­
резок представляет вершину; две вершины являются
смежными тогда и только тогда, когда соответствующие
сегменты линии пересекаются.
Как и совершенные графы, подклассом которых они
являются, интервальные графы имеют несколько харак­
теризаций. Характеризация запрещенными подграфа­
ми формулируется в терминах астероидальных троек.
Они представляют собой наборы из трех вершин графа,
где между любыми двумя вершинами существует такой
путь, который избегает окрестности третьей вершины.
Интервальные графы — это такие графы, которые яв­
ляются хордальными и не содержат астероидальных
троек. На рис. 7.3 представлена астероидальная тройка.
Рис. 7.3. Вершины A, B и C образуют астероидальную
тройку; между любыми двумя из этих вершин существует
путь, который не содержит никаких вершин, смежных
с третьей

117
Глава 7. Основные классы графов
Вероятно, самым известным является применение ин­
тервальных графов в генетическом анализе; интерваль­
ные графы были использованы для определения того,
что субэлементы гена с высокой вероятностью связаны
друг с другом, образуя линейную структуру1.
Интервальные графы обычно используются в задачах
выделения ресурсов: каждый интервал представляет
запрос ресурса, а раскраска графа соответствует выде­
лению этих ресурсов. Например, если каждый интервал
представляет урок, а два интервала пересекаются, если
уроки в какой-то момент совпадают, то хроматическое
число графа — это минимальное количество необходи­
мых классных комнат, а раскраска распределяет уроки
по этим комнатам.

## Сложите два ломтика вместе. Приятного аппетита!
### Графы дуг окружности

Надмножеством интервальных графов2 являются гра­
фы дуг окружности — такие графы, которые можно изо­
бразить в виде набора пересекающихся дуг окружности
(рис. 7.4). Две вершины такого графа будут смежными
тогда и только тогда, когда соответствующие дуги пере­
секаются. Если граф дуг окружности можно предста­
вить так, чтобы окружность не была замкнута, то такой
1
О топологии тонкой генетической структуры читайте работы
Сеймура Бензера (Seymour Benzer), 1959.
2
Другими словами, каждый интервальный граф также являет­
ся графом пересечения дуг окружности. Это строгое отноше­
ние надмножеств, поскольку обратное неверно: многие графы
пересечения дуг окружности не являются интервальными.

118
Часть II. Графы и графовые алгоритмы
граф также интервальный; если разорвать круг в не­
замкнутой части и растянуть его в линию, то получим
интервальное представление.
Рис. 7.4. C4, бесхордовый цикл из четырех вершин,
представленный в виде графа дуг окружности
В то время как интервальные графы являются строгим
подмножеством как совершенных графов, так и графов
дуг окружности, последние классы пересекаются. Класс
графов пересечения дуг окружности содержит как со­
вершенные графы (например, интервальные), так и гра­
фы, которые не являются совершенными (нечетные
бесхордовые циклы). Подобно интервальным графам,
графы дуг окружности можно классифицировать по их
запрещенным подграфам.

Часть III
Неграфовые
алгоритмы

8
Алгоритмы
сортировки
Сортировка относится к тем задачам, о которых боль­
шинству программистов никогда не приходится ду­
мать; за них это делает язык программирования или
библио­теки. Как правило, подходящий алгоритм со­
ртировки выбирается автоматически в зависимости
от объема входных данных. Например, на платформе
.NET массивы сортируются методом вставки, пира­
мидальной или быстрой сортировки, в зависимости
от задачи (https://msdn.microsoft.com/en-us/library/85y6y2d3
(v=vs.110).aspx).
Так зачем же создавать собственный алгоритм сорти­
ровки? Возможно, вам нужна устойчивая сортировка
(то есть такая, в которой два элемента с одинаковым
ранжированием будут размещаться в одинаковом по­
рядке друг относительно друга), а предоставляемые
готовые алгоритмы сортировки не являются устойчи­
выми. Или же вы обладаете дополнительной инфор­
мацией о сортируемых данных, что может значительно
сократить время выполнения алгоритма.
Наиболее эффективно изменить алгоритм сортировки
можно, если:

121
Глава 8. Алгоритмы сортировки
z
z данные и так уже почти отсортированы;
z
z данные расположены в обратном или почти в об­
ратном порядке;
z
z данные представляют собой конечное число дискрет­
ных значений, относительно малое по сравнению
с количеством сортируемых элементов.
В этой главе рассмотрены некоторые характерные ал­
горитмы сортировки. Сравним их преимущества и не­
достатки.
Большинство алгоритмов сортировки — сортировка
сравнением, когда два элемента сортируемого списка
сравниваются с помощью некоторой операции, которая
определяет, что один из них меньше или равен друго­
му (размещается перед ним). Сложность алгоритмов
сортировки сравнением обычно определяется количе­
ством требуемых операций сравнения.

## Сложите два ломтика вместе. Приятного аппетита!
### Малые и большие алгоритмы

сортировки
Первые два вида сортировки, которые мы рассмотрим,
имеют неэффективную среднюю сложность. Это озна­
чает, что на больших наборах данных они будут слиш­
ком медленными, поэтому бесполезными. Однако для
небольших наборов данных асимптотически неэффек­
тивный алгоритм может работать быстрее, чем асимпто­
тически эффективный алгоритм.
Множество из восьми элементов алгоритм со слож­
ностью O(n2) отсортирует примерно за 64 сравнения,

122
Часть III. Неграфовые алгоритмы
а алгоритм со сложностью O(n lg n) — всего за 24 срав­
нения, однако каждое сравнение может потребовать
меньше дополнительной работы, и в результате асим­
птотически медленный алгоритм на практике работает
быстрее. Однако при сортировке тысячи элементов
вряд ли удастся преодолеть стократное асимптотиче­
ское ускорение более эффективного алгоритма.
Затем мы рассмотрим три алгоритма со сравнением,
которые выполняются за среднее время O(n lg n), и два
алгоритма, в которых невозможно подсчитать количе­
ство сравнений, потому что в них значения не сравни­
ваются между собой.
Время выполнения сортировки сравнением в худшем
случае составляет O(n lg n) — это лучшее, что можно
получить, и это можно продемонстрировать следу­
ющим образом. Каждое сравнение определяет относи­
тельный порядок двух значений и поэтому может рас­
сматриваться как внутренний узел сбалансированного
двоичного дерева, каждый лист которого является
одним из n! возможных вариантов размещения эле­
ментов. В сбалансированном двоичном дереве с k ли­
стьями любой путь от корня до листа состоит из lg k
внутренних узлов или вариантов выбора (в данном
случае сравнений), поэтому существует lg n! сравне­
ний; согласно приближению Стирлинга, lg n! имеет
сложность O(n lg n).1
1
Это упрощенное объяснение; более подробное объяснение
с точными цифрами вы найдете в подразделе 5.3.1 книги
«Искусство программирования» Дональда Кнута (Donald
Knuth).

123
Глава 8. Алгоритмы сортировки

## Сложите два ломтика вместе. Приятного аппетита!
### Сортировки для малых наборов

данных
8.2.1.  Сортировка пузырьком
Сортировка пузырьком (bubble sort) не имеет практиче­
ской пользы — ее обычно приводят в качестве примера
наивного алгоритма сортировки. Однако благодаря
своей простоте она дает хорошее представление о сор­
тировке. Алгоритм состоит в том, что каждая пара со­
седних элементов массива сравнивается и, если эти эле­
менты не расположены в должном порядке, их меняют
местами.
Пример: сортировка пузырьком
На k-й итерации k самых больших значений гаран­
тированно находятся в конце списка, поэтому после
n – 1 итераций список отсортирован с общим временем

124
Часть III. Неграфовые алгоритмы
выполнения O(n2). Интересно, что это не только слож­
ность наихудшей ситуации (по которой обычно из­
меряется эффективность алгоритмов), но и средняя
сложность. Однако в лучшем случае время выполнения
составит всего O(n). Если список уже полностью или
почти отсортирован, то, поскольку сортировка пузырь­
ком способна это обнаружить (при этом не выполня­
ется никаких перестановок), она эффективно работа­
ет для таких наборов данных. Это свойство присуще
также сортировке вставками, о которой мы поговорим
позже. Такая сортировка была бы более полезной во
времена ленточных накопителей, когда последователь­
ный доступ выполнялся намного быстрее, чем произ­
вольный.
8.2.2.  Сортировка вставками
Сортировка вставками (insertion sort) — еще один спо­
соб сор­тировки, который прост в реализации, но, в от­
личие от сортировки пузырьком, он действительно
полезен для небольших наборов данных. Этот метод
также обладает тем преимуществом, что он интуитивно
понятен для большинства людей1.
Сортировка вставками выполняется путем перебора
элементов массива. Если размер массива равен едини­
це, то такой массив явно упорядочен. Каждый элемент,
добавляемый в конец массива (то есть при просмотре
1
Вы когда-нибудь играли в бридж или преферанс? Большин­
ство людей берут карты по одной и вставляют каждую карту
на свое место среди уже отсортированных карт, которые
держат в руке. Это и есть сортировка вставкой!

125
Глава 8. Алгоритмы сортировки
следующего элемента массива), либо больше, чем все
остальные элементы, либо его можно переместить в пра­
вильное место массива, сместив все расположенные
после него отсортированные элементы в конец на одну
ячейку.
Пример: сортировка вставками
Подобно сортировке пузырьком, наилучшая сложность
сор­тировки вставкой (когда массив уже отсортирован)
равна O(n), а наихудшая сложность (когда массив от­
сортирован в обратном порядке) равна O(n2). На прак­
тике алгоритм быстро работает для небольших масси­
вов и обычно применяется для сортировки небольших
участков массивов в рекурсивных алгоритмах, таких
как быстрая сортировка и сортировка слиянием1.
У сортировки вставками есть еще несколько приятных
особенностей. В частности, она стабильна, выполняется
на месте и онлайн. Онлайн-алгоритм — это такой алго­
ритм, в котором значения могут обрабатываться по мере
их поступления; они могут быть недоступны все сразу
с самого начала.
1
После того как однажды мне пришлось проверить 160 уче­
нических работ и выставить оценки, я привык сортировать
вставкой стопки из 8–10 работ, объединять эти стопки мето­
дом сортировки слиянием, а затем записывать оценки.

126
Часть III. Неграфовые алгоритмы

## Сложите два ломтика вместе. Приятного аппетита!
### Сортировка больших

наборов данных
8.3.1.  Пирамидальная сортировка
Подобно предыдущим алгоритмам сортировки, пира­
мидальная сортировка делит входные данные на отсор­
тированную и неотсортированную части и поэтапно
перемещает элементы в отсортированную часть. В отли­
чие от предыдущих методов сортировки пирамидальная
сортировка требует предварительной обработки данных.
Сначала из данных строится куча, а затем самый боль­
шой элемент кучи многократно извлекается и вставля­
ется в массив. Построение кучи требует O(n) операций1.
Извлечение из кучи максимального элемента и восста­
новление кучи требуют O(lg n) операций. Поскольку
нужно извлечь все n элементов, наилучшая и наихудшая
производительность составляет O(n lg n)2. Обратите вни­
мание: хотя асимптотическая сложность для наилучшего
и наихудшего случаев одинакова, на практике наилучшее
время выполнения будет примерно в два раза быстрее3.
8.3.2.  Сортировка слиянием
При сортировке слиянием (merge sort) список сорти­
руется рекурсивно: массив делится на несколько мас­
1
O(n lg n) для некоторых вариаций.
2
Schaffer R., Sedgewick R. The Analysis of Heapsort // Journal
of Algorithms. Vol. 15. Issue 1, July, 1993.
3
Bolloba's B., Fenner T. I., Frieze A. M. On the Best Case of Heap­
sort // Journal of Algorithms. Vol. 20. Issue 2, March, 1996.

127
Глава 8. Алгоритмы сортировки
сивов меньшего размера, которые сортируются, а затем
объединяются. При чистом слиянии можно продолжать
деление до тех пор, пока каждый набор не будет содер­
жать только одно значение. Затем множества объеди­
няются; имея два отсортированных набора размером k,
мы можем создать полностью упорядоченный объеди­
ненный набор, при этом число сравнений составит
от k до 2k – 1.
Пример: сортировка слиянием
Это дает O(lg n) комбинированных шагов, каждый из
которых занимает O(n) времени, так что общее время
выполнения алгоритма составляет O(n lg n).
На практике вместо того, чтобы делить исходный на­
бор данных на отдельные элементы, обычно прекра­
щают деление, когда наборы достаточно малы, чтобы

128
Часть III. Неграфовые алгоритмы
использовать алгоритм с наилучшим временем выпол­
нения для небольших наборов данных (например, сор­
тировку вставками).
8.3.3.  Быстрая сортировка
Алгоритм быстрой сортировки (quick sort) интересен
тем, что его наихудшее время выполнения O(n2) хуже,
чем у сортировки слиянием и пирамидальной сорти­
ровки, но на практике он обычно работает в 2–3 раза
быстрее этих алгоритмов, его среднее время достигает
O(n lg n)1.
Быстрая сортировка работает так: выбирается опор­
ный элемент, после чего остальные элементы масси­
ва упорядочиваются так, чтобы все элементы слева
от опорного были меньше или равны, а все элементы
справа — больше или равны опорному элементу. Затем
алгоритм рекурсивно вызывается для левого и правого
сегментов массива и так далее до достижения базового
случая (когда каждый сегмент содержит одно или ноль
значений).
Фактическое количество требуемых итераций зависит
от выбора опорного элемента и от значений, которые
необходимо отсортировать. Например, метод Ломуто
состоит в том, чтобы просто выбрать в качестве опорно­
го последний элемент массива (или сегмента массива);
это легко реализовать, но тогда, если массив уже отсор­
1
Скиена С. Алгоритмы. Руководство по разработке. — СПб.:
BHV, 2017.

129
Глава 8. Алгоритмы сортировки
тирован, время выполнения составит O(n2), потому
что на каждой итерации сегмент будет уменьшаться
только на один элемент. Чтобы этого избежать, можно
выбрать в качестве опорного элемент, находящийся
в середине массива, случайный элемент или медиану из
трех случайных элементов. В идеале опорный элемент
будет точной медианой сортируемых данных, а каж­
дый из двух новых разделов будет содержать половину
оставшихся данных. При известном (неслучайном)
методе выбора опорного элемента злоумышленник мо­
жет увеличить время выполнения до O(n2), намеренно
размещая данные таким образом, чтобы опорный эле­
мент каждый раз находился с одной и той же стороны
от элемента, с которым он сравнивается.
Пример: быстрая сортировка
По аналогичным причинам быстрая сортировка так­
же будет плохо работать с массивами, содержащими

130
Часть III. Неграфовые алгоритмы
большое количество повторяющихся значений1, но
это можно исправить, используя сортировку не на два,
а на три раздела (меньше, равно, больше). В этом случае
средний раздел не нуждается в дальнейшей сортировке,
поэтому при сортировке массивов с большим коли­
чеством дубликатов можно получить более быстрые
результаты (а если все элементы одинаковы, то сор­
тировка займет линейное время).
Преимущества быстрой сортировки, по сравнению
с сор­тировкой слиянием, включают в себя сортировку на
месте и более простой внутренний цикл, благодаря чему
в большинстве случаев алгоритм работает быстрее2.
Недостатками этого метода являются наихудшее время
выполнения и отсутствие стабильности3; переупорядо­
чение на месте также не работает, если данные представ­
лены не в виде массива, а в виде связного списка.

## Сложите два ломтика вместе. Приятного аппетита!
### Сортировки без сравнения

Как уже упоминалось, минимальное время выполнения
в худшем случае, которое мы можем получить для сор­
тировки сравнением, составляет O(n lg n). Чтобы улуч­
шить время выполнения, нужна дополнительная инфор­
1
Эта задача известна как задача о голландском национальном
флаге.
2
Скиена С. Алгоритмы. Руководство по разработке. — СПб.:
BHV, 2017.
3
Причина нестабильности быстрой сортировки, как правило,
состоит в том, что во время разбиения могут переставляться
элементы с одинаковым ключом.

131
Глава 8. Алгоритмы сортировки
мация (метаданные) о сортируемых данных. Иногда это
позволяет улучшить время сортировки до O(n).
В частности, даже если количество сортируемых эле­
ментов достаточно велико, может существовать огра­
ниченное количество ключевых значений, по которым
эти элементы должны быть отсортированы. На этом
принципе основаны следующие методы сортировки.
8.4.1.  Сортировка подсчетом
Предположим, что каждый из n элементов сортируемых
данных имеет ключ, который является положительным
целым числом со значением не более k. Тогда можно
создать массив длиной k и перебрать в цикле все эле­
менты, которые должны быть отсортированы, исполь­
зуя этот массив для отслеживания количества вхожде­
ний каждого ключа (выражаясь более формально, мы
строим частотную гистограмму для значений ключа).
Теперь у нас есть массив значений, соответствующих
количеству появлений каждого ключа. Затем остается
еще раз пройти по массиву и заменить каждое значение
на количество ключей с меньшими значениями. После
этого каждая ячейка массива будет содержать правиль­
ную позицию для первого элемента с этим ключом.
Наконец, остается переместить каждый элемент ис­
ходных данных в позицию, которая определяется зна­
чением, записанным в соответствующей ячейке массива
ключей, и увеличить это значение на единицу (чтобы
следующий элемент с таким ключом, если он есть, раз­
местить в следующей ячейке выходного массива).

132
Часть III. Неграфовые алгоритмы
Пример: сортировка подсчетом
Рассмотрим следующий массив, в котором цифра явля­
ется ключом для сортировки, а буква — прикрепленным
значением: [1a, 3b, 2a, 4c, 1c, 4b, 2a, 2c, 2b, 1b, 3c].
Пройдя по массиву, мы обнаружили три единицы, че­
тыре двойки, две тройки и две четверки и получили
гистограмму [3, 4, 2, 2].
Это говорит о том, что первый элемент с каждым ключом
должен появляться в следующих позициях: [0, 3, 7, 9].
Теперь снова пройдем по исходному массиву. Первый
элемент равен 1 и перейдет в ячейку 0. Второй элемент
имеет ключ 3, он пойдет в ячейку 3 и т. д. Каждый раз,
помещая элемент в выходной массив, мы увеличиваем
соответствующее значение в массиве ключей на единицу.
Например, после размещения первых семи элементов
массив ключей принял вид [2, 5, 8, 11], и мы знаем, что
следующий элемент, 2c, попадет в ячейку 5 выходного
массива.
Весь процесс требует двух циклов для входного массива
(один для заполнения массива ключей и один — для
перемещения элементов в выходной массив) и одного
цикла для массива ключей, чтобы просуммировать зна­
чения и определить конечные позиции ключей. Кроме
того, должны быть инициализированы массив ключей
(размером k) и выходной массив (размером n). То­гда
общее время выполнения, как и занимаемое место в па­
мяти, составит O(n + k). Если k мало по сравнению с n
(например, для большого количества элементов, кото­
рые ранжируются по шкале от 1 до 100), то это O(n).
Это стабильный метод сортировки.

133
Глава 8. Алгоритмы сортировки
8.4.2.  Поразрядная сортировка
Поразрядная сортировка — это более старый метод сор­
тировки1, который до сих пор остается полезным; в за­
висимости от допущений, он может быть более эффек­
тивным, чем лучшие варианты сортировки сравнением.
Его сложность составляет O(wn) для ключей с длиной
слова w; если w постоянна, это сводится к O(n). Есте­
ственно, это требует дублирования ключей; если каж­
дый сортируемый элемент имеет уникальный ключ, то
длина ключа должна быть не менее lg n2. Существует
несколько вариантов поразрядной сортировки; здесь
мы рассмотрим сортировку по младшему разряду (least
significant digit, LSD).
Рассмотрим алфавит, из которого взят ключ, и соз­
дадим по одной ячейке для каждой буквы этого алфа­
вита. Например, если ключ является десятичным чис­
лом, то у нас будет десять ячеек, помеченных цифрами
от 0 до 9. Каждый элемент списка мы поместим в ячей­
ку, соответствующую младшему разряду ключа этого
элемента. Например, элемент с ключом 378 попадает
в ячейку номер 8. Другими словами, мы сгруппиро­
вали ключи по младшему разряду, но сохранили их
относительный порядок (чтобы это была стабильная
сор­тировка).
1
Метод использовался Германом Холлеритом (Herman Hol­
lerith) для счетно-аналитических машин в 1887 году; одна из
компаний, основанных Холлеритом, в итоге стала IBM.
2
Для основания b и ключа длиной w количество различных
ключей равно bw. Если w меньше lgb n, то количество возмож­
ных ключей меньше количества сортируемых элементов.

134
Часть III. Неграфовые алгоритмы
Затем мы снова сгруппируем ключи, но теперь по вто­
рому с конца разряду; теперь элемент с ключом 378
окажется в ячейке номер 7. И так далее. После того как
будут перебраны все цифры в ключе, список отсортиро­
ван. Один из способов реализовать это — представить
каждую ячейку в виде очереди; после каждого прохода
элементы можно возвращать обратно в список.
Почему это работает? Рассмотрим два ключа на послед­
нем этапе процесса. Если их старшие разряды различ­
ны, то ключ, который должен стоять первым при сор­
тировке, попадет в предшествующую ячейку, поэтому
они будут правильно расположены друг относительно
друга. Если старшие разряды ключей одинаковы, то
они попадут в одну ячейку в том же порядке, в котором
были отсортированы для предыдущего разряда, что по
индукции также будет правильным, если эти цифры от­
личаются, и т. д. Если все цифры одинаковы, то порядок
не имеет значения (но элементы расположатся в том же
относительном порядке, в котором были представлены
в исходном списке).
Каждый элемент помещается в ячейку (за постоянное
время) один раз для каждого символа ключа, что дает
максимальное время выполнения O(wn).

Часть IV
Методы решения
задач

9
А если в лоб?
Computer Science можно рассматривать как способ най­
ти решения задач с помощью компьютеров. Затем ра­
бота программиста сводится к трем действиям: опреде­
лить, какие задачи может решить компьютер, объяснить
компьютеру, как их решать, и спрогнозировать, сколько
времени займет этот процесс.
Выбор метода решения задачи зависит от того, какие
атрибуты решения наиболее важны. У каждого алгорит­
ма есть своя стоимость выполнения, которую можно вы­
разить как сложность по времени и пространству. Слож­
ность по времени — это время выполнения алго­ритма
в зависимости от объема входных данных. Сложность
по пространству — требуемый объем памяти (опять же
относительно объема входных данных). Вычислительная
сложность алгоритма — это количество ресурсов (време­
ни и пространства), необходимых для его выполнения;
вычислительная сложность задачи — это минимальная
сложность алгоритма, который мог бы ее решить.
Однако ресурсы, необходимые для выполнения про­
граммы, — это не единственные расходы (хотя в научных
статьях, как правило, упоминают только их). Приходит­

137
Глава 9. А если в лоб?
ся также учитывать сложность написания и отладки
программы. Иногда лучше реализовать менее эффек­
тивный алгоритм, пожер­твовав некоторой скоростью
в обмен на время программиста (потому что реализация
более быстрого алгоритма займет значительно больше
времени) или точностью (потому что в более быстром
алгоритме выше вероятность программных ошибок).
Практическое применение
Однажды я проводил обзор кода (code review) джуниора.
Рецензент предложил внести некое изменение, чтобы
сделать код более эффективным.
Я согласился, что предложенный код будет более эф­
фективным, но наложил вето на изменение, потому что
из-за этого код стал бы более сложным. В том случае код
не относился к чувствительной ко времени части при­
ложения (долю секунды, которую могло бы сэкономить
изменение, никто бы не заметил), но дополнительное
усложнение повысило бы вероятность того, что в итоге
мы бы получили ошибку — либо сразу, либо в будущем,
при очередном обновлении кода.
В конце шкалы «эффективность — сложность» нахо­
дится метод решения задач в лоб, или метод грубой
силы. Он очень прост: перебрать все возможные реше­
ния и проверить каждое, пока одно из них не окажется
правильным. Этот метод годится, если задачу нужно
решить один раз, и дополнительное время, необходимое
для поиска эффективного решения, превысит эконо­
мию времени при выполнении этого решения. Конечно,
иногда мы применяем грубую силу просто потому, что
не знаем лучшего решения!

138
Часть IV. Методы решения задач
Например, если на сейфе установлен пульт из десяти
кнопок и вы знаете, что комбинация представляет собой
четырехзначное число и больше никакой информации
нет (и количество попыток не ограничено), можно най­
ти комбинацию, просто перебрав все возможные числа
от 0000 до 9999. Это может занять очень много време­
ни — в среднем 5000 попыток, — но сама процедура
очень проста. В цифровом мире это означает, что, если
на сайте не используются надежные пароли, а учетная
запись не блокируется после некоторого количества не­
правильных попыток, то с помощью известного имени
пользователя можно перебрать все возможные пароли,
пока один из них не подойдет.
Решение методом грубой силы, как правило, очень про­
сто реализовать. В то же время его очень сложно реа­
лизовать неправильно, что делает его полезным, если
размер задачи невелик, а точность крайне желательна.

10
Динамическое
программирование

## Сложите два ломтика вместе. Приятного аппетита!
### Задача недостающих полей

Предположим, у нас есть шахматная доска размером
n × n, на которой недостает нескольких полей. Как най­
ти наибольший участок доски размером k × k без недо­
стающих полей?1
Если вы раньше не сталкивались с такой задачей, по­
тратьте несколько минут на то, чтобы написать решение
и определить время выполнения вашего алгоритма.
Столкнувшись с этой задачей, я рассуждал следующим
образом. Каждое поле шахматной доски может принад­
лежать ко многим наибольшим участкам, но только
в одном из них оно может быть верхним левым углом.
Если я помечу каждое поле размером наибольшего
1
Мне задали эту задачу несколько лет назад на собеседо­
вании в известной компании по разработке программного
обеспечения; быстро предложив эффективное решение,
я вышел на следующий уровень собеседований. С тех пор
прошло достаточно времени, чтобы я мог спокойно изло­
жить ее здесь.

140
Часть IV. Методы решения задач
неповрежденного участка, верхним левым углом кото­
рого он является, то поле с наибольшей такой меткой
будет соответствовать искомому участку.
Предположим, что доска представлена в виде матри­
цы n × n, в которой каждая ячейка содержит 1, если
соответствующее поле присутствует, и 0, если оно про­
пущено. Если текущее значение ячейки равно 0, то
соответствующее поле отсутствует и не может быть
частью непрерывного участка, поэтому его не нужно
изменять. Если же значение равно 1, то мы можем за­
менить его числом, которое на единицу больше, чем
минимальное значение из трех ячеек, расположенных
ниже и справа.
Мы изменяем каждую ячейку матрицы один раз, вклю­
чая проверку, равно ли значение ячейки нулю, проверку
значений еще максимум трех ячеек и запись нового
значения ячейки. Каждая из этих операций занимает
время O(1), поэтому время, необходимое для обработки
всей шахматной доски, составляет O(n2).
Обратите внимание, что это линейное, а не квадратич­
ное время выполнения алгоритма — на шахматной до­
ске n1 полей (некоторые из них отсутствуют), поэтому
общее время, затрачиваемое алгоритмом, пропорцио­
нально количеству полей. Если более точно обозначить
размер шахматной доски как √ n  × √ n , то получим n по­
лей и общее время выполнения O(n).
1
Мы считаем, что n — это общее количество полей, и при­
держиваемся обычного соглашения о том, что n — это объем
входных данных.

141
Глава 10. Динамическое программирование

## Сложите два ломтика вместе. Приятного аппетита!
### Работа с перекрывающимися

подзадачами
Подход, использованный в этом разделе, называется
динамическим программированием. Он применяется,
когда задачу можно разделить на несколько подзадач,
решение каждой из которых будет использовано не­
сколько раз. Этот подход отличается от принципа «раз­
деляй и властвуй», когда задачу разделяют на подзадачи,
которые решаются независимо друг от друга. В задаче
с шахматной доской каждая подзадача зависела от ре­
шений трех других задач, а решения всех подзадач со­
хранялись для дальнейшего использования.
Динамическое программирование обычно выполняется
путем построения таблиц, как показано выше. Это озна­
чает решение задачи методом «снизу вверх», когда мы
начинаем с решения наименьших подзадач и продви­
гаемся вверх до тех пор, пока не придем к ответу (ал­
горитм 8). Другой метод — это мемоизация, при ко­
торой мы идем сверху вниз, решая подзадачи по мере
необходимости и кэшируя результаты для повторного
использования1.
Построение таблиц — предпочтительный вариант, ко­
гда нужно решить каждую подзадачу (в моем примере
с шахматной доской нужно было найти наибольший
1
Некоторые считают, что динамическое программирование
ограничивается построением таблиц, а мемоизация к нему
не относится. Какую бы семантику вы ни предпочли, сами
методы остаются такими, как описано здесь.

142
Часть IV. Методы решения задач
неповрежденный участок для каждого поля доски),
поскольку затраты у этого метода меньше, чем при ме­
моизации. Если некоторые подзадачи из области реше­
ния не обязательно решать, то мемоизация позволяет
решать только те подзадачи, которые действительно
необходимы.

143
Глава 10. Динамическое программирование
Ключевой момент
Там, где метод «разделяй и властвуй» подразумевает
разделение задачи на несколько независимых подзадач,
динамическое программирование подразумевает разде­
ление задачи на несколько перекрывающихся подзадач.
Решение каждой подзадачи кэшируется для последу­
ющего повторного использования.

## Сложите два ломтика вместе. Приятного аппетита!
### Динамическое

программирование
и кратчайшие пути
Рассмотрим задачу поиска кратчайшего пути: для за­
данного графа со взвешенными ребрами нужно найти
такой путь из одного узла в другой, который имеет наи­
меньшую стоимость.
Определение
Граф со взвешенными ребрами — это граф, в котором
каждое ребро имеет свой вес (стоимость). Стоимость
пути из одного узла в другой определяется суммой стои­
мости всех пройденных ребер.
Предположим, что мы нашли путь между узлами s и t,
который содержит третий узел v. Тогда путь из s в t
должен содержать кратчайший путь из s в v, поскольку
в противном случае мы могли бы заменить этот участок
более коротким путем и уменьшить длину кратчайшего
пути из s в t, что противоречит начальному условию1.
1
Это принцип оптимальности Беллмана.

144
Часть IV. Методы решения задач
Ключевой момент
Динамическое программирование (и жадные алгорит­
мы) полезно для решения задач, имеющих оптимальную
подструктуру. Это означает, что оптимальное решение
задачи может быть эффективно построено из оптималь­
ных решений ее подзадач. Если самый короткий путь
из Мэдисона в Денвер проходит через Омаху, то этот
маршрут также должен содержать самый короткий путь
из Мэдисона в Омаху и из Омахи в Денвер.
Если задача имеет и оптимальную подструктуру, и пере­
крывающиеся подзадачи, то она становится кандида­
том на решение методом динамического программи­
рования.
Задачи поиска кратчайшего пути представляют собой
яркие примеры динамического программирования, по­
скольку оптимальное свойство подструктуры интуи­
тивно понятно — очевидно, что самый быстрый способ
перехода из точки А в точку С через точку В — это также
самый быстрый способ перехода из точки А в точку В и из
точки В в точку С. В число алгоритмов, основанных на
этом принципе, входит метод Беллмана — Форда, ко­
торый находит кратчайший путь из исходной точки
в любую вершину графа (или от любой вершины графа
до конечной точки) и метод Флойда — Уоршелла — с его
помощью вычисляется кратчайший путь между каждой
парой вершин графа (алгоритм 10). В обоих случаях
идея состоит в том, чтобы начать с небольшого под­
множества узлов, близких к интересующим нас узлам,
и постепенно расширять это множество, используя уже
найденные узлы для вычисления новых расстояний.

145
Глава 10. Динамическое программирование

## Сложите два ломтика вместе. Приятного аппетита!
### Примеры практического

применения
10.4.1.  Git merge
Еще одна задача, на примере которой обычно демонстри­
руют возможности динамического программирования, —
поиск наибольшей общей подпоследовательности
(Longest Common Subsequence). Задача состоит в том,
чтобы для двух заданных строк A и B найти самую

146
Часть IV. Методы решения задач
длинную последовательность, которая встречается в обе­
их строках с сохранением последовательности символов.
Символы в строках не обязательно должны стоять под­
ряд; например, если A = {acdbef} и B = {babdef}, то {adef}
будет их общей подпоследовательностью.
При слиянии изменений в Git (merge) выполняется
поиск наибольшей общей подпоследовательности
для master и рабочей веток. Символы, присутству­ющие
в master, но отсутствующие в наибольшей общей под­
последовательности, удаляются; символы, которые
есть в рабочей ветке, но отсутствуют в этой подпосле­
довательности, добавляются в master.
10.4.2.  LATEX
Систему подготовки документов LATEX  часто исполь­
зуют для создания технических документов. Одна из
задач системы набора текста — выравнивание текста
одновременно по правому и левому краю; для этого
интервалы между словами и символами растягиваются
или сжимаются таким образом, чтобы все строки имели
одинаковую длину. Другой способ выровнять текст со­
стоит в переносе последнего слова, так что часть слова
оказывается на следу­ющей строке. LATEX 1 пытает­
ся найти оптимальные точки разрыва строки, чтобы
текст выглядел красиво. Если это сделать не удастся,
то несколько строк подряд будут заканчиваться пере­
носом слова или же расстояние между словами в разных
1
С технической точки зрения практически всю работу выпол­
няет система ввода текста TEX; LATEX построена на основе TEX.
Здесь я использую LATEX из соображений простоты.

147
Глава 10. Динамическое программирование
строках будет различаться. В LATEX  существует набор
правил для оценки «неудачности» выравнивания. Про­
грамма стремится найти «наименее плохой» вариант.
Если в абзаце есть n возможных точек разрыва строки,
то существует 2n возможных вариантов разбиения тек­
ста. «Не­удачность» выбора для каждой точки разрыва
зависит от того, какие точки разрыва были выбраны до
нее. Следовательно, у нас снова есть перекрывающиеся
подзадачи. Использование методов динамического про­
граммирования сокращает время выполнения до O(n2),
которое может быть улучшено с помощью дополнитель­
ных методов1.
1
Подробнее см. статью: Donald E. Knuth, Michael F. Plass Breaking
paragraphs into lines // Software: Practice and Experience.
Vol. 11. Issue 11, 1981.

11
Жадные
алгоритмы
Жадный подход к решению задачи состоит в том, чтобы
каждый раз, когда нужно принять решение, выбирать
тот вариант, который является локально оптимальным.
Другими словами, выбирается тот вариант, который
дает лучшее решение текущей подзадачи, даже если это
не будет лучшим решением всей задачи.
В задаче о коммивояжере из раздела 1.6 это означало,
что нужно всегда ехать в ближайший город, который
еще не посещался (то есть выбрать ребро с наимень­
шим весом, которое приведет к еще не посещавшей­
ся вершине). Такой метод работает быстро (нужно
только перебрать все ребра, выходящие из текущей
вершины, и выбрать то, которое имеет наименьший
вес), но не гарантирует, что будет найдено наилучшее
решение всей задачи.
Допустим, мы ходим по некоторому участку земли
и хотим найти самую высокую точку. Жадный алго­
ритм предложил бы постоянно идти в гору, пока это
возможно. Когда все допустимые пути будут направле­
ны вниз, это будет означать, что мы нашли локальный

149
Глава 11. Жадные алгоритмы
максимум — любая точка, в которую мы сможем перей­
ти непосредственно из текущего положения, окажется
ниже того места, в котором мы находимся в данный
момент. Это не означает, что мы действительно нашли
самое высокое доступное место, — мы достигли лишь
самой высокой точки в локальной области (места, где
вы сейчас находитесь, и соседних мест, с которыми вы
его сравниваете).
Существуют задачи, для которых жадные алгоритмы
дают оптимальное решение; одним из примеров явля­
ется алгоритм поиска кратчайших путей Дейкстры.
Как и в случае динамического программирования,
жадные алгоритмы лучше всего работают в тех слу­
чаях, когда задача имеет оптимальную подструктуру.
Разница между этими подходами заключается в том,
что динамическое программирование позволяет га­
рантированно найти решение задачи для оптималь­
ной подструктуры, поскольку оно учитывает все воз­
можные подзадачи и объединяет их для достижения
оптимального решения, тогда как жадный алгоритм
просто выбирает ту подзадачу, которая лучше всего
выглядит в данный момент.
Рассмотрим такую задачу: добраться домой с работы
в час пик. Жадный подход заключается в том, чтобы
выбрать любой маршрут домой с наименьшей загру­
женностью возле работы. В этом случае вы будете
двигаться быстрее, но рискуете столкнуться с боль­
шим трафиком ближе к дому. Алгоритм динамиче­
ского программирования будет учитывать весь тра­
фик и выберет маршрут с наименьшими затратами

150
Часть IV. Методы решения задач
в среднем, даже если начальный участок этого пути
будет сильнее загружен.
Жадные алгоритмы, как правило, являются быстры­
ми. Поэтому их предпочтительно выбирать, когда они
гарантированно найдут либо оптимальное решение
задачи, либо хотя бы одно достаточно хорошее ре­
шение.

Часть V
Теория сложности
вычислений

12
Что такое теория
сложности
В главе 1 вы узнали, как оценить время выполнения
алгоритма, чтобы можно было выбрать наилучший ал­
горитм для решения данной задачи (или определить,
существует ли достаточно хороший алгоритм для ее
решения). В той главе не имело особого значения, какой
язык программирования использовать. Там описаны
алгоритмы на псевдокоде, однако использование C#,
Java или Python дало бы такую же асимптотическую
скорость выполнения.
Это не означает, что программы, написанные на любом
языке, всегда будут одинаково эффективны, однако
все они (теоретически) работают на одном и том же
оборудовании и используют одни и те же структуры
данных, поэтому мы ожидаем увидеть одинаковое уве­
личение времени выполнения по мере роста объема
задачи. Основное предположение состоит в том, что
существует некий теоретический компьютер, во всем
подобный тем, что применяются в настоящее время, за
исключением бесконечного объема памяти (что, увы,
редко встречается в реальных компьютерах).

153
Глава 12. Что такое теория сложности
Одно из применений теории сложности состоит в опре­
делении того, что может и чего не может сделать ком­
пьютер. Иногда удается значительно сократить время,
необходимое для решения задачи, либо используя бо­
лее эффективный алгоритм, либо вводя дополнитель­
ные ресурсы (например, процессоры). Более сложные
по своей природе задачи невозможно решить без зна­
чительных ресурсов даже при наличии оптимального
алгоритма (NP-полные задачи считаются сложными).
Иногда задача действительно не решается на опреде­
ленном типе компьютеров, даже при наличии неогра­
ниченного количества ресурсов.
При смене вычислительной модели задача, которая
прежде была очень сложной, может стать тривиаль­
ной, а тривиальная задача, наоборот, — неразрешимой.
Например, существуют квантовые алгоритмы (алгорит­
мы, работающие на квантовом компьютере), которые
выполняются экспоненциально быстрее, чем самые из­
вестные классические алгоритмы (те, что выполняются
на компьютерах, используемых сегодня повсеместно, не
только в исследовательских лабораториях), для одной
и той же задачи.
Дополнительная информация
Квантовый компьютер — это сравнительно новая модель
вычислений, основанная на квантовой механике. Там,
где в классических компьютерах используются биты,
которые могут быть равны 0 или 1, в квантовых ком­
пьютерах применяются кубиты. Последние существуют

154
Часть V. Теория сложности вычислений
в суперпозиции состояний: каждый бит равен 0 и 1 одно­
временно. Если байт выражает одно значение от 0 до 255,
то квантовый байт выражает все 256 значений одно­
временно.
Если прочитать кубиты, то они свернутся в одно состоя­
ние. Другими словами, вместо того, чтобы находиться во
всех возможных состояниях сразу, они имеют ровно одно
значение. При этом нет гарантии, что это значение будет
правильным; алгоритм просто манипулирует кубитами
так, что при их измерении они с большой вероятностью
придут в правильное состояние.
И наоборот, существуют модели вычислений, неспо­
собные решить задачи, которые тривиально решаются
с помощью современных компьютеров. Эти модели
имеют такие ограничения, как способ доступа к памя­
ти. Продемонстрировав, что конкретная задача может
быть решена с помощью данной модели, мы устанав­
ливаем верхнюю границу вычислительной мощности,
необходимой для ее решения, а также получаем до­
ступ к инструментам, созданным для работы с этой
моделью.

13
Языки и конечные
автоматы

## Сложите два ломтика вместе. Приятного аппетита!
### Формальные языки

Любой человеческий язык, например английский, пред­
ставляет собой набор букв (в письменной речи) или
звуков (в устной речи), а также правил, описывающих,
как комбинировать эти буквы или звуки в слова и пред­
ложения. Точно так же в математике и Computer Science
язык — это набор символов и правила их комбинации.
Языки классифицируются в зависимости от того, на­
сколько мощным должен быть компьютер для их рас­
познавания. Под распознаванием в данном случае по­
нимается способность компьютера точно определить
по заданной строке, принадлежит ли она некоторому
языку. Такие свойства, как тип доступной памяти, опре­
деляют мощность компьютера и, следовательно, слож­
ность языков, которые он способен распознавать.
Формально язык L с алфавитом Σ — это (возможно,
бесконечное) множество всех допустимых слов, кото­
рые могут быть составлены из символов этого алфави­
та. Например, мы можем определить алфавит Σ = {a}
для языка L = a2n, другими словами, все строки четной

156
Часть V. Теория сложности вычислений
длины, состоящие только из буквы a. В этот язык будут
входить строки λ (пустая строка — ноль, а ноль — это
четное число!), aa, aaaa и т. д. В языке может быть ко­
нечное количество слов, бесконечное количество слов
или даже не быть слов вообще (L = {∅}1).
Класс языков может определяться по типу машины, кото­
рая способна его распознать, по типу грамматики, генери­
рующей этот язык, а также в терминах тео­рии множеств.
Рассмотрим все способы для каждого класса языков.

## Сложите два ломтика вместе. Приятного аппетита!
### Регулярные языки

Регулярные языки — это такие языки, которые могут
быть поняты конечными автоматами. Конечный авто­
мат (Finite State Machine), — это машина, которая имеет
одно начальное состояние, одно или несколько допусти­
мых состояний и переходы между этими состояниями.
Чтобы определить, есть ли в языке данная строка, вы
начинаете со стартового состояния и следуете переходу
для каждой буквы этой строки. Если состояние, достиг­
нутое после последней буквы строки, является допусти­
мым состоянием, то строка принадлежит этому языку.
В конечном автомате, представленном на рис. 13.1, ра­
бота начинается с состояния S, которое также явля­
ется допустимым (поскольку нам еще не встретилось
никаких букв, а ноль — четное число). Встретив одну
букву a, мы переходим в состояние q1, а встретив вторую
букву a — возвращаемся к S. И так далее: продолжаем
переходить по ребрам, пока не прочитаем всю строку.
1
Это пустое множество — не то же самое, что множество, со­
держащее только пустую строку ({λ}).

157
Глава 13. Языки и конечные автоматы
Рис. 13.1. Конечный автомат, который принимает любую
строку четной длины, составленную из алфавита Σ = {a}.
Двойной круг указывает на то, что S — допустимое состояние
Существует два вида конечных автоматов: детермини­
рованные и недетерминированные. В детерминирован­
ных конечных автоматах, ДКА (Deterministic Finite
Automata), если алфавит содержит более одной буквы
(как в большинстве языков), каждое состояние авто­
мата должно содержать ребро для каждой буквы алфа­
вита. На рис. 13.2 показан детерминированный конеч­
ный автомат для языка, который построен на алфавите
Σ = {a, b} и состоит из любого количества букв a, после
которых стоит ровно одна буква b.
Рис. 13.2. Детерминированный конечный автомат,
принимающий строки, состоящие из любого (включая
нулевое) числа букв a, после которых стоит одна буква b
Состояние q2 на рис. 13.2 — то, что называют мертвым
состоя­нием: это состояние не является допустимым
и, поскольку, какую бы букву мы ни добавили, мы все
равно вернемся в эту же точку, если мы сюда попали, то

158
Часть V. Теория сложности вычислений
уже не сможем достичь какого-либо допустимого состо­
яния. В данном случае строка, которая содержит любые
символы после буквы b, отсутствует в данном языке.
Обратите внимание, что, поскольку автомат является
детерминированным, переход на каждом шаге одно­
значно определяется вводимым символом и текущим
состоянием.
Альтернативой мертвому состоянию является исполь­
зование недетерминированного конечного автомата,
НКА (Nondeterministic Finite Automaton). Это конеч­
ный автомат, в котором у каждого состояния для любой
буквы может быть ноль, один или несколько переходов.
Поскольку в недетерминированном конечном автомате
каждое состояние не должно иметь переход для каждой
буквы, мертвое состояние не является обязательным.
Если для следующей буквы в строке нет перехода, то
данная строка отсутствует в этом языке.
С точки зрения описываемых языков автоматы НКА
эквивалентны ДКА. Каждый ДКА также является НКА
(ДКА должен соблюдать ограничение по одному пере­
ходу на одну букву, в отличие от НКА), а любой НКА
может быть преобразован в соответствующий ДКА.
На рис. 13.3 представлен НКА, который описывает
тот же язык, что и ДКА на рис. 13.2. Как правило, пред­
почтительно использовать НКА вместо ДКА, поскольку
НКА часто требуют гораздо меньше переходов.
Предположим, мы хотим распознать более сложный
язык: он состоит из одной или нескольких букв a, после
которых стоит ноль или более букв c, ноль или более
букв b, а затем ровно одна буква c. Мы могли бы рас­
познать этот язык с помощью недетерминированного

159
Глава 13. Языки и конечные автоматы
конечного автомата на рис. 13.4. Обра­тите внимание:
в этом автомате используется лямбда-переход1, чтобы
гарантировать, что c-цикл не будет повторяться после
b-цикла.
Рис. 13.3. Недетерминированный конечный автомат, который
принимает строки, состоящие из любого (включая нулевое)
количества букв a, после которых стоит ровно одна буква b
Рис. 13.4. НКА для языка a + c * b * c
Какие типы языков не распознаются конечными ав­
томатами? Обратите внимание, что у этих конечных
авто­матов нет отдельной памяти, что ограничивает дли­
ну сравнений числом состояний автомата. Например,
мы хотим построить автомат, который бы распознавал
язык, состоящий из любого количества парных скобок,
причем после левой скобки все­гда следует соответству­
ющая правая скобка. Такой автомат мог бы выглядеть
так, как показано на рис. 13.5.
1
Лямбда-переход позволяет переходить из одного состояния
в другое, не считывая входные данные.

160
Часть V. Теория сложности вычислений
Рис. 13.5. Недетерминированный конечный автомат,
который принимает наборы парных скобок и поддерживает
до четырех одновременно открытых пар
Такой автомат будет делать именно то, что мы хотим,
если число одновременно открытых пар скобок не пре­
высит четырех (четыре левые скобки без соответству­
ющих правых скобок). Если этот предел будет превы­
шен, автомат не сможет распознать строку. Мы можем
увеличить автомат, добавив еще несколько состояний,
но число состояний всегда будет конечным. В случае
n + 1 состояний можно отслеживать до n переходов, то
есть конечный автомат не сможет распо­знать любую
строку языка, в котором допускаются сравнения лю­
бой длины. Позже вы узнаете о методе, позволя­ющем
показать, что язык, который требует такого сравнения,
не может быть распознан никаким конечным автоматом,
следовательно, такой язык не является регулярным.
13.2.1.  Регулярные грамматики
Грамматика — это набор правил для генерации языка.
Там, где автоматы для языка позволяют проверить, при­
надлежит ли данная строка языку, грамматика позволяет
генерировать любую строку, которая является частью
языка. Грамматика состоит из переменных (обозначае­
мых заглавными буквами), терминалов (которые явля­

161
Глава 13. Языки и конечные автоматы
ются символами алфавита) и переходов, преобразующих
переменные в символы (которые могут быть перемен­
ными или терминалами). Например, грамматика, по­
казанная на рис. 13.6, генерирует язык, представленный
на рис. 13.5 и состоящий из наборов скобок, в которых
одновременно может быть открыто до четырех пар.
Рис. 13.6. Грамматика, генерирующая язык парных скобок,
в котором не допускается более четырех открытых пар
одновременно
Мы будем использовать грамматику, в которой по­
строение строки начинается с S и затем на каждом шаге
переменная заменяется до тех пор, пока получившаяся
строка полностью не будет состоять из терминалов.
Например: S → (A → ((B → (() A → (() (B → (() () A →
→ (() ()) S → (() ()).
Такая грамматика называется праволинейной, пото­
му что при каждом преобразовании после переменной
(если она есть) стоит терминальный символ. Каждое
порождающее правило в праволинейной регулярной
грамматике имеет одну из трех форм: переменная при­
соединяется к терминалу, переменная ставится после

162
Часть V. Теория сложности вычислений
терминала или λ. Леволинейная регулярная грамма­
тика идентична праволинейной, только переменная
присоединяется к терминалу, терминал ставится после
переменной или λ. Обратите внимание, что эти два вида
грамматик не смешиваются; для представления любого
регулярного языка можно использовать только леволи­
нейную регулярную или праволинейную регулярную
грамматику, но не обе одновременно.
Подводные камни на практике
Казалось бы, еще один способ работы с регулярны­
ми языками — это регулярные выражения (regex).
Действительно, с точки зрения Computer Science это
так. Регулярные выражения описывают регулярные
языки и обладают теми же возможностями описания,
что и регулярные грамматики.
В программировании регулярные выражения расширены
и поддерживаются многими языками, которые на самом
деле не являются регулярными, поскольку включают
в себя запоминание введенных ранее данных (обратные
ссылки). Благодаря этому regex в программировании го­
раздо мощнее регулярных выражений в Computer Science.
Зато теоретические регулярные выражения по крайней
мере не подвержены катастрофическим возвратам.
13.2.2.  Свойства замыкания
Все слова языка образуют множество1. Множества могут
быть замкнуты относительно определенных операций.
1
Напомню, что множество — неупорядоченная коллекция
элементов.

163
Глава 13. Языки и конечные автоматы
Это означает, что, если применить эту операцию к членам
множества, мы получим другой элемент данного множе­
ства. Например, целые числа замкнуты относительно сло­
жения, вычитания и умножения, потому что сложение,
вычитание и умножение двух целых чисел дает еще одно
целое число. Целые числа не замкнуты относительно
деления, так как результат деления одного целого числа
на другое не обязательно будет целым числом.
Аналогично класс языков является замкнутым отно­
сительно операции °, если для любых языков из этого
класса результатом применения операции является
язык этого же класса. Регулярные языки замкнуты от­
носительно таких операций, как:
z
z объединение A ∪ B: каждое слово, которое входит
хотя бы в один из языков A или B;
z
z пересечение A ∩ B: каждое слово, которое входит
и в A, и в B;
z
z конкатенация A с B: множество слов, каждое из ко­
торых представляет собой любую строку из A, после
которой идет любая строка из B;
z
z дополнение A–: все слова, составленные из того же
алфа­вита Σ, что и A, но не принадлежащие A;
z
z разность A – B: все слова, которые есть в A, но кото­
рых нет в B;
z
z звезда Клини A∗: ноль копий A и более;
z
z плюс Клини А+: одна копия А и более.
Следующие свойства либо являются очевидными, либо
логически следуют из определения регулярных языков
в терминах теории множеств:

164
Часть V. Теория сложности вычислений
z
z пустой язык L = {∅} является регулярным;
z
z язык, содержащий только пустую строку L = λ, явля­
ется регулярным;
z
z для каждой буквы в алфавите Σ язык, содержащий
только эту букву, является регулярным;
z
z если A и B являются регулярными языками, то A ∪ B,
конкатенация A и B, а также A∗ являются регуляр­
ными.
Пример
Конкатенация. Если A и B являются регулярными язы­
ками, то добавление перехода λ из каждого допустимого
состояния НКА для A в начальное состояние НКА для B1
дает НКА для конкатенации A с B.
Дополнение. Если заменить любое допустимое состояние
ДКА для языка L на недопустимое состояние (и наобо­
рот), то получим ДКА для дополнения L.
Пересечение. Пересечение множеств A и B (элементы,
присутствующие в обоих множествах) — это те же са­
мые элементы, которых нет в множестве элементов,
отсутствующих в A, или элементов, отсутствующих в B.
Другими словами, это A ∪ B. Таким образом, зная, что
регулярные языки замкнуты относительно объединения,
из дополнения следует, что они также замкнуты относи­
тельно пересечения.
Ни один язык с алфавитом Σ, который не может быть
построен по этим правилам, не является регулярным.
Чтобы доказать, что регулярный язык замкнут относи­
тельно определенной операции, нужно либо показать,

165
Глава 13. Языки и конечные автоматы
что можно создать конечный автомат (или регулярное
выражение), представляющий операцию замыкания,
либо показать, что эта операция является объединением
уже проверенных операций замыкания.
13.2.3.  Лемма о накачке
Чтобы показать, что язык является регулярным, я ис­
пользую либо конечные автоматы, либо регулярную
грамматику, которая описывает этот язык. Как показать,
что язык не является регулярным? Неспособность най­
ти подходящий автомат или грамматику не является
доказательством того, что, возможно, она существует,
просто я ее не нашел.
Вместо того чтобы доказывать, что язык не является
регулярным, мы используем то, что называется леммой
о накачке. Она не доказывает, что язык является регуляр­
ным, а лишь показывает, что это не так. Это способ до­
казательства от противного — мы предполагаем, что язык
является регулярным, и показываем, что любой автомат,
который допустим для этого языка, также будет считать
допустимыми строки, которых нет в данном языке.
Рассмотрим язык L = {anbn} (то есть любое количество
букв a, после которого следует такое же количество
букв b). Предположим, что этот язык — регулярный;
тогда существует конечный автомат, для которого этот
язык является допустимым. Данный автомат имеет
конечное число состояний, обозначим его k. Далее,
если этот автомат считает допустимой строку длиной k
1
Следовательно, эти состояния в A больше не являются до­
пустимыми.

166
Часть V. Теория сложности вычислений
и более символов, то одно и то же состояние должно
посещаться более одного раза (в автомате есть цикл).
Рассмотрим строку akbk, которая заведомо есть в языке.
Поскольку для нашего автомата этот язык допустимый,
то и строка akbk является допустимой для этого автома­
та. Однако, поскольку число букв a в строке совпадает
с количеством состояний, в автомате должен существо­
вать цикл размером j1, который необходимо выполнить,
чтобы распознать эту строку. При чтении букв a мы про­
ходим этот цикл еще один раз, после чего попадаем в до­
пустимое состояние для строки ak + jbk, которой в языке
заведомо нет. Это противоречит предположению о том,
что для данного языка существует конечный автомат,
и показывает, что этот язык не регулярный.

## Сложите два ломтика вместе. Приятного аппетита!
### Контекстно свободные языки

Контекстно свободные языки — это надмножество регу­
лярных языков: любой регулярный язык также являет­
ся контекстно свободным языком. Оба типа языков вхо­
дят в состав иерархии грамматик Хомского (рис. 13.7),
в которой каждая грамматика является собственным
надмножеством менее мощных грамматик иерархии.
Подобно регулярным языкам, контекстно свободные
языки могут быть описаны в терминах автоматов, кото­
рые могут их распознавать, грамматик, которые могут их
создавать, и свойств замыкания множества. Контекст­но
свободные языки более мощные, чем регулярные языки,
поскольку в них допускается использование памяти,
1
| j | > 0.

167
Глава 13. Языки и конечные автоматы
в частности стека (сколь угодно большого размера). Ин­
туитивно понятно, что контекстно свободными языками
являются те, в которых нужно помнить не более одного
элемента за раз, — так (как вскоре будет доказано), язык
anbn будет контекстно свободным, а anbncn — нет.
Рис. 13.7. Иерархия Хомского. Регулярные языки являются
собственным подмножеством контекстно свободных языков,
которые, в свою очередь, являются собственным подмноже­
ством контекстно зависимых языков, а те — собственным
подмножеством рекурсивно перечислимых языков
13.3.1.  Магазинные автоматы
Магазинные (стековые) автоматы (МП-автоматы)
(PushDown Auto­mata) очень похожи на конечные авто­
маты, с двумя исключениями. Чтобы определить, какой
переход выполнить, такие автоматы, кроме чтения оче­
редного элемента входных данных, могут использовать
верхний элемент стека. Автоматы также могут управ­
лять стеком в процессе перехода.

168
Часть V. Теория сложности вычислений
Подобно конечным автоматам, магазинные состоят из
конечного множества состояний (одно или несколь­
ко из которых могут быть допустимыми) и переходов
между ними. Однако, кроме чтения буквы из входных
данных, в процессе этих переходов автомат может из­
влекать переменную из стека и помещать одну или не­
сколько переменных в стек. В дополнение к алфавиту
терминалов, здесь есть множество символов стека (в ко­
торое иногда входит специальный символ, обычно Z,
обозначающий дно стека).
Магазинный автомат может проверить строку на до­
пустимость двумя способами. Первый способ — дойти
до заключительного состоя­ния, как в случае конечных
автоматов: МП-автомат считает строку допустимой,
если после чтения строки автомат находится в допу­
стимом состоянии. Кроме того, МП-автомат также счи­
тает строку допустимой в случае пустого стека. Одни
и те же языки можно выразить, используя любой метод
доказательства допустимости. Но, как правило, удобно
предположить, что МП-автомат должен находиться в до­
пустимом состоянии, а также иметь пустой стек; именно
этому соглашению мы и будем следовать.
Рассмотрим автомат, показанный на рис. 13.8.
В первом состоянии S мы можем прочитать любое количе­
ство букв a (включая нулевое). Для каждой прочитанной
буквы a мы ничего не извлекаем из стека, но помещаем
туда A. Закончив чтение букв a, мы выполняем λ-переход
(при котором ничего не читаем, не помещаем в стек и не
извлекаем оттуда) в состояние q1. В состоянии q1 мы счи­
тываем столько букв b, сколько это возможно, с учетом

169
Глава 13. Языки и конечные автоматы
того, что при каждом чтении буквы b мы извлекаем
из стека A. Закончив чтение входных данных, мы вы­
полняем последний λ-переход в допустимое состояние,
извлекая в процессе перехода символ дна стека.
Рис. 13.8. Недетерминированный магазинный автомат,
для которого является допустимым язык L = {anbn}.
Предполагается, что в начале стек содержит Z
Как и в случае конечных автоматов, МП-автоматы мо­
гут быть детерминированными или недетерминирован­
ными. МП-автомат является недетерминированным,
если для данной ситуации (текущего состояния, сле­
дующего считываемого символа и переменной вверху
стека) существует несколько возможных переходов.
Детерминированный магазинный автомат имеет не бо­
лее одного возможного перехода из каждого состояния,
после которого можно читать следующий символ из
входных данных и верхнего символа стека.
В отличие от конечных автоматов детерминированные
и недетерминированные магазинные автоматы не яв­
ляются взаимозаменяемыми. Недетерминированные
МП-автоматы могут реализовать любой контекстно
свободный язык, в то время как детерминированные
МП-автоматы реализуют собственное подмножество
детерминированных контекстно свободных языков.

170
Часть V. Теория сложности вычислений
13.3.2.  Контекстно свободная грамматика
Контекстно свободная грамматика, которая генерирует
контекстно свободный язык, — это грамматика, левая
часть которой всегда представляет собой одну перемен­
ную, а правая часть может быть любым числом пере­
менных и терминалов. Это надмножество регулярных
грамматик, для которых левая часть также должна пред­
ставлять собой единственную переменную, но правая
часть всегда является только одним терминалом, после
которого следует ноль или одна переменная (или перед
ним стоит леволинейная регулярная грамматика). Ин­
туитивно понятно, что контекстно свободными грам­
матиками являются такие, в которых (поскольку ле­
вая часть в правиле контекстно свободной грамматики
всегда является единственной переменной) переменная
всегда может быть преобразована в любую из возмож­
ных замен, независимо от чего-либо (от контекста), что
может стоять до или после нее (рис. 13.9).
Рис. 13.9. Контекстно свободная грамматика,
которая генерирует язык anbn
13.3.3.  Лемма о накачке
Как и в случае с регулярными языками, можно доказать,
что язык не является контекстно свободным. Для этого
нужно выбрать строку, принадлежащую языку, и по­
казать, что любой магазинный автомат, который гене­
рирует эту строку, также должен генерировать строки,

171
Глава 13. Языки и конечные автоматы
отсутствующие в данном языке. Лемма о накачке для
контекстно свободных языков гласит, что если язык L
контекстно свободный, то любая строка s из L, имеющая
длину p или более символов, может быть записана как
s = uvwxy, так что выполняются следу­ющие условия:
z
z uvnwxny принадлежит к языку L для всех n ≥ 0.
Это условие говорит о том, что, если v и x повторя­
ются одинаковое число раз (включая ноль), мы все
равно получим строку, которая принадлежит языку.
Чтобы отследить, сколько раз мы выполняем первый
цикл, и повторить то же количество итераций во
втором цикле, можно использовать стек;
z
z |vwx| ≤ р.
Отсюда следует, что количество символов в цикле,
включая неповторяющуюся часть (x), не больше p;
z
z |vx| ≥ 1.
Данное условие показывает, что повторяющаяся
часть цикла содержит хотя бы один символ.
Предположим, что язык L является контекстно свобод­
ным; тогда существует автомат с p состояниями, для
которого этот язык будет допустимым. Если строка
языка имеет длину не менее p, то путь, который про­
ходит строка, должен содержать цикл длиной не менее
единицы. Если выполнить этот цикл еще один раз или
не выполнять его вообще, то мы должны закончить
в том же конечном состоянии. Следовательно, есть
другая строка, которая также должна принадлежать
этому языку. Если условие не соблюдается, то это про­
тиворечит нашему первоначальному предположению

172
Часть V. Теория сложности вычислений
о существовании магазинного автомата, для которого
L — допустимый язык и L не является контекстно сво­
бодным языком.
Хитрость использования леммы о накачке для кон­
текстно свободных языков состоит в том, что обычно
существует несколько способов разбить строку таким
образом, чтобы она соответствовала приведенным выше
правилам. Мы должны показать, что любой способ раз­
биения строки все равно выбрасывает нас за пределы
языка. Таким образом, главным условием эффектив­
ного использования леммы о накачке является выбор
хороших строк, у которых не очень много вариантов
разбиения.
Рассмотрим язык L = {anbncn} и выберем строку s = aPbPcP.
Если строка целиком состоит из букв a, то в результате
накачки мы получим строку, в которой букв a больше,
чем b и c, поэтому строка не относится к данному язы­
ку. Это верно и для случая, когда строка полностью
состоит из букв b или c. Если же начальная строка со­
держит два символа, то результат будет содержать еще
несколько этих символов, после которых будет стоять
третий (или меньше, если использовать обратную на­
качку, то есть вообще не выполнять цикл). Исходная
строка не может содержать все три символа, поскольку
ее длина не может быть больше p, а между последней a
и первой c должно стоять p букв b.
Таким образом, любой способ, которым теоретически
можно разбить строку, позволяет превратить ее во что-
то, чего нет в языке. Следовательно, такой язык не яв­
ляется контекстно свободным.

173
Глава 13. Языки и конечные автоматы

## Сложите два ломтика вместе. Приятного аппетита!
### Контекстно зависимые языки

Контекстно зависимые языки — это следующий уровень
в иерархии Хомского, и они включают в себя контекст­
но свободные языки. Если регулярные языки реализу­
ются конечными автоматами, а контекстно свободные
языки — магазинными автоматами, то контекстно за­
висимые языки реализуются линейно ограниченными
авто­матами (Linear Bounded Automata). Такой ав­
томат — это недетерминированная машина Тьюринга
(cм. главу 14), в которой длина ленты ограничена и за­
висит от длины входных данных1.
Контекстно зависимые языки генерируются неукора­
чивающими грамматиками — это грамматики, которые
не содержат каких-либо правил, в которых левая часть
длиннее правой. Другими словами, при использовании
такой грамматики длина перезаписываемой строки ни­
когда не уменьшается.
L = {anbncn, n ≥ 1} является контекстно зависимым язы­
ком, поскольку его можно сгенерировать с помощью
следующей грамматики (рис. 13.10).
Рис. 13.10. Грамматика, которая генерирует
язык anbncn, n ≥ 1
1
Формально длина ленты является линейной функцией дли­
ны входных данных.

174
Часть V. Теория сложности вычислений

## Сложите два ломтика вместе. Приятного аппетита!
### Рекурсивные и рекурсивно

перечислимые языки
Рекурсивные языки также реализуются машинами
Тьюринга, но они снимают ограничение на длину ис­
пользуемой ленты. Если существует машина Тьюрин­
га, которая в итоге прекращает работу на любом за­
данном наборе входных данных и правильно признает
допустимыми или отклоняет строки некоторого языка,
то этот язык является рекурсивным.
Рекурсивно перечислимые языки — это те языки, для
которых машина Тьюринга может перечислить все до­
пустимые строки. Другими словами, мы снимаем тре­
бование, чтобы машина Тьюринга прекращала работу,
если строка не относится к данному языку. Если язык,
комплементарный рекурсивно перечислимому языку,
также является рекурсивно перечислимым, то такой
язык является рекурсивным.

14
Машины Тьюринга

## Сложите два ломтика вместе. Приятного аппетита!
### Чисто теоретический

компьютер
Машина Тьюринга — это абстрактная машина, способ­
ная моделировать любой алгоритм. Возможно, другие мо­
дели вычислений могут работать быстрее, использовать
меньше памяти, их легче программировать, но если маши­
на Тьюринга не способна решить какую-то задачу, значит,
никакая другая машина также не способна это сделать
(насколько мы знаем, это тезис Черча — Тьюринга).
Предупреждение
Говоря о компьютере без каких-либо уточнений, я имею
в виду классический (не квантовый) компьютер.
Машина Тьюринга — это конечный автомат, который ра­
ботает с лентой памяти бесконечной длины, разделенной
на отдельные ячейки. У машины есть головка, которая
расположена над определенной ячейкой; при запуске ал­
горитма машина считывает значение этой ячейки. Затем
она может выполнить запись в эту ячейку, переместить

176
Часть V. Теория сложности вычислений
головку влево или вправо и перейти в новое состояние.
Другой способ представить машину Тьюринга — как
магазинный автомат с двумя стеками, в котором один
стек представляет часть ленты, расположенную слева от
головки, а второй — остальную часть ленты.
Установка различных ограничений на машину Тьюрин­
га может сделать ее эквивалентной другим моделям
вычислений. Например, если машина осуществляет
только чтение и может перемещать головку только
вправо, то она эквивалентна НКА. И наоборот, различ­
ные ослаб­ления ограничений на машины Тьюринга —
сделать их недетерминированными, добавляя допол­
нительные ленты и т. д., — не расширяют класс задач,
которые может решить машина (хотя это влияет на
число операций, необходимых для решения этих задач).
Универсальная машина Тьюринга, способная моде­
лировать другие машины Тьюринга, эквивалентна по
мощности (то есть по задачам, которые она способна
решать) реальному компьютеру (при условии, что у ре­
ального компьютера бесконечная память).

## Сложите два ломтика вместе. Приятного аппетита!
### Построение машины Тьюринга

Машину Тьюринга можно представить так же, как ко­
нечные автоматы: в виде последовательности состоя­
ний и переходов между этими состояниями (рис. 14.1).
Каждый переход включает в себя считываемый символ
(если он есть), записываемый символ (если есть) и то,
должна ли головка машины передвигаться влево, вправо
или остаться в той же ячейке ленты. Строка принадле­
жит языку, который является допустимым для машины

177
Глава 14. Машины Тьюринга
Тьюринга, если обработка ленты, содержащей эту строку,
приведет к остановке машины в допустимом состоянии.
Строка не будет допустимой, если не существует кор­
ректного перехода, который можно было бы выполнить.
Рис. 14.1. Машина Тьюринга для anbn. Обратите внимание,
что при последнем переходе читается пустая ячейка. Машина
находит буквы a и соответствующие буквы b, повторяя так
до тех пор, пока в строке не закончатся символы

## Сложите два ломтика вместе. Приятного аппетита!
### Полнота по Тьюрингу

Система правил, такая как язык программирования, на­
зывается Тьюринг-полной, если ее можно использовать
для моделирования любой машины Тьюринга. Посколь­
ку машина Тьюринга способна решить любую задачу,
которая в принципе может быть решена компьютером,
это означает, что Тьюринг-полный язык также способен

178
Часть V. Теория сложности вычислений
решить любую задачу, которая может быть решена ком­
пьютером с использованием любого языка. Обратите
внимание, что здесь ничего не говорится о том, сколько
времени потребуется для решения задачи, а лишь то, что
машина в итоге придет к решению задачи.
Процедурным языком является Тьюринг-полный язык,
если в нем есть условное ветвление и он способен обраба­
тывать сколь угодно большой объем памяти. Это означа­
ет, что (без учета аппаратных ограничений) большинство
языков программирования являются Тьюринг-полными.

## Сложите два ломтика вместе. Приятного аппетита!
### Проблема остановки

Если машина Тьюринга способна решить любую задачу,
которая в принципе может быть решена компьютером,
это означает, что существуют задачи, которые не может
решить ни один компьютер.
Одной из таких является проблема остановки: если даны
описание произвольной программы и входные данные,
как определить, закончит ли когда-нибудь работу эта про­
грамма? Задача считается неразрешимой — не существу­
ет машины Тьюринга, которая могла бы ответить на этот
вопрос для всех возможных входных данных. Машина
для языка L все­гда останавливается на любой строке этого
языка, но может работать вечно, если строка не принад­
лежит данному языку и при этом язык не рекурсивный.
Как и в случае NP-полноты, можно продемонстрировать,
что задача неразрешима, показав, что ее решение также
позволило бы решить еще одну задачу, относительно
которой уже было доказано, что она неразрешимая.

Часть VI
Доказательства

15
Приемлемые
доказательства

## Сложите два ломтика вместе. Приятного аппетита!
### Введение в доказательства

Математика замечательна тем, что позволяет выстра­
ивать доказательства, которые никогда не утрачивают
своей силы. Если аксиомы1 верны, как и логическая
цепочка, связывающая эти аксиомы с данным резуль­
татом, то он всегда является верным.
Математическое доказательство должно демонстриро­
вать, что утверждение верно всегда, то есть не просто во
многих случаях, а во всех.
Студенты часто используют такие фразы, как «это
очевидно» или «это легко показать». Однако матема­
тическое доказательство не допускает пропуска шагов.
В учебнике простые шаги могут быть опущены для
краткости, но в общем случае доказательство требует
выстраивания всей логической цепочки.
1
Аксиома — утверждение, принимаемое истинным без доказа­
тельств, из которого логически выводятся дополнительные
утверждения. Например, согласно одной из аксиом Евклида,
любые две точки могут быть соединены прямой линией.

181
Глава 15. Приемлемые доказательства
Пример
Числа-близнецы — это пары простых чисел, отлича­
ющихся друг от друга на 2 (например, 5 и 7, 11 и 13, 17
и 19). Согласно гипотезе1 о простых числах-близнецах
существует бесконечное количество простых чисел, от­
личающихся друг от друга на 2. Это кажется разумным,
поскольку мы знаем, что существует бесконечно много
простых чисел2, однако это неочевидно, так как до сих
пор нам не удавалось обнаружить никакой закономер­
ности в порядке их появления.
На момент написания этой книги самыми большими
числами-близнецами были 2 996 863 034 895 * 21 290 000
+/– 1, состоящие из 388 342 цифр. Множество чисел-
близнецов, обнаруженных до настоящего момента,
убедительно свидетельствует о том, что они будут
появляться бесконечно, однако это не есть доказа­
тельство!

## Сложите два ломтика вместе. Приятного аппетита!
### Конструктивное

доказательство,
доказательство методом
исчерпывания вариантов
Эти два метода доказательства часто путают.
Конструктивное доказательство — это доказательство,
в котором существование объекта доказывается путем
построения его примера.
Если я хочу доказать гипотезу о существовании двух
простых чисел, отличающихся друг от друга на 2, то
могу сделать это, предоставив пару таких чисел (на­
пример, 17 и 19). В данном случае цель — просто про­
демонстрировать факт существования искомого объ­
екта, а для этого достаточно привести хотя бы один
пример.
При использовании метода исчерпывания вариантов
мы разбиваем задачу на некое количество случаев и до­

185
Глава 16. Методы доказательства
казываем каждый из них отдельно1. Лемма о накач­
ке, обсуждаемая в главе 13, доказывается с помощью
именно этого метода: мы берем строку, принадлежа­
щую некое­му языку, и показываем, что любой автомат,
генерирующий эту строку, также будет генерировать
строки, которых нет в данном языке.
Пример
Согласно теореме о четырех цветах2, для правильной
раскраски планарного графа требуется не более четы­
рех цветов. Кеннет Аппель (Kenneth Appel) и Вольфганг
Хакен (Wolfgang Haken) доказали эту теорему методом
исчерпывания вариантов, продемонстрировав, что ми­
нимальный контрпример должен содержать одну из
1936 возможных конфигураций, каждая из которых
была проверена с помощью компьютера.

## Сложите два ломтика вместе. Приятного аппетита!
### Доказательство

от противного 2
При использовании данного метода доказательства мы
предполагаем, что утверждение, которое мы хотим опро­
вергнуть, на самом деле верно, а затем показываем, что
это предположение приводит к логическому противо­
речию, то есть к заведомо ложному утвер­ждению.
1
Этот метод доказательства также называется методом «разбора
случаев», поскольку мы разбиваем задачу на конечное число
частных случаев (каждый из которых может содержать беско­
нечное количество примеров) и отдельно доказываем каждый.
2
См. раздел 4.7.

186
Часть VI. Доказательства
Пример
Иррациональное число — это действительное число,
которое нельзя представить в виде отношения двух
целых чисел.
Предположим, нам нужно доказать, что число √2  явля­
ется иррациональным. Допустим, оно является рацио­
нальным; тогда √2  можно представить в виде несокра­
тимой дроби a / b, где a и b — взаимно простые числа.
Выполнив преобразование, получим b√2  = a. Возведя
обе части уравнения в квадрат, получим b2 * 2 = a2.
Поскольку a2 в два раза больше b2, число a должно быть
четным, поэтому мы можем представить его в виде
произведения a = 2c, где c — некое третье число. Итак,
мы имеем: 2b2 = (2c)2 = 4c2. Тогда b = 2c, а это значит,
число b — четное, что противоречит предположению
о том, что дробь a / b является несократимой1.
Таким образом, наше первоначальное предположе­
ние было неверным, то  есть число  √2  не является
рациональным.
Если мы хотим использовать конструктивное доказа­
тельство, но не знаем, как подойти к построению объ­
екта, то можем показать, что утверждение о том, что
этот объект несуществует, приводит к противоречию. 1
Доказательство, демонстрирующее существование объ­
екта без его фактического построения, называется не­
конструктивным.
1
Если числа a и b являются взаимно простыми, то у них не
может быть никакого общего делителя, кроме +/–1.

187
Глава 16. Методы доказательства

## Сложите два ломтика вместе. Приятного аппетита!
### Доказательство методом

индукции
Доказательство методом индукции состоит из двух эта­
пов. На первом из них, называемом базой (или базисом)
индукции, мы доказываем истинность гипотезы для
некоего начального случая или случаев.
На втором этапе, называемом индуктивным пере­
ходом (или шагом индукции), мы показываем, что
если утверждение верно для случая k, то оно верно
и для следующего случая k + 1. О нескольких базовых
случаях речь идет тогда, когда данный этап доказа­
тельства зависит от нескольких предыдущих шагов
или когда для доказательства необходимо, чтобы пре­
дыдущий шаг был на некую минимальную величину
больше того базового случая, который мы хотим до­
казать.
Итак, наше рассуждение строится следующим образом.
Утверждение верно для случая 1. Поскольку оно верно
для случая 1, оно должно быть верно для случая 2. По­
скольку оно верно для случая 2, оно должно быть верно
для случая 3. Поскольку оно верно для случая n, оно
должно быть верно для случая n + 1.
Как только мы показали, что утверждение верно для
базового случая, а также то, что из истинности утвер­
ждения для каждого случая вытекает его истинность
для каждого последу­ющего случая, мы можем сказать,
что утверждение является истинным для любого слу­
чая n, а значит, теорему можно считать доказанной.

188
Часть VI. Доказательства
16.3.1.  Пример
Представьте, что у нас есть шахматная доска, из которой
вырезана одна клетка. Подобная шахматная доска 2 × 2
могла бы выглядеть так.
Назовем эту фигуру L. Теперь представьте, что у нас
есть шахматная доска 2n × 2n с вырезанной клеткой. Нам
нужно доказать, что ее можно замостить (то есть по­
крыть все клетки доски) только L-образными плитками.
Базовый случай — показанная выше доска 2 × 2 с выре­
занной клеткой. Форма данной доски по определению
совпадает с формой L-образной плитки, поэтому оче­
видно, что ее можно замостить.
Предположим, данное утверждение верно для доски
размером до 2k × 2k; это наша индуктивная гипотеза
(ИГ). Рассмотрим доску размером 2k + 1 × 2k + 1, которую
можно представить в виде сетки 2 × 2, состоящей из
досок 2k × 2k.

189
Глава 16. Методы доказательства
Положите плитку так, чтобы каждый из составляющих
ее квадратов располагался на одной из трех четвертей до­
ски, в которых нет вырезанных клеток. Теперь у нас есть
четыре доски размером 2k × 2k, в каждой из которых от­
сутствует (или закрыта) одна клетка, которые, согласно
нашей индуктивной гипотезе, можно выложить плиткой.
Такой способ покрытия всей шахматной доски 2k + 1 × 2k + 1
доказывает, что подобную доску можно замостить плит­
ками при любом положительном целом k.

190
Часть VI. Доказательства
16.3.2.  Ошибочное доказательство
Предположим, я хочу доказать, что все лошади одного
цвета1.
База индукции: очевидно, что в множестве, состоящем
из одной лошади, все лошади одного цвета.
Индуктивная гипотеза: в любом множестве лошадей,
состоящем из k особей, все лошади одного цвета.
Индуктивный шаг: рассмотрим множество, состоящее
из k + 1 лошадей. Согласно ИГ, первые k из них одного
цвета. Согласно ИГ, последние k из них тоже одного
цвета. Поскольку эти два множества пересекаются, все
k + 1 лошадей имеют одинаковый цвет, следовательно,
все лошади одного цвета!
Что не так с этим доказательством? В данном примере
нам нужно было доказать два базовых случая. Индук­
тивный шаг предполагает пересечение множеств, со­
стоящих из первых и последних k лошадей, что невер­
но, если k = 1. Нам также следовало доказать базовый
случай для двух лошадей, но мы не можем показать, что
две лошади имеют одинаковый цвет, поэтому данное
доказательство является ошибочным.
1
На самом деле это не так.

191
Глава 16. Методы доказательства

## Сложите два ломтика вместе. Приятного аппетита!
### Доказательство на основе

закона контрапозиции
Зачастую для того, чтобы доказать то или иное утвержде­
ние, гораздо легче доказать его модифицированную (воз­
можно, более сильную) версию, которая подразумевает
то, что мы хотели доказать с самого начала. Согласно за­
кону контрапозиции, если некая посылка A влечет за со­
бой некое следствие B (A ⇒ B), то отрицание следствия B
влечет за собой отрицание посылки A (B– ⇒ A–). Если
контрапозиционное утверждение истинно, то исходное
утверждение также должно быть истинным, иначе посыл­
ка A и ее отрицание A– будут иметь место одновременно.
Пример
Предположим, мы хотим доказать, что если число k
является иррациональным, то число √k  также должно
быть иррациональным.
Контрапозиционное утверждение состоит в том, что
если число √k  является рациональным, то число k также
должно быть рациональным.
Предположим, что √k  — это рациональное число; тогда
его можно представить в виде отношения двух целых
чисел: √k  = a / b.
Возведя обе части уравнения в квадрат, получаем k =
= a2 / b2. Это уравнение показывает, что число k также
представляет собой отношение двух целых чисел и, сле­
довательно, является рациональным.
Эта цепочка рассуждений доказывает, что если √k  — ра­
циональное число, то число k также должно быть рацио­
нальным, и наоборот, если k является иррациональным
числом, то число √k  тоже должно быть иррациональным.

17
Сертификаты
Допустим, у нас есть проверенный алгоритм, позволя­
ющий решить ту или иную задачу. Если мы реализуем
этот алгоритм в виде программы, то можем ли быть
уверены в том, что она будет выдавать правильное ре­
шение?
Опасайтесь ошибок в приведенном выше коде;
я доказал его корректность, но еще
не запускал его.
Дональд Кнут1
Сложность заключается в следующем: несмотря на кор­
ректность алгоритма, мы не можем быть уверены в том,
что его реализация не содержит ошибок. Поэтому нам
необходимо каким-то образом проверить, действитель­
но ли программа возвращает правильный ответ.
Доказательство корректности называется сертифика­
том. Это то, что мы можем легко проверить, чтобы убе­
1
Knuth D. E. Notes on the van Emde Boas construction of prio­
rity deques: An instructive use of recursion, classroom notes.
March 1977.

193
Глава 17. Сертификаты
диться в правильности ответа. Например, рассмотрим
программу, определяющую, является ли то или иное
число простым. Если ответ отрицательный, то сертифи­
кат будет представлять собой набор целых чисел, про­
изведением которых является проверяемое нами число.
Наша цель — удостовериться в отсутствии ошибок
в программе, поэтому нам необходимо добиться того,
чтобы проверка сертификата происходила быстрее
и проще (то есть отличалась меньшим асимптотиче­
ским временем выполнения и меньшей сложностью),
чем решение исходной задачи. Сертификат считается
сильным, если алгоритм верификации имеет лучшие

194
Часть VI. Доказательства
временные показатели по сравнению с процессом ре­
шения исходной задачи, и слабым, если это не так; на
практике алгоритмы часто имеют сильный сертификат
отвержения и слабый сертификат принятия или наобо­
рот1.
Пример
Проверка графа на двудольность занимает время O(n + m).
Если граф является двудольным, то сертификат при­
нятия представляет собой раскраску графа в два цве­
та. В данном случае проверка также занимает время
O(n + m), что делает сертификат слабым. Если граф не
является двудольным (содержит нечетный цикл), то
сертификат отвержения может быть проверен за время
O(n), что делает этот сертификат сильным.
1
Kratsch, D. McConnell R. M., Mehlhorn K., Spinrad J. P. Certify­
ing algorithms for recognizing interval graphs and permutation
graphs // ACM-SIAM SODA. № 14 (2003). Р. 866–875.

Часть VII
Безопасность
и конфиденциальность

18
Введение
в безопасность
Обеспечение информационной безопасности — это
комплекс мер, направленных на предотвращение угроз,
связанных с нарушением конфиденциальности, целост­
ности и доступности данных.

## Сложите два ломтика вместе. Приятного аппетита!
### Конфиденциальность

Рассмотрим следующие виды информации:
z
z переписку пациента и врача на медицинском пор­
тале;
z
z электронную таблицу с суммой расходов на предвы­
борную рекламу;
z
z список логинов и паролей пользователей для входа
на популярные торговые площадки.
В каждом из этих случаев очень важно, чтобы инфор­
мация оставалась конфиденциальной1. При нарушении
1
Иногда даже само наличие информации должно оставаться
в тайне. Например, факт общения пациента с онкологом рас­
крывает личную медицинскую информацию.

197
Глава 18. Введение в безопасность
конфиденциальности информация становится доступ­
на третьим лицам, не уполномоченным на ее получе­
ние. Это может произойти по нескольким причинам,
изложенным ниже.
z
z В компании не внедрена политика, запрещающая
раскрытие информации, или ее сотрудники не следу­
ют данной политике. Например, конфиденциальные
документы хранятся в каталоге сайта, к которому
может получить доступ поисковый робот1.
z
z Злоумышленник получил доступ к информации,
замаскировавшись под доверенного пользователя
(сбой аутентификации). Законный пользователь
может щелкнуть на ссылке в электронном письме,
якобы отправленном Amazon, и, оказавшись на под­
дельном сайте, ввести свои учетные данные, после
чего злоумышленник сможет совершать покупки от
его имени.
z
z Злоумышленник сумел прочитать файл, который
должен был быть нечитаемым (сбой шифрования).
Файл мог быть зашифрован с помощью устаревшей
схемы шифрования или легко угадываемого пароля.
z
z Злоумышленник смог перехватить данные во время
их передачи от одного авторизованного пользователя
другому.
Безопасное хранение и передача информации часто
требует шифрования, о котором мы поговорим в сле­
дующих двух главах.
1
Это не шутка. Я случайно обнаружил целые налоговые де­
кларации в ходе поиска совершенно другой информации.

198
Часть VII. Безопасность и конфиденциальность

## Сложите два ломтика вместе. Приятного аппетита!
### Целостность

Понятие «целостность» имеет отношение к достоверно­
сти информации и охватывает две области: целостность
данных (сохранение информации в том виде, в каком
она была создана) и целостность источника (наличие
сведений о том, откуда поступила эта информация).
Чтобы обеспечить целостность данных, нам необходи­
мы механизмы предотвращения или выявления фактов
их несанкционированного изменения1. Кроме того, мы
хотим знать об источнике данных, поскольку от этого
зависит их достоверность. Например, в медицинских
вопросах мы склонны больше доверять врачу, чем ад­
министратору клиники. Благодаря механизмам обеспе­
чения целостности данных мы можем не только узнать,
кто отправил сообщение, но и доказать это. Подробнее
об этом мы поговорим в главе 22.

## Сложите два ломтика вместе. Приятного аппетита!
### Доступность

Если злоумышленнику и не удастся скомпрометировать
систему, то он все равно может сделать ее недоступной
для использования. Его действия могут варьироваться от
простой попытки сделать сервис недоступным для всех
(например, проведя атаку типа «отказ в обслуживании»
на популярный сайт) до вызова задержек, позволяющих
провести повторную атаку (приводящую к аварийному
переключению с безопасного сервера на взломанный).
1
Данное изменение не обязательно должно быть умышленным.
С помощью контрольной суммы можно выявить как при­
знаки преднамеренного изменения, так и случайные ошибки.

199
Глава 18. Введение в безопасность

## Сложите два ломтика вместе. Приятного аппетита!
### Цели

Различные механизмы обеспечения безопасности пре­
следуют три основные цели:
z
z предотвращение успешной атаки. Политика исполь­
зования надежных паролей направлена на защиту
системы от несанкционированного доступа;
z
z восстановление после атаки. Это может означать вос­
становление удаленного или измененного файла из
резервной копии или судебное преследование зло­
умышленника;
z
z выявление факта атаки. Это может означать обнару­
жение выполняющейся атаки с целью ее отражения
(например, блокирование пользователя после не­
скольких неудачных попыток входа в систему) или
выявление уже произошедшего вторжения и при­
нятие мер по восстановлению системы.

19
Введение
в криптографию
Криптография — это наука о способах обеспечения
безопасности коммуникации, охватывающая широкий
спектр математических методов1. Криптографию можно
считать одним из самых опасных разделов Computer
Science, учитывая частоту случаев некачественной реа­
лизации и возможные последствия использования не­
безопасной криптографической системы.
Предотвратить перехват сообщения можно несколь­
кими способами. Самый простой (если не в плане ре­
ализации, то по крайней мере в концептуальном плане)
заключается в том, чтобы скрыть это сообщение. В идеа­
ле противник вообще не должен знать о его отправке.
Люди использовали стеганографию (практику сокры­
тия факта передачи сообщения) на протяжении многих
тысячелетий. Согласно греческому историку Геродоту,
тиран Гистией велел обрить голову своему слуге и вы­
татуировать на ней послание, а когда волосы отросли,
1
Более подробно с историей криптографии вы можете ознако­
миться, прочитав увлекательную «Книгу шифров» Саймона
Сингха (Simon Singh).

201
Глава 19. Введение в криптографию
отослал его с поручением снова обрить голову по при­
бытии на место. В наше время изображение или другой
файл может содержать скрытое послание, часто прямо
на виду. Если криптография позволяет скрыть содержи­
мое сообщения, то стеганография позволяет скрыть сам
факт его отправки.
Сообщение можно защитить двумя способами: с помо­
щью кодов и с помощью шифров. При использовании
шифра буквы (или группы букв) заменяются другими
буквами (или группами букв). Например, широко из­
вестный шифр Цезаря предполагает замену каждой
буквы другой буквой, находящейся на несколько по­
зиций левее или правее в алфавите1. При использова­
нии кода словам или фразам придается другое, заранее
оговоренное значение, не имеющее прямого отношения
к сказанному; например, фраза «куриный суп» может
означать «атака на рассвете».

## Сложите два ломтика вместе. Приятного аппетита!
### Современная криптография

В прошлом сохранение информации в тайне в значи­
тельной степени опиралось на принцип «безопасность
через неясность», предполагающий сокрытие сообще­
ния или отсутствие у противника ключей для его рас­
шифровки.
В основе современной криптографии лежит матема­
тика. Мы предпочитаем использовать криптосистему,
спроектированную таким образом, что, даже имея
1
Говорят, при переписке со своими генералами сам Цезарь
использовал сдвиг на три символа.

202
Часть VII. Безопасность и конфиденциальность
копию зашифрованного текста (шифротекст) и зная,
как именно он был зашифрован, злоумышленник все
равно не сможет прочитать сообщение, не зная обще­
го секретного ключа. Наличие этого ключа позволяет
расшифровать сообщение и восстановить открытый
(исходный) текст.

## Сложите два ломтика вместе. Приятного аппетита!
### Абсолютно безопасный обмен

данными
Теоретически, если времени и вычислительной мощно­
сти достаточно, можно взломать практически любой
шифр. Чем больше объем передаваемого шифротекста,
созданного с помощью одного и того же ключа, тем
проще его расшифровать. Например, при использо­
вании шифра подстановки (когда каждая буква за­
меняется другой) по мере увеличения длины текста
в нем будет наблюдаться частотное распределение
букв, характерное для языка, на котором написано
сообщение, что упрощает его расшифровку методом
частотного анализа.
Исключение и единственный способ шифрования, ко­
торый нельзя взломать с помощью криптографических
методов, — одноразовый блокнот (рис. 19.1). При его
1
Однако этот подход может ослабить безопасность схемы ши­
фрования, вследствие чего обладателю ключей рекомендуется
использовать разные ключи для расшифровки и подписи.

204
Часть VII. Безопасность и конфиденциальность
использовании у Алисы и Боба есть общий ключ, длина
которого не может быть меньше длины передаваемо­
го текста, и каждая буква этого текста комбинируется
с соответствующей буквой блокнота для получения
шифротекста. При условии, что блокнот содержит дей­
ствительно случайные символы, хранится в секрете
и применяется только один раз, полученный с его помо­
щью шифротекст не может быть расшифрован. Слож­
ность заключается в создании и распространении этих
одноразовых блокнотов (это одна из тех задач, которые
решает квантовая криптография).
Рис. 19.1. Одноразовый блокнот, использовавшийся Агент­
ством национальной безопасности США. Слева сам блокнот,
а справа — инструкции по шифрованию каждой буквы откры­
того текста с учетом соответствующей буквы блокнота. Изо­
бражение взято из рассекреченного документа, доступного
по адресу https://bit.ly/3d6byxX

205
Глава 19. Введение в криптографию

## Сложите два ломтика вместе. Приятного аппетита!
### Квантовое распределение

ключей
Самый известный способ применения квантовой крип­
тографии — квантовое распределение ключей, которое
позволяет Алисе и Бобу сгенерировать ключ, не при­
бегая к личной встрече или любой другой форме без­
опасной коммуникации.
При этом требуется, чтобы Алиса и Боб обменивались
данными по аутентифицированному классическому
каналу, то есть отправляли сообщения (не обязательно
конфиденциальные) и были уверены в том, что они об­
щаются друг с другом, а не с кем-то посторонним.
Технология квантового распределения ключей опирает­
ся на тот факт, что перехватчик должен будет измерить
передаваемые квантовые состояния, а значит, изменить
их. А такие изменения можно выявить.
В классическом примере используются состояния по­
ляризации фотона. Алиса посылает поток фотонов
и измеряет их состояния, но для каждого из них она
случайным образом выбирает прямолинейную или диа­
гональную поляризацию. Получая фотоны, Боб дела­
ет то же самое. Затем они сравнивают поляризации,
выбранные ими для каждого фотона (задействуя для
этого классический канал), и отбрасывают те, которые
не совпадают.
После этого они выбирают случайное подмножество
фотонов и сравнивают свои результаты. Если информа­
ция не была перехвачена и квантовый канал является

206
Часть VII. Безопасность и конфиденциальность
достаточно надежным, то результаты почти всех изме­
рений должны совпасть. Если же Еве удалось перехва­
тить фотоны, то примерно в 50 % случаев она не сможет
определить состояние полученного фотона и отправит
фотон Бобу в выбранном наугад состоянии. В результа­
те его измерения будут отличаться от измерений Алисы
примерно в 25 % случаев, из чего они смогут сделать
вывод о небезопасности квантового канала.
Коммерческие системы квантового распределения клю­
чей доступны уже в течение некоторого времени.

20
Криптографическая
система с открытым
ключом
Асимметричная криптография предполагает использо­
вание разных ключей для шифрования и расшифровки
сообщения. Этот тип шифрования лежит в основе крип­
тографии с открытым ключом, при которой открытый
ключ передается по незащищенному каналу, а расши­
фровка сообщения выполняется с помощью закрытого
ключа.

## Сложите два ломтика вместе. Приятного аппетита!
### Использование

открытого и закрытого
ключей
Если Алиса хочет отправить Бобу сообщение, то сна­
чала находит его открытый ключ и использует его для
шифрования. Затем она может отправить Бобу заши­
фрованное сообщение или даже опубликовать его на
открытом форуме. Получив сообщение, Боб задействует
для его расшифровки свой закрытый ключ.
Суть работы этой системы заключается в том, что зло­
умышленник не может (с помощью известных методов)

208
Часть VII. Безопасность и конфиденциальность
получить закрытый ключ из открытого ключа в разум­
ные сроки1.
Использование закрытых ключей также позволяет Али­
се подтвердить, что сообщение отправила именно она.
После шифрования сообщения Алиса снова шифрует
его с помощью своего закрытого ключа и прикрепляет
эту копию в качестве подписи. Любой обладатель ее
открытого ключа может расшифровать подпись, чтобы
убедиться в ее соответствии исходному зашифрован­
ному сообщению, а значит, в том, что отправителю был
известен закрытый ключ Алисы2.
В асимметричной криптографии используются так на­
зываемые односторонние функции с лазейкой — ма­
тематические функции, которые легко вычислить, но
трудно обратить, не имея определенной секретной ин­
формации.
Математика
Пусть дана такая функция f, что f(x) = y. Если f пред­
ставляет собой хорошую одностороннюю функцию
с лазейкой, то вычислить y из x легко, однако вычис­
лять x из y при отсутствии ключа непрактично.
1
Если сообщение должно оставаться в секрете на протяжении
недели, а на взлом шифра требуется три года, то мы можем
говорить о достаточной степени безопасности данных.
2
Использование такой подписи обеспечивает и невозможность
отказа от авторства. В дальнейшем Алиса не сможет заявить,
будто не отправляла сообщение, не заявив при этом о том, что
кто-то посторонний знает ее закрытый ключ.

209
Глава 20. Криптографическая система с открытым ключом

## Сложите два ломтика вместе. Приятного аппетита!
### Алгоритм RSA

RSA1 — это один из наиболее распространенных крип­
тографических алгоритмов с открытым ключом.
При использовании этого алгоритма Алиса выбирает
два больших простых числа p и q сопоставимой длины
и вычисляет их произведение n = pq. Данная функция
является односторонней, поскольку перемножить два
целых числа легко, а разложить результат на простые
множители — нет.
20.2.1.  Создание ключей
Алиса использует два больших простых числа p и q
и их произведение n, чтобы сгенерировать открытый
ключ e и закрытый ключ d, который нелегко получить
из e. Затем она публикует ключ шифрования e и про­
изведение n, поэтому они оказываются известны всем.
20.2.2.  Шифрование с помощью
открытого ключа
Если Боб хочет отправить Алисе сообщение M, то пре­
образует M в целое число m, которое подлежит шифро­
ванию, а затем выполняет следующие операции.

## Возводит число m в степень e: m' = me.


1
RSA — это аббревиатура, состоящая из первых букв фами­
лий создателей алгоритма: Rivest (Ривест), Shamir (Шамир)
и Adleman (Эдлман).

210
Часть VII. Безопасность и конфиденциальность

## Берет результат по модулю n, чтобы получить ши­


фротекст c: c = m' mod n.
20.2.3.  Расшифровка с помощью
закрытого ключа
Получив сообщение (c), Алиса расшифровывает его,
используя свой закрытый ключ.

## Сначала она возводит зашифрованное число в сте­


пень d: c' = cd.

## Затем, чтобы восстановить исходное целое число,


выполняет операцию взятия по модулю: m = c' mod n.

## Наконец, преобразует m в сообщение M, которое


теперь может прочитать.
Математика
Почему это работает? Согласно малой теореме Ферма,
если p — простое число, а a — целое число, то ap ≡ a mod p.
Символ ≡ означает, что обе части конгруэнтны (срав­
нимы) по модулю. Например, числа 3 и 15 сравнимы
по модулю 12, поэтому 3-й час (3 часа ночи) и 15-й час
(3 часа дня) находятся на одной позиции 12-часового
циферблата.
В данном случае сообщение m возводится в степень e,
а затем в степень d, mod n. При возведении степени в сте­
пень основание остается без изменений, а показатели
степеней перемножаются, поэтому после шифрования
и расшифровки мы получаем med mod n. Алиса выбирает
такие числа e и d, что в результате у нас остается исход­
ное сообщение m.

211
Глава 20. Криптографическая система с открытым ключом
20.2.4.  Попытки перехвата сообщения
Чтобы расшифровать сообщение, Ева должна знать
значение d. Для вычисления d ей нужно разложить n
на простые множители (а значит, воссоздать закрытый
ключ), что является сложной задачей. Таким образом,
сообщение считается защищенным, поскольку совре­
менные технологии и математические методы не по­
зволяют Еве взломать шифр в разумные сроки.

## Наконец, преобразует m в сообщение M, которое
### Соображения

производительности
Поскольку симметричное шифрование происходит
быстрее, чем асимметричное, асимметричные ключи,
как правило, используются для обмена симметричны­
ми ключами, также известными как сеансовые ключи,
которые применяются для шифрования и расшиф­
ровки данных в ходе сеанса. Этот метод позволяет
объединить удобство асимметричной криптографии,
скорость симметричной криптографии и безопасность,
обусловленную частой заменой ключа (каждый сим­
метричный ключ применяется только для одного се­
анса связи).
По такому же принципу работает протокол SSL. Брау­
зер получает копию асимметричного ключа сервера, соз­
дает сеансовый ключ, зашифровывает его и отправляет
серверу. Тот расшифровывает сообщение, используя
свой закрытый ключ, а в ходе остальной части сеан­
са данные шифруются с помощью общего секретного
ключа.

212
Часть VII. Безопасность и конфиденциальность
Причина, по которой симметричное шифрование выпол­
няется быстрее, заключается в том, что ­асимметричное
шифрование предполагает использование более длин­
ного ключа1. Поскольку симметричный ключ может
представлять собой любое случайное число, надежность
такого ключа зависит от его длины. Асимметричный
ключ выбирается с помощью известного алгоритма, по­
этому данное пространство ключей содержит меньше
уникальных значений, кроме того, они подчиняются
определенным закономерностям, которыми может вос­
пользоваться злоумышленник. Как следствие, в целях
обеспечения сопоставимого уровня надежности про­
странство ключей для асимметричного алгоритма долж­
но быть больше, чем для симметричного.
Например, в случае описанного выше алгоритма RSA
закрытый ключ состоит из двух простых чисел, а значит,
все остальные числа можно игнорировать, поскольку
они не могут быть частью этого ключа.
1
Алгоритмы симметричного шифрования обычно использу­
ют ключи от 128 до 256 бит, в то время как асимметричные
обычно применяют ключи от 1024 до 4096 бит.

21
Аутентификация
пользователя
Пароли использовались для получения доступа к се­
кретной информации на протяжении многих тысячеле­
тий. Но в эпоху Интернета пароли часто не гарантируют
должный уровень безопасности по нескольким причинам.
z
z Слабые пароли. Если система допускает неогра­
ниченное количество попыток ввода пароля, то
зло­умышленник может просто перепробовать все
возможные пароли, пока не найдет правильный.
В данном случае речь может идти об исчерпывающем
поиске ключей (переборе всех допустимых комби­
наций) или об атаке по словарю (переборе списка
распространенных паролей).
z
z Повторное использование паролей. Даже надеж­
ный пароль можно выяснить. Если злоумышленник
получит пароль, связанный с одним и тем же именем
пользователя или адресом электронной почты на не­
скольких сайтах, то сможет получить доступ к каж­
дому из них.
Введение дополнительных требований к длине и слож­
ности паролей помогает решить первую проблему, но

214
Часть VII. Безопасность и конфиденциальность
повышает вероятность того, что пользователь повторно
применит пароль (кому захочется запоминать несколь­
ко длинных и сложных комбинаций символов?), сохра­
нит его в доступном злоумышленнику месте1 или забу­
дет. Одно из решений — менеджеры паролей (которые
генерируют и сохраняют надежные пароли для разных
сайтов, при этом пользователю требуется запомнить
только один мастер-пароль). Правда, в случае взлома
менеджера паролей злоумышленник получит доступ ко
всем учетным записям пользователя2.
Ниже перечислены другие средства повышения надеж­
ности паролей.
z
z Принудительная смена пароля. До недавнего вре­
мени корпорация Microsoft рекомендовала компани­
ям побуждать сотрудников к частой смене паролей
с целью предотвращения возможной утечки послед­
них. Однако частая смена паролей лишь усугубляет
описанные выше проблемы (пользователи, которым
приходится часто менять пароли, как правило, выби­
рают более легкие для запоминания), поэтому данная
мера больше не рекомендуется3. Пароли, которые не
были украдены, менять не обязательно, однако если
1
В 2018 году сотрудник Белого дома наделал много шума,
когда записал свои пароли от зашифрованной электронной
почты на официальном бланке и забыл его на автобусной
остановке.
2
В 2019 году выяснилось, что ошибка кэширования в по­
пулярном менеджере паролей LastPass допускала утечку
последних использованных паролей на вредоносный сайт.
3
https://bit.ly/3gLon38.

215
Глава 21. Аутентификация пользователя
вы подозреваете, что они были скомпрометированы,
то их следует незамедлительно заменить.
z
z Списки запрещенных паролей. Помимо предъяв­
ления требований к минимальной длине пароля, его
можно сравнить со списком распространенных па­
ролей и запретить его использование в случае со­
впадения с одним из присутствующих в этом списке
вариантов.
z
z Хеширование паролей. Безопасный сайт не позво­
лит вам восстановить утерянный пароль, поскольку
никогда его не сохраняет. Вместо этого он объединя­
ет пароль с так называемой солью (уникальной для
каждого пользователя секретной строкой)1, хеширу­
ет полученное значение2 и сохраняет хешированное
значение. Таким образом, даже если база данных
паролей будет скомпрометирована, злоумышленни­
ку все равно придется взламывать каждый пароль
по отдельности.
z
z Многофакторная аутентификация. Как правило, тре­
мя главными факторами аутентификации ­являются:
знание (например, пароля для входа на сайт), облада­
1
Применение уникальной для каждого пользователя соли
позволяет предотвратить применение радужных таблиц —
особых таблиц поиска для обращения криптографических
хеш-функций. При наличии базы данных с хешированными
паролями мы можем восстановить пароль, хранящийся в ней
в виде хеш-значения, и таким образом получить доступ к нуж­
ной учетной записи. Добавление соли, уникальной для каж­
дого пользователя, делает радужную таблицу бесполезной.
2
Чтобы познакомиться с темой хеширования, обратитесь
к разделу 2.5.

216
Часть VII. Безопасность и конфиденциальность
ние (смарт-картой для доступа в здание) и свойство
(отпечаток пальца для разблокировки телефона). Ис­
пользование кредитной карты с чипом и PIN-кодом
требует двух факторов: обладания (самой картой)
и знания (PIN-кода)1. В настоящее время многие сай­
ты задействуют двухфакторную аутентификацию2,
для прохождения которой требуется пароль и вре­
менный код, позволяющий вам подтвердить нали­
чие доступа к телефону или устройству, связанному
с учетной записью.
1
В качестве еще одного примера можно привести вход в Disney
World по многодневному билету, который предполагает ис­
пользование сканера отпечатков пальцев, поэтому зависит
как от обладания (билетом), так и от вашего свойства (от­
печатка пальца).
2
Двухфакторная аутентификация, или 2FA, представляет
собой разновидность многофакторной аутентификации, ко­
торая использует комбинацию двух факторов.

Часть VIII
Аппаратное
и программное
обеспечение

22
Аппаратные
абстракции
Большинство из нас не занимается написанием машин­
ного кода для непосредственного управления оборудо­
ванием компьютера. Вместо этого мы используем набор
абстракций, позволяющих получить доступ к ресурсам
определенного типа, не запоминая их физические де­
тали. Эти абстракции могут иметь место на нескольких
уровнях.
z
z При обращении к операционной системе нам нужно
знать только ее API, а не конкретный набор команд
процессора, на базе которого она работает.
z
z При написании кода на высокоуровневом языке
программирования мы можем использовать общие
команды, которые компилятор затем преобразует
в специфичные для процессора инструкции.

## Наконец, преобразует m в сообщение M, которое
### Физическое хранилище

Данные хранятся в памяти компьютера в виде набора
нулей и единиц.
Традиционный жесткий диск состоит из одной или не­
скольких круглых пластин; их поверхность разделена на

219
Глава 22. Аппаратные абстракции
дорожки (концентрические круги) и секторы (клинья)
(рис. 22.1). Каждый сектор содержит несколько1 очень
мелких областей, которые можно намагничивать или раз­
магничивать по отдельности. По мере вращения пластин
головки чтения/записи перемещаются к областям, в ко­
торых требуется считать или записать биты информации.
В твердотельном накопителе используется флеш-па­мять
типа NAND2, хранящая данные в массиве транзисто­
ров, то есть в ячейках памяти (на пересечении строки
и столбца), которые могут находиться в одном из двух
состояний в зависимости от подаваемого напряжения.
Каждый диск предусматривает контроллер — компо­
нент, который управляет физическим доступом к памя­
ти, позволяя ЦП просто запросить нужные данные, не
прибегая к необходимости непосредственно управлять
рычагом привода жесткого диска или подавать напря­
жение на транзисторы твердотельного накопителя. По­
мимо этого, контроллер может выполнять такие допол­
нительные функции, как выявление и переназначение
поврежденных секторов, обнаружение и исправление
ошибок, а также выравнивание износа3.
1
Традиционно размер сектора жесткого диска составлял
512 байт, однако в 2011 году был введен новый стандарт
и размер сектора был увеличен до 4096 байт за счет объеди­
нения восьми 512-байтовых секторов.
2
Сокращение NAND (Not AND) обозначает логический эле­
мент «И-Не» (см. врезку).
3
Для выравнивания износа контроллер пытается организо­
вать данные таким образом, чтобы обеспечить равномерную
запись во все ячейки памяти, поскольку они рассчитаны на
ограниченное количество циклов записи.

220
Часть VIII. Аппаратное и программное обеспечение
Рис. 22.1. Схематическое изображение пластины жесткого
диска. Источник изображения: Wikimedia Commons
Каждый из концентрических кругов [A] называется до­
рожкой, а каждый клин в форме куска пирога [B] — гео­
метрическим сектором. Пересечение дорожки и геоме­
трического сектора называется сектором дорожки [C]
и представляет собой наименьший элемент данных, ко­
торый может быть прочитан с диска или записан на него.
Кластер [D] — наименьшая логическая единица дис­
кового пространства, которая фактически используется
операционной системой (например, для хранения файла).

221
Глава 22. Аппаратные абстракции
Забираемся в дебри
Любой тип флеш-памяти предполагает использование
транзисторов для хранения данных, но эти транзисторы
могут быть организованы по-разному. Два основных
типа такой памяти, NOR и NAND, названы в честь
соответствующих логических элементов. Различное
расположение транзисторов обусловливает различные
физические свойства.
Флеш-память типа NOR (Not OR) обеспечивает воз­
можность высокоскоростного произвольного доступа,
отличается высокой надежностью и позволяет считывать
и записывать отдельные байты.
Для флеш-памяти типа NAND (Not AND) характерны
ячейки меньшего размера, что обусловливает гораздо
более высокую скорость записи и стирания данных, а так­
же меньшую стоимость. Однако флеш-память NAND
считывает и записывает данные отдельными страницами
или блоками и не позволяет работать напрямую с бай­
тами. Использование косвенного интерфейса усложняет
получение доступа к такой памяти, а наличие плохих
блоков требует дополнительных функций исправления
ошибок, в которых не нуждается флеш-память NOR.
На практике флеш-память NOR используется для хра­
нения и выполнения кода (например, прошивка мобиль­
ных телефонов), а флеш-память NAND — для хранения
данных (карты памяти и твердотельные накопители).

## Наконец, преобразует m в сообщение M, которое
### Данные и методы

ввода/вывода
Физическая структура жестких дисков и флеш-памяти
типа NAND не позволяет считывать или записывать

222
Часть VIII. Аппаратное и программное обеспечение
отдельные байты. Вместо этого мы имеем дело с це­
лым блоком. Блок — наименьшая логическая единица
данных, которая может быть прочитана или записана
операционной системой, а сектор — наименьшая фи­
зическая единица хранения данных на жестком диске.
Таким образом, размер блока равен размеру одного или
нескольких секторов. В зависимости от диска он, как
правило, составляет 512 или 4096 байт1.
SSD-накопители не имеют секторов, но их ячейки па­
мяти организованы в страницы, а несколько страниц
(обычно 128) составляют блок. Данные могут быть про­
читаны и записаны на уровне страницы, но их стирание
происходит только на уровне блока.
Каждый физический сектор имеет заголовок, включа­
ющий информацию, которую задействует контроллер
диска, и область данных, содержащую как сохраненную
пользователем информацию, так и коды коррекции
ошибок (error-correcting code, ECC). Более крупные
секторы более эффективны, поскольку их заголовок
занимает меньше места, а значит, для хранения поль­
зовательских данных может быть выделено больше
дискового пространства. Более крупные секторы также
нуждаются в большем объеме ECC-кода для поддер­
жания той же эффективности исправления ошибок.
Кроме того, поскольку жесткие диски большей емкости
отличаются более плотной упаковкой данных, любой
1
Диски с 4096-байтовыми секторами обычно способны эму­
лировать 512-байтовые секторы. Однако обновление логиче­
ских 512-байтовых секторов все равно предполагает чтение
и запись всего 4096-байтового сектора, что сопровождается
уменьшением скорости.

223
Глава 22. Аппаратные абстракции
физический недостаток может повлиять на большее
количество битов, что опять же требует большего объ­
ема ECC-кода для поддержания уровня эффективности
исправления ошибок.

## Наконец, преобразует m в сообщение M, которое
### Память

Когда речь заходит о компьютерной памяти, помимо
объема, программистов больше всего интересует ее рас­
пределение. При выполнении программы данные хра­
нятся либо в (контрольном) стеке, либо в куче. В любом
случае они хранятся в памяти (с одной оговоркой, о ко­
торой чуть позже); стек и куча — это просто структуры
данных, которые используются для их организации.
Когда запущенная программа вызывает функцию, все
переменные этой функции помещаются в стек. После
выполнения функции они удаляются из стека, и память
освобождается для повторного использования. Кроме
того, стек содержит указатели на функции, что обеспе­
чивает возврат управления в нужное место.
Стек представляет собой простую структуру данных
типа LIFO (Last In, First Out — «последним пришел,
первым ушел»; см. раздел 2.4), поэтому выделение
и осво­бождение памяти происходит более эффективно,
чем при использовании кучи1. В многопоточном при­
ложении каждый поток имеет свой стек. Поскольку
стек, как правило, содержит (относительно) неболь­
шое количество элементов, а доступ к стековой памяти
1
После выхода из функции вся память, которая была выделена
для нее в стеке, автоматически освобождается.

224
Часть VIII. Аппаратное и программное обеспечение
осуществляется достаточно часто, значения в стеке,
вероятно, будут кэшироваться. Кроме того, согласно
результатам исследований, использование небольшого
стекового кэша (отдельного от основного кэша) позво­
ляет значительно повысить производительность1.
В стек помещаются только примитивы и ссылки; объ­
екты всегда помещаются в кучу2. В отличие от стековой
памяти, доступ к которой строго регулируется, любой
элемент кучи может быть доступен в любое время ввиду
ее неупорядоченности. И куча, и стек занимают место
в памяти; часто стек растет сверху вниз, от самого вы­
сокого адреса к самому низкому, а куча — снизу вверх,
от самого низкого к самому высокому.
В отличие от стека, память для кучи выделяется динами­
чески и может быть освобождена в любое время3. Доступ
к памяти кучи отличается меньшей эффективностью,
и эту память необходимо отслеживать, поскольку ее
освобождение не происходит автоматически. Куча спо­
собна вмещать объекты разного размера, которые могут
храниться в ней, пока в стеке существуют ссылки на них.
1
Schoeberl M., Nielsen C. A Stack Cache for Real-Time Systems //
IEEE 19th International Symposium on Real-Time Distributed
Computing (ISORC). New York, 2016. P. 150–157.
2
Здесь под кучей подразумевается не структура данных, а об­
ласть памяти, выделяемая не так, как в случае стека. Когда
для выделения памяти используется функция new (в C++)
или malloc (в C), эта память поступает из кучи.
3
Когда вы создаете объект, для него выделяется память в куче.
Когда вы освобождаете память (или объект обрабатывается
сборщиком мусора), эта память снова становится доступной
для использования.

225
Глава 22. Аппаратные абстракции

## Наконец, преобразует m в сообщение M, которое
### Кэш

Несмотря на то что оперативная память работает бы­
стрее, чем жесткий диск, она не может незамедлительно
предоставлять данные процессору. Отчасти это объ­
ясняется предельной скоростью света: за тот или иной
промежуток времени свет (а значит, и данные) может
распространиться лишь на определенное расстояние1.
В вакууме свет преодолевает примерно 30,48 см за одну
наносекунду2. Это значит, если ЦП работает на частоте
3 ГГц, то максимальное расстояние, на которое может
распространиться сигнал за один тактовый цикл, со­
ставляет 10,16 см. Таким образом, если память находит­
ся на расстоянии более 6 см от ЦП, то данные не могут
быть получены за один тактовый цикл, даже если эта
память реагирует мгновенно.
Однако память, разумеется, не реагирует мгновенно.
Еще один важный фактор — количество времени, не­
обходимое модулю памяти для доступа к определенной
ячейке3. Даже при очень быстром ОЗУ эта задержка
озна­чает, что между запросом информации и получени­
ем доступа к ней пройдет несколько наносекунд.
1
Разумеется, скорость света — абсолютный предел; в дей­
ствительности мы не передаем данные настолько быстро,
это максимальная скорость, с которой их в принципе мож­
но передавать.
2
Объяснение понятия наносекунды адмиралом Грейс Хоп­
пер (Grace Hopper) можно найти по адресу: https://www.you­
tube.com/watch?v=9eyFDBPk4Yw.
3
Это так называемая CAS-латентность, или CAS-задержка
(от Column Address Strobe — строб адреса столбца).

226
Часть VIII. Аппаратное и программное обеспечение
Решение обеих этих задач заключается в расположении
небольшого объема очень быстрой памяти на самом кри­
сталле1. Близость к процессору позволяет минимизиро­
вать задержку, связанную с предельной скоростью све­
та, а использование небольшого объема очень быстрой
памяти вдобавок помогает сократить время ожидания.
Быстрая память, размещаемая на кристалле, отличается
ограниченным объемом и высокой стоимостью2, поэтому
применяется для кэширования самых часто используе­
мых данных. Эта встроенная в процессор память называ­
ется кэшем L1 (или кэшем первого уровня). Существует
также кэш L2, который находится на материнской плате,
но может отсутствовать на самом чипе3.

## Наконец, преобразует m в сообщение M, которое
### Регистры

В то время как кэш-память используется компьютером
для хранения данных, которые могут понадобиться
1
Кристалл — это небольшой блок полупроводникового мате­
риала, на котором размещены транзисторы, составляющие
ЦП; вместе со встроенной электроникой он образует инте­
гральную схему (как правило, называемую микросхемой или
чипом). Сначала производится кремниевая полупроводни­
ковая пластина с несколькими процессорами, которая затем
разделяется на отдельные устройства. Каждый кристалл
может содержать несколько ядер.
2
В качестве кэш-памяти задействуется память типа SRAM,
которая работает намного быстрее, чем DRAM, используемая
в качестве основной памяти, однако она занимает больше
места и стоит дороже.
3
Помимо большей удаленности от процессора, кэш L2, как пра­
вило, использует более медленную память типа DRAM, однако
его объем обычно в несколько раз превышает объем кэша L1.

227
Глава 22. Аппаратные абстракции
в ближайшем будущем, регистры служат для хране­
ния данных и инструкций, необходимых в настоящий
момент. Процессор работает с регистрами напрямую,
поэтому они представляют собой области памяти, на­
ходящейся в непосредственной близости от ЦП и име­
ющей минимальное время отклика. В разделе 25.1 мы
рассмотрим пример инструкции машинного кода, ука­
зывающей регистр, в который должно быть помещено
значение.
Обычно ЦП имеет как регистры общего назначения
(которые хранят временные данные и могут быть до­
ступны пользовательским программам), так и регистры
специального назначения наподобие аккумулятора,
счетчика команд и регистра команд1.
1
Аккумулятор служит для хранения промежуточных результа­
тов арифметических операций. Его можно представить в виде
блокнота, в котором записывается результат одного вычисле­
ния, используемого в качестве входных данных для следующе­
го. Счетчик команд содержит адрес следующей инструкции,
которую требуется извлечь из памяти. Регистр команд содер­
жит инструкцию, выполняемую в настоящий момент.

23
Программные
абстракции

## Наконец, преобразует m в сообщение M, которое
### Машинный код и язык

ассемблера
Вначале был машинный код. Машинный код — это
код, который выполняется непосредственно процес­
сорами и является специфичным для того или иного
их семейства. Двоичное (или, для удобства програм­
миста, шестнадцатеричное) число представляет дей­
ствие, которое требуется выполнить, и данные, над
которыми его нужно произвести. Язык ассемблера
упрощает процесс программирования, заменяя числа
мнемокодами.
Например1, вместо записи 10110000 01100001 (в дво­
ичной системе счисления) или B0 61 (в шестнадцате­
ричной) мы можем написать MOV AL, 61h. В данном
случае B0 — машинная инструкция (для процессора
1
Я взял данный пример из «Википедии» (https://en.wikipe­
dia.org/wiki/Machine_code), поскольку не писал на языке
ассемблера уже два десятилетия и не хочу заниматься этим
снова.

229
Глава 23. Программные абстракции
x86/IA-32), которая приказывает системе переместить
следующее значение в регистр AL. Запись MOV AL
означает то же самое, но является более простой для
восприятия. Ассемблер преобразует программу на
языке ассемблера в машинный код, который затем вы­
полняет процессор.

## Наконец, преобразует m в сообщение M, которое
### Низкоуровневые языки

программирования
Машинный код и язык ассемблера считаются языками
программирования низкого уровня, поскольку абстрак­
ция между написанной командой и фактически выпол­
няемым кодом практически отсутствует, а компилятор
или интерпретатор не требуется. Код, написанный на
низкоуровневом языке, может быть очень эффектив­
ным, но, как правило, непереносимым, поскольку при­
способлен для конкретного семейства процессоров.

## Наконец, преобразует m в сообщение M, которое
### Высокоуровневые языки

программирования
В отличие от низкоуровневых языков программиро­
вания высокоуровневые имеют более высокий уро­
вень абстракции, позволяющий компилировать или
интерпретировать код для обеспечения его работо­
способности на различных машинах. Эта абстракция
означает, что программист не может оптимизировать
код, исходя из свойств конкретного оборудования,
на котором он будет выполняться. В ситуации, ког­
да производительность имеет критическое значение,

230
Часть VIII. Аппаратное и программное обеспечение
а о целевом оборудовании известно все, программист
может написать самый важный фрагмент кода на язы­
ке ассемблера, а остальную часть программы — на
высокоуровневом языке. В других случаях програм­
мист, умеющий работать как с языком ассемблера, так
и с компилятором для высокоуровневого языка, может
написать высокоуровневый код таким образом, чтобы
скомпилированный код, генерируемый компилятором,
был достаточно эффективным.
Когда следует использовать язык ассемблера
Программисты, которые пишут код на языке ассемблера,
говорят, что у такого подхода есть три преимущества.
Первые два очевидны: код занимает меньше места и ра­
ботает быстрее. Третье не столь очевидно: если в коде
есть ошибка, то она, как правило, приводит к катастро­
фическому сбою. На первый взгляд это не кажется пре­
имуществом, однако сразу дает понять, что вы сделали
что-то не так.
В подавляющем большинстве случаев проще работать
на высокоуровневом языке. Язык ассемблера стоит ис­
пользовать при работе со встроенными системами с огра­
ниченной вычислительной мощностью, особенно когда
экономия места позволяет задействовать более дешевые
процессоры. В случае создания крупномасштабных при­
ложений экономия на процессорах может более чем
компенсировать дополнительное время разработчика.
Например, программы DSP (цифровой обработки сиг­
налов) часто пишутся на языке ассемблера.

24
Компьютерная
арифметика
Представьте приложение, которое должно очень быстро
выполнять миллионы вычислений.
Подойти к его разработке можно несколькими спосо­
бами. Один из них заключается в создании специали­
зированного оборудования, оптимизированного для
выполнения необходимых операций1. Другой — в осо­
бом структурировании вычислений, позволяющем вос­
пользоваться преимуществами тех операций, которые
компьютер выполняет очень быстро2.
1
Например, графические процессоры (ГП) способны выпол­
нять определенные типы вычислений во много раз быстрее,
чем ЦП общего назначения. По этой причине они оказывают­
ся полезными и для неграфических приложений, например
для добычи биткойна.
2
Рассмотрим задачу вычисления обратных квадратных кор­
ней, которые используются, например, при нормализации
векторов. Существует быстрый приближенный алгоритм вы­
числения обратного квадратного корня с помощью битового
сдвига, применявшегося в видеоиграх, таких как Quake. В то
время это было гораздо быстрее по сравнению с выполнением
точных расчетов. Для получения дополнительной информа­
ции введите запрос 0x5f3759df в строку поисковой системы.

232
Часть VIII. Аппаратное и программное обеспечение

## Наконец, преобразует m в сообщение M, которое
### Битовый сдвиг

Операции битового сдвига (<< и >> в языках семей­
ства C) сдвигают все биты в регистре на одну пози­
цию.
При сдвиге влево биты, освободившиеся справа от опе­
ранда, заполняются нулями. Сдвиг влево на n бит соот­
ветствует умножению числа на 2n.
Сдвиг вправо может быть арифметическим или логи­
ческим1. При арифметическом сдвиге вправо крайний
левый бит дублируется. В случае двоичного числа,
записанного в дополнительном коде2, сдвиг вправо
на n бит эквивалентен делению на 2n с округлением
в меньшую сторону (то есть в сторону отрицательной
бесконечности).
При логическом сдвиге вправо освободившиеся слева
разряды заполняются нулями (что вполне уместно
в случае беззнаковых двоичных чисел).
1
То же касается и сдвига влево, просто между арифметическим
и логическим сдвигом влево нет никакой разницы.
2
Обратный код двоичного числа (дополнение до единицы)
получается путем инверсии каждого бита, а дополнитель­
ный код (дополнение до двух) получается из обратного
кода числа путем добавления единицы. Как правило, для
представления знаковых чисел используется дополнитель­
ный код: положительное значение имеет знаковый бит,
равный нулю, и хранится в прямом коде, а отрицательное —
знаковый бит, равный единице, и хранится в дополнитель­
ном коде.

233
Глава 24. Компьютерная арифметика
Зачем использовать битовый сдвиг, если он логически
эквивалентен умножению или делению на два? Главная
причина — скорость. Раньше из-за дефицита простран­
ства или пропускной способности данные упаковыва­
лись максимально плотно и считывались полубайтами
путем битового сдвига.
Пример — C#
В C# битовые операции определены для типов int, uint,
long и ulong. Другие типы преобразуются в int (и битовая
операция возвращает значение типа int).
В случае любой переменной num подходящего типа
операция num << x приведет к сдвигу num влево на x
бит. Например, если num = 3 (0000 0011), то операция
num << 4 будет эквивалентна 3 × 24 = 48 (0011 0000).
Операция сдвига вправо выполняет арифметический
сдвиг, если операнд является знаковым, и логический,
если это не так.

## Наконец, преобразует m в сообщение M, которое
### Битовые И и ИЛИ

В то время как логические операторы И и ИЛИ (&&
и || в языке C) принимают два логических значения
(или значения, которые могут рассматриваться в ка­
честве таковых) и возвращают логическое значение,
битовые операторы И и ИЛИ (& и |) принимают и воз­
вращают биты. Битовое И возвращает 1, если оба вход­
ных бита равны 1, и 0, если это не так. А битовое ИЛИ
возвращает 0, если оба входных бита равны 0, в про­
тивном случае возвращается 1.

234
Часть VIII. Аппаратное и программное обеспечение
Пример — маскирование
Битовые операции часто используются в целях ма­
скирования. Предположим, у объекта есть несколько
логических свойств. Мы можем объединить их в одну
переменную, присвоив каждому степень двойки и при­
менив к ним оператор ИЛИ:
PropertyOne = 20 = 1 << 0 = 1
PropertyTwo = 21 = 1 << 1 = 2
PropertyThree = 22 = 1 << 2 = 4
PropertyFour = 23 = 1 << 3 = 8
Если объект обладает свойствами один, два и четыре,
то переменная-флаг будет иметь значение 0001 | 0010 |
1000 = 1011.
Позднее мы можем захотеть выяснить, обладает ли объ­
ект свойствами три и четыре.
PropertyThree: (0100 & 1011) = 0
PropertyFour: (1000 & 1011) = 1
В коде мы определили бы эти свойства как константы
и написали бы следующее1:
if ((PropertyThree & flagVar) !=0)
if ((PropertyFour & flagVar) !=0)
Если мы хотим проверить несколько свойств сразу, то
можем выполнить над ними операцию с помощью ИЛИ,
объединив их в новую переменную sumVar, а затем при­
менить к переменным sumVar и flagVar оператор И. Если
в результате будет возвращено значение sumVar, значит,
каждое из исходных логических значений истинно.
1
Да, в языке C выражение !=0 использовать не обя­за­тельно,
поскольку ноль интерпретируется как «ложь», а все осталь­
ное — как «истина», однако при обращении с числом как
с логическим значением может возникнуть ошибка.

235
Глава 24. Компьютерная арифметика

## Наконец, преобразует m в сообщение M, которое
### Битовое НЕ

Битовое НЕ (∼) инвертирует состояние каждого бита
исходного числа, то есть единицы становятся нулями,
а нули — единицами.
Пример — маскирование
Продолжим рассмотрение приведенного выше примера.
Теперь мы хотим установить для четвертого свойства
значение «ложь». Для этого мы применяем оператор НЕ
к PropertyFour и получаем ∼1000 = 0111. После этого
применяем к PropertyFour и flagVAR оператор И: 0111
& 1011 = 0011. Теперь у нас установлены только два
первых свойства.

## Наконец, преобразует m в сообщение M, которое
### Битовое исключающее ИЛИ

Логический оператор «исключающее ИЛИ» (XOR
или ˆ) возвращает значение «истина», если истинным
является лишь один из операндов; его битовая версия
возвращает 1, если только один из операндов равен 1.
Следствием этого является обратимость операции XOR,
то есть ее повторное применение возвращает исходное
значение. Например, мы хотим зашифровать откры­
тый текст 10100101 с помощью одноразового блокнота1
10110111.
z
z Чтобы зашифровать сообщение, мы выполняем над
текстом и блокнотом операцию XOR: 10100101 XOR
10110111 и получаем шифротекст 00010010.
1
Одноразовые блокноты обсуждались в разделе 19.3.

236
Часть VIII. Аппаратное и программное обеспечение
z
z Для расшифровки шифротекста мы выполняем над
ним и блокнотом операцию XOR: 00010010 XOR
10110111 и получаем исходное сообщение 10100101.
Вне сферы криптографии эта операция применяется
для решения задач в случае использования минималь­
ного объема памяти. Один из популярных примеров
таких задач — нахождение единственного неповторя­
ющегося элемента в списке повторяющихся элементов.
Для этого мы выполняем операцию XOR над всеми зна­
чениями в списке, в результате чего все значения, кроме
уникального, обнуляются1 (поскольку при одинаковых
значениях соответствующих битов исходных перемен­
ных операция XOR устанавливает значение бита ре­
зультата в 0). Еще один пример — обмен значений двух
переменных без использования временной переменной:
let x = x XOR y, y = y XOR x, а затем x = x XOR y2.
1
Разумеется, для того, чтобы это сработало, количество по­
вторяющихся значений должно быть четным.
2
Первая операция XOR дает нам содержимое одной пере­
менной — x или y. Вторая дает содержимое одной или трех
переменных — x, или y, или y, то есть x. Третья операция XOR
дает нам содержимое одной или трех переменных — x, или
y, или x, то есть y. Однако, как правило, для решения такой
задачи лучше использовать временную переменную.

25
Операционные
системы
Операционную систему можно рассматривать в каче­
стве еще одного уровня абстракции, отделяющего поль­
зователя (или программиста) от физической структуры
компьютера. Вместо того чтобы напрямую управлять
оборудованием, код приложения может просто обра­
титься к API ОС, чтобы задействовать те или иные си­
стемные функции.

## Наконец, преобразует m в сообщение M, которое
### Управление процессами

Как правило, пользователи предпочитают делать не­
сколько дел одновременно1. Подобно человеческому
мозгу, процессор компьютера не может решать боль­
ше одной задачи за раз2, но способен переключаться
между разными задачами, чтобы создать видимость
одновременного выполнения множества действий.
1
Этот факт требует проверки.
2
Современные процессоры, как правило, имеют несколько
ядер, каждое из которых является полноценным процессо­
ром, способным решать задачи независимо от остальных.

238
Часть VIII. Аппаратное и программное обеспечение
Это переключение позволяет нескольким задачам со­
вместно использовать системные ресурсы (в том числе
процессоры и память), но требует дополнительной
работы, связанной с переключением контекстов1 и обе­
спечением того, чтобы разные процессы (выполнение
задачи) не мешали друг другу.
25.1.1.  Многозадачность
Многозадачная система работает в режиме разделе­
ния времени, при котором процессорное время рас­
пределяется между потоками различных процессов.
Современные компьютеры обычно используют так
называемую вытесняющую многозадачность, при ко­
торой ядро прерывает выполняющийся процесс по
истечении некоего кванта времени или при получе­
нии сигнала от задачи с более высоким приоритетом.
Поскольку распределение времени контролирует опе­
рационная система, каждый процесс в конечном итоге
гарантированно получает квант времени ЦП. Тем не
менее любой процесс может когда угодно потерять
управление. Кроме того, может возникнуть ситуация
взаимной блокировки, при которой несколько про­
цессов находятся в состоянии ожидания ресурсов,
занятых остальными, и ни один не может продолжить
свое выполнение.
1
Контекст процесса — это его текущее состояние, включающее
содержимое всех регистров, которое потребуется после возоб­
новления его выполнения. Данная информация сохраняется
в блоке управления процессом (Process Control Block, PCB)
и используется для восстановления его состояния при пере­
запуске.

239
Глава 25. Операционные системы
Пример
Для иллюстрации данной проблемы часто исполь­
зуется задача об обедающих философах, в которой
пять безмолвных (то есть не разговаривающих друг
с другом) философов сидят за круглым столом. Перед
каждым из них стоит тарелка спагетти, и между каж­
дой парой сидящих рядом философов лежит по одной
вилке. Каждый из философов может либо есть, либо
размышлять, причем есть он может, лишь взяв две
вилки, лежащие с обеих сторон. Философ, у которого
есть только одна вилка, не ест, а ждет, пока ему не до­
станется вторая вилка; таким образом, если каждый
философ возьмет вилку слева от себя, все они будут
голодать, ожидая возвращения второй вилки.
При использовании другого типа многозадачности,
называемой совместной или кооперативной, каждый
процесс сам контролирует свое выполнение и добро­
вольно отдает процессорное время другим задачам
либо периодически, либо при логической блокировке
(например, при ожидании завершения ввода/выво­
да). Совместная многозадачность предполагает, что
все процессы регулярно передают управление другим,
и является непрактичной для большинства систем,
поскольку существует вероятность того, что один из
процессов не отдаст ресурсы, из-за чего остальные при­
ложения не смогут продолжить работу. Тем не менее
этот тип многозадачности часто применяется во встро­
енных системах1.
1
Подробнее о встроенных системах мы поговорим в главе 27.

240
Часть VIII. Аппаратное и программное обеспечение
25.1.2.  Многопроцессорность
и многопоточность
Если компьютер предусматривает несколько процес­
соров, то на нем могут одновременно выполняться не­
сколько процессов. Кроме того, один процесс может
состоять из нескольких потоков, выполняющихся на
разных процессорах.
Многопоточность позволяет ускорить отклик програм­
мы, оптимизировать использование системных ресур­
сов и обеспечить возможность распараллеливания. Тем
не менее процесс написания многопоточных прило­
жений может быть более сложным, поскольку требует
тщательной синхронизации потоков в целях предотвра­
щения состоя­ний гонки1.
25.1.3. Многопоточность и состояния
гонки
Состояния гонки возникают тогда, когда два или более
потока пытаются одновременно изменить общие дан­
ные. Результат этого изменения зависит от порядка,
в котором эти потоки обращаются к данным. Как пра­
вило, происходит нечто наподобие этого.

## Поток A встречает оператор if и проверяет его


усло­вие.
1
Я по собственному опыту знаю, как сложно бывает решить
проблему, связанную с состояниями гонки в многопоточных
программах.

241
Глава 25. Операционные системы

## Поток B выполняет код, который должен изменить


результат условного выражения.

## Поток A продолжает выполнение тела оператора if,


даже если это уже неактуально.
Для того чтобы предотвратить возникновение этого
гейзенбага1, необходимо выполнить одно из следующих
действий:
z
z заблокировать общие данные перед обращением
к ним любого из потоков и тем самым предотвра­
тить их изменение во время использования2;
z
z превратить всю единицу работы (условное выра­
жение и тело оператора if) в атомарную операцию,
то есть в операцию, которую нельзя прервать3.

## Поток A продолжает выполнение тела оператора if,
### Управление хранилищем

Ранее мы обсуждали4, как происходит выделение па­
мяти в стеке или в куче. Этим процессом управляет
операционная система, распределяя память между про­
цессами и решая, когда ее следует освободить.
1
Ошибка, которая исчезает или меняет свои свойства, когда
вы пытаетесь ее обнаружить.
2
В языке C# существует класс Interlocked, позволяющий вы­
полнять атомарные операции.
3
В языке Java существует ключевое слово synchronized, кото­
рое блокирует доступ к блоку кода, если тот уже использу­
ется другим потоком.
4
См. раздел 22.3.

242
Часть VIII. Аппаратное и программное обеспечение
25.2.1.  Логические
и физические адреса
Предположим, некоему вновь созданному процессу
разрешено использовать 4 Гбайт памяти. Если мы
­предоставим этому процессу прямой доступ к памяти,
то столкнемся с несколькими проблемами.
z
z Как мы можем гарантировать, что этот процесс
не обратится к памяти за пределами выделенного
блока?
z
z Если у нас нет непрерывного блока оперативной
памяти размером 4 Гбайт, то как мы можем его соз­
дать?
z
z Если процесс приостановлен, а выделенная для него
оперативная память используется другим процессом,
то нужно ли нам ждать освобождения этого конкрет­
ного блока памяти перед возобновлением данного
процесса?
Решение заключается в замене физической памяти
логической. Вместо того чтобы предоставлять каждо­
му процессу прямой доступ к диапазону физических
адресов, мы назначаем ему блок логических адресов,
которые ЦП может затем отобразить в физические.
Благодаря такому подходу процессу не требуется знать
о том, где в действительности хранятся используемые
им данные1. Их можно как угодно перемещать, не
опасаясь того, что процесс (намеренно или случайно)
1
Подробнее о динамическом распределении памяти вы можете
узнать в разделе 2.5 книги Дональда Кнута «Искусство про­
граммирования».

243
Глава 25. Операционные системы
получит доступ к памяти за пределами выделенного
ему блока.
Редко используемые данные можно переместить в об­
ласть подкачки, при этом процесс будет воспринимать
их так, будто они находятся в оперативной памяти.
Если нескольким процессам требуется копия одних
и тех же инструкций, то одна и та же физическая па­
мять может отображаться в несколько логических адре­
сов.
25.2.2.  Пейджинг и свопинг
Объем данных растет так, чтобы
заполнить все место на носителе.
Закон информации Паркинсона
Допустим, объем оперативной памяти системы не по­
зволяет одновременно хранить данные для всех за­
пущенных процессов, что тогда? Один из вариантов
решения этой задачи — свопинг: процесс загружается
в память целиком, выполняется до тех пор, пока управ­
ление не перейдет к другому процессу, а затем выгружа­
ется обратно на диск, чтобы освободить память для сле­
дующего процесса. В качестве альтернативы в память
могут загружаться только те части программы, которые
требуются в настоящий момент, а остальные при этом
остаются на диске до тех пор, пока в них не возникнет
необходимость.
Пейджинг, или подкачка страниц, предполагает раз­
биение виртуального адресного пространства на бло­

244
Часть VIII. Аппаратное и программное обеспечение
ки фиксированного размера, называемые страница­
ми, ­которые отображаются в страничные кадры или
­фреймы (того же размера) в памяти. Всякий раз, ко­
гда программа обращается к памяти, мы индексируем
таблицу страниц, чтобы выяснить местоположение
соответствующего страничного кадра. Если данная
страница в настоящее время не загружена, то возника­
ет ее отказ, после чего мы загружаем соответствующий
кадр (при необходимости заменяя другую страницу,
находящуюся в памяти в настоящее время).
Часто процесс работает с небольшим набором доступ­
ных ему страниц1. Если это рабочее множество нахо­
дится в памяти, то процесс может выполняться быстро,
несмотря на небольшое количество загруженных стра­
ниц. Если же в каждый момент времени загруженной
оказывается лишь часть рабочего множества, то резуль­
татом будут частые отказы страниц, поскольку процесс
будет постоянно сталкиваться с отсутствием в памяти
нужной ему страницы (такое состояние называется про­
буксовкой). Чтобы этого избежать, мы можем разрешить
запуск процесса только при загрузке в память всего
рабочего множества2.
Если памяти недостаточно для хранения рабочих мно­
жеств всех запущенных процессов, то некоторые про­
1
Речь идет о так называемой локальности ссылок, упомянутой
в разделе 2.2.
2
Чтобы не допустить отказов страниц, мы можем загрузить
все рабочее множество, прежде чем процессу будет позволено
возобновить работу. Этот подход называется опережающей
подкачкой страниц (prepaging).

245
Глава 25. Операционные системы
цессы должны быть выгружены во избежание пробук­
совки.
Практические соображения, связанные
с подкачкой страниц
Как можно освободить место для загрузки страницы,
когда его оказывается недостаточно? Идеальным реше­
нием была бы замена страницы, которая нам больше не
понадобится. Однако, поскольку задача определения
таких страниц, как правило, является трудновыпол­
нимой, вместо этого мы можем заменять страницы, не
использовавшиеся в последнее время.
На каждой странице установлены флаги, сообщающие
о факте ее чтения или изменения тем или иным процес­
сом, причем бит чтения периодически очищается. Когда
нам нужно освободить место, мы удаляем случайным
образом выбранную страницу, к которой уже какое-то
время не обращались, исходя из предположения о том,
что она не потребуется нам в ближайшем будущем1.
Если страница была изменена, то выгружаем эти из­
менения на диск.
1
На самом деле существует четыре категории страниц:
те,которые не считывались и не изменялись; изменялись,
ноне считывались; считывались, но не изменялись; и счи­
тывались, и изменялись. Существование страницы, которая
изменялась, но не считывалась, обусловлено тем, что бит чте­
ния периодически очищается, а бит изменения (сообщающий
о необходимости выгрузки страницы на диск) — нет. Когда
нам нужно удалить страницу, мы выбираем ее из нижнего
непустого класса, поэтому измененная страница, к которой
давно не обращались, будет удалена раньше, чем неизменен­
ная страница, к которой недавно был получен доступ.

246
Часть VIII. Аппаратное и программное обеспечение

## Поток A продолжает выполнение тела оператора if,
### Ввод/вывод

Одна из важных функций операционной системы —
унифицированное представление устройств ввода/
вывода. С точки зрения процесса не имеет значения,
откуда считываются данные (из памяти, с диска или
из сети) и куда выводятся (на экран, в файл или на
принтер). Операционная система предоставляет ин­
терфейс, позволяющий процессу считывать данные
из стандартного потока ввода и записывать их в стан­
дартный поток вывода.
С точки зрения операционной системы ввод и вывод
данных происходит чрезвычайно медленно по срав­
нению со скоростью работы процессора1. Для простой
системы, выполняющей одно действие за раз, может
быть достаточно того, чтобы процессор запросил вы­
полнение операции ввода/вывода, а затем находил­
ся в режиме активного ожидания2 до тех пор, пока
соответствующее устройство не закончит обработку
данных. В большинстве случаев предпочтительным
является переключение контекста и возобновление
прерванного процесса после завершения операции
ввода/вывода. Один из способов возврата к исходно­
1
Существуют исключения, например серверы Oracle Exadata,
однако мало кто из нас готов потратить на сервер сотни тысяч
долларов (или даже больше).
2
В режиме активного ожидания (busy waiting) ресурсы ЦП
бесполезно тратятся на многократную проверку некоего усло­
вия вплоть до его выполнения; это также называется враще­
нием процесса в пустом цикле (spinning).

247
Глава 25. Операционные системы
му состоянию заключается в том, чтобы разрешить
аппаратному обеспечению посылать процессору за­
просы на прерывание всякий раз, когда оно готово
к обработке очередного символа, однако на это тратит­
ся достаточно много времени. Более предпочтителен
вариант использования контроллера прямого доступа
к памяти (direct memory access, DMA). В таком случае
ЦП просто инициирует передачу данных, делегирует
ее контроллеру DMA и прерывается только после за­
вершения этого процесса.

## Поток A продолжает выполнение тела оператора if,
### Безопасность

В главе 18 мы обсудили три составляющие информа­
ционной безопасности: конфиденциальность, целост­
ность и доступность. Когда речь идет об операцион­
ных системах, мы можем ожидать от ОС гарантии
того, что без соответствующего разрешения к данным
пользователя или процесса не получит доступ другой
пользователь или процесс, что они не подвергнутся
несанкционированному изменению и будут доступны
по запросу.
В предыдущих разделах мы говорили о том, как сде­
лать так, чтобы процесс мог получить доступ толь­
ко к ячейкам памяти, выделенным для него опера­
ционной системой, и не мог монополизировать ЦП.
Обычно мы хотим, чтобы каждый процесс имел до­
ступ лишь к тем ресурсам, которые ему разрешено
использовать, причем исключительно допустимыми
способами.

248
Часть VIII. Аппаратное и программное обеспечение
Для этого требуется, чтобы процессы обращались
к ресурсам путем отправки запроса в операционную
систему, а не контролировали оборудование напря­
мую. ОС, в свою очередь, должна проверить уместность
полученного­ запроса. Для этого она может использо­
вать списки управления доступом (access control lists,
ACL), которые определяют, какие процессы могут за­
действовать ресурс и как именно, или перечни возмож­
ностей, определяющие права доступа, предоставленные
тому или иному процессу.
В целях предоставления гарантий того, что процес­
сы не смогут обойти меры контроля доступа, крайне
важно избежать повреждения самой операционной
системы. Надежные системы предполагают создание
доверенной вычислительной базы (trusted computing
base, TCB), состоящей из аппаратных и программных
компонентов, отвечающих за поддержание безопасно­
сти. Размер TCB должен быть минимальным, чтобы
можно было периодически проверять корректность
функционирования ее компонентов; все запросы на
получение доступа к системным ресурсам должны
проверяться монитором обращений, выполняющим
функцию барьера между доверенной и недоверенной
частями системы.
В более общем смысле в основе компьютерной без­
опасности лежит принцип наименьших привилегий,
согласно которому каждый субъект (будь то процесс,
пользователь или программа) должен иметь доступ
только к тем ресурсам, которые минимально необ­
ходимы для выполнения его цели. Благодаря этому

249
Глава 25. Операционные системы
ядро1 остается максимально компактным и изолиро­
ванным от остальных частей системы.
Программы выполняются как процессы на уровне
пользователя, которые не имеют разрешения на пря­
мой доступ к ресурсам. Когда процессу требуется
доступ, он выполняет системный вызов через преры­
вание, передающее управление ядру. После того как
права процесса на доступ к запрошенному ресурсу
будут проверены, ядро его предоставляет.
1
Ядро — это часть ОС, которая всегда находится в оперативной
памяти и имеет полный доступ ко всем системным ресурсам.

26
Распределенные
системы
Представьте процесс создания популярной поисковой
системы. По мере ее развития могут возникнуть про­
блемы, связанные с такими аспектами, как:
z
z масштабируемость — система должна обрабатывать
постоянно растущий объем данных;
z
z производительность — работа системы не должна
замедляться по мере увеличения нагрузки;
z
z доступность — система всегда должна быть доступна;
ее простои недопустимы.
Мы можем до определенной степени повысить произ­
водительность и масштабируемость, добавив дополни­
тельное оборудование, однако рано или поздно достиг­
нем пределов возможностей одной системы1. Решение
заключается в разделении работы между несколькими
недорогими компьютерами. Это обеспечивает масшта­
бируемость (по мере увеличения нагрузки можно доба­
вить больше серверов), производительность (на каждый
1
Возможности недорогого компьютера можно исчерпать очень
быстро.

251
Глава 26. Распределенные системы
сервер приходится ограниченная часть нагрузки) и до­
ступность (резервные серверы позволяют продолжить
работу в случае отказа одного из них). Даже небольшая
система может выиграть от разделения компонентов,
например, на веб-сервер, сервер базы данных и т. д.
Масштабирование Google
В 1998 году, когда компания Google начала свою дея­
тельность, у ее соучредителей было всего четыре ком­
пьютера и несколько сотен гигабайтов дискового про­
странства. Сейчас ее работу обеспечивают более двух
миллионов серверов в нескольких центрах обработки
данных по всему миру.

## Поток A продолжает выполнение тела оператора if,
### Ложные допущения

относительно распределенных
вычислений
Распределенные вычисления имеют свои сложности.
Л. Питер Дойч в соавторстве с другими специалистами1
составил список ложных допущений, которые часто
делают программисты, приступающие к работе над рас­
пределенными системами2.
1
Краткое изложение этой истории вы можете найти по адресу
https://web.archive.org/web/20070811082651/http://java.sys-
con.com/read/38665.htm.
2
Дополнительную информацию и примеры вы можете найти
в этой статье: https://arnon.me/wp-content/uploads/Files/
fallacies.pdf.

252
Часть VIII. Аппаратное и программное обеспечение

## Допущение: работа сети стабильна.


Реальность: сеть (или ее критически важные ком­
поненты) отключается в самое неподходящее время.

## Допущение: задержка равна нулю.


Реальность: пакеты задерживаются.
Исторический экскурс: латентность
В 1990-х годах сотрудники одного из факультетов
Университета Северной Каролины выяснили, что не
могут отправить электронную почту на расстояние
более 500 миль. Системный администратор решил,
что этого не может быть, но тестирование подтвердило
существование данной проблемы. В конце концов он
понял, что после обновления почтовый сервер перестал
понимать файл конфигурации и отключался по тайм-
ауту, спустя ровно столько времени, сколько было не­
обходимо для того, чтобы сообщение было получено
системой, находящейся на расстоянии 500 миль.

## Допущение: пропускная способность безгранична.


Реальность: в каналах передачи данных будут воз­
никать перегрузки.

## Допущение: сеть безопасна.


Реальность: хакеры попытаются украсть ваши данные.

## Допущение: топология не меняется.


Реальность: узлы сети будут добавляться и/или уда­
ляться.

## Допущение: есть только один администратор.


253
Глава 26. Распределенные системы
Реальность: разные администраторы внедряют раз­
ные политики.

## Допущение: затраты на перемещение данных равны


нулю.
Реальность: перемещение данных между узлами тре­
бует затрат.
Исторический экскурс: безопасность
В 2013 году после публикации документов Эдвардом
Сноуденом выяснилось, что Агентство национальной
безопасности США перехватывало информацию, пере­
даваемую между центрами обработки данных (ЦОД),
принадлежащими Google (и Yahoo!). Ответом компа­
нии Google стало шифрование каналов связи между
своими ЦОД.
В 2014 году несколько инженеров по безопасности
независимо друг от друга обнаружили ошибку (на­
званную Heartbleed) в криптографическом про­
граммном обеспечении OpenSSL, которая позво­
ляет злоумышленнику украсть информацию, как
правило защищаемую с помощью протоколов SSL/
TLS. Согласно отчету Shodan Heartbleed Report, по
состоянию на ноябрь 2019 года 91 063 общедоступ­
ных веб-сервера по-прежнему были уязвимы для
этой ошибки.

## Допущение: сеть однородна.


Реальность: разные части системы используют раз­
ное оборудование.
К уже перечисленным я могу добавить следующее.

254
Часть VIII. Аппаратное и программное обеспечение

## Допущение: мы можем восстановить порядок со­


бытий.
Реальность: серверы могут спорить относительно
того, что произошло раньше.
Все эти проблемы мы обсудим в следующих разделах.
Исторический экскурс: затраты
на перемещение данных
В 2013 году клиенты интернет-провайдеров Comcast
и Verizon столкнулись с ухудшением качества потоко­
вого видео, в результате чего многие из них отказались
от подписки на сервис Netflix. В начале 2014  года
компания Netflix заключила соглашения с обоими
провайдерами относительно прямого подключения
к их сетям.

## Допущение: мы можем восстановить порядок со­
### Коммуникация

Процессы, образующие распределенную систему, вза­
имодействуют путем передачи сообщений. Любые два
процесса могут быть запущены на одной машине или на
двух серверах, находящихся на расстоянии тысяч кило­
метров друг от друга. Разработчики системы должны
ответить на следующие вопросы.
z
z Следует ли нам требовать подтверждения получения
сообщений, и если да, то как долго мы должны его
ожидать?
z
z Хотим ли мы получать каждое сообщение «хотя бы
один раз» или «только один раз»?

255
Глава 26. Распределенные системы
z
z Что мы будем делать, если некоторые элементы си­
стемы станут недоступными?
z
z Как мы будем реагировать на добавление или удале­
ние серверов?
Проще говоря, распределенная система должна пред­
усматривать план действий на случай неспособности
обеспечения своевременной, надежной или безопасной
доставки сообщений, а также на случай принципиаль­
ной невозможности их доставки.

## Допущение: мы можем восстановить порядок со­
### Синхронизация

и согласованность
Рассмотрим, что происходит, когда данные копируют­
ся (реплицируются) на несколько географически уда­
ленных друг от друга серверов. Благодаря этому со­
кращается латентность (ближайший сервер в среднем
всегда будет находиться ближе, чем единственный
центральный сервер) и обеспечивается избыточность
(если один сервер выйдет из строя, то остальные по-
прежнему будут доступны). В связи с этим также воз­
никает вопрос поддержания синхронизации данных
между серверами.
Если изменения данных допускает лишь единствен­
ный сервер (а все остальные доступны только для
чтения), то он представляет собой слабое звено. Если
все серверы допускают как чтение, так и запись дан­
ных, то существует вероятность того, что несколько
серверов обновятся приблизительно в одно и то же

256
Часть VIII. Аппаратное и программное обеспечение
время, в результате чего будут содержать противоре­
чивую информацию. Даже если данные изменяются
только на одном сервере, другие серверы будут полу­
чать обновления в разное время, поэтому пользователь
может увидеть разные значения в зависимости от того,
к какому серверу обращается.
На случай получения серверами конфликтующих
данных при обновлении необходимо предусмотреть
политику, определяющую те данные, которые следу­
ет принять. Из-за отсутствия универсальных часов
определение последовательности обновлений может
оказаться невозможным, и различные серверы могут
получать их в разном порядке.
Почему не существует универсальных часов?
Работать с распределенными системами было бы на­
много проще, если бы мы точно знали время наступле­
ния того или иного события. Однако каждая система
предусматривает собственные часы, скорость работы
которых может слегка различаться. Мы можем синхро­
низировать все часы с одними доверенными часами,
но, поскольку время, необходимое для получения со­
общения от доверенных часов, может варьироваться,
наши распределенные системы по-прежнему не будут
идеально синхронизированы.

27
Встроенные
системы
Обычный человек (не программист) под словом «ком­
пьютер» подразумевает компьютер общего назначения,
то есть устройство, на котором можно запускать разные
программы. Однако компьютеры общего назначения
составляют лишь небольшую часть1 всех компьютеров.
Большинство составляют встроенные системы, специ­
ально созданные для выполнения конкретной задачи.
Эти крошечные компьютеры управляют всем, начиная
от вашей микроволновой печи и заканчивая зеркалами
заднего вида и фарами некоторых автомобилей2. Про­
граммирование встроенных систем позволяет сделать
так, чтобы ваше программное обеспечение напрямую
управляло оборудованием.
В отличие от разработки большинства приложений об­
щего назначения, при программировании встроенных
систем вы вынуждены иметь дело с более ограничен­
1
По некоторым оценкам, их процент приближается к нулю.
2
С примерами вы можете ознакомиться по адресу https://
patents.google.com/patent/US8625815B2/en и https://www.
cs.cmu.edu/smartheadlight/.

258
Часть VIII. Аппаратное и программное обеспечение
ным количеством ресурсов. Встроенная система, как
правило, отличается медленным процессором, ограни­
ченным количеством энергии, памяти и периферийных
устройств. Возможно, ей придется работать бесконечно
без какого-либо обслуживания (например, если система
встроена в космический спутник или спущена в Мари­
анскую впадину). Она должна уметь либо восстанав­
ливать работу после сбоев, либо полностью отказывать
при первом же возникновении ошибки. Она должна
выдавать либо детерминированную реакцию (то есть
всегда одинаково реагировать на те или иные входные
данные), либо реагировать в пределах некоего времен­
ного периода1. Проектирование встроенной системы
обычно предполагает нахождение компромисса между
различными ограничениями.
Одна из сложностей программирования встроенных
систем заключается в том, что их разработка, как пра­
вило, не может выполняться на том же оборудовании,
на котором им предстоит работать. Встроенная система
обычно не имеет дополнительных возможностей для
запуска отладчика и, вероятно, не может напрямую
управлять монитором или типичными устройствами
ввода, поэтому мы программируем их с помощью ком­
пьютера общего назначения.
Ограниченность ресурсов повышает полезность методов,
описанных в главе 24, позволяющих увеличить скорость
работы программы за счет некоторой потери в ясности.
1
Многие встроенные системы используют ОС реального
времени, которые должны обрабатывать данные в рамках
требуемых временных ограничений. Чтобы гарантировать
их производительность, при разработке приоритет отдается
скорости и предсказуемости.

259
Глава 27. Встроенные системы
Знакомство со встроенными системами
На протяжении длительного времени стандартом в об­
ласти разработки встроенных систем являлась физиче­
ская вычислительная платформа с открытым исходным
кодом Arduino1. Несмотря на то что эта платформа име­
ет низкую стоимость (плата начального уровня стоит
около 20 долларов США) и подходит для студентов
и любителей2, она представляет собой эффективный
инструмент для создания реальных продуктов3.
123
1
Плата Arduino Uno R3. Изображение предоставлено SparkFun
по лицензии Creative Commons.
2
Всевозможные примеры проектов, от игр до роботов, вы мо­
жете найти на сайте https://create.arduino.cc/projecthub.
3
О различных областях профессионального использования
платформы Arduino вы можете узнать на сайте https://www.
arduino.cc/pro/verticals.

28
Сети и Интернет
Многие из современных программ предназначены для
работы в компьютерной сети (как правило, в Интерне­
те). Вне зависимости от того, идет ли речь о модели SaaS
(software as a service — программное обеспечение как услу­
га), MMORPG-играх, сетевых принтерах или камерах ви­
деонаблюдения с функцией автоматического резервного
копирования, работа наших программ и устройств зависит
от их способности быстро, надежно и безопасно обмени­
ваться данными с другими устройствами, которые могут
находиться в том же помещении или в другой стране.
Существует две широко используемые модели описа­
ния процесса построения сетей, разделяющие функ­
циональность на различные уровни, которые можно
настроить независимо от других. Например, вашему
почтовому клиенту все равно, как электронное письмо
достигает места назначения. Маршрутизатору, пересы­
лающему пакеты данных, нет дела до их содержимого.
Кабель Ethernet предназначен только для передачи
битов из конца в конец. Каждый уровень имеет соб­
ственные протоколы, то есть правила, определяющие
порядок обработки данных на этом уровне.

261
Глава 28. Сети и Интернет
Модель TCP/IP состоит из четырех уровней, постро­
енных на базе протоколов TCP/IP, лежащих в основе
работы сети Интернет. Более универсальная теорети­
ческая модель OSI вместо стандартов предлагает семь
уровней протоколов и рекомендации (рис. 28.1).

## Допущение: мы можем восстановить порядок со­
### Уровни протоколов

28.1.1.  Прикладной уровень
Прикладной уровень, который является верхним в стеке
протоколов, обеспечивает межпроцессное взаимо­
действие, давая возможность приложениям обмени­
ваться данными по любой имеющейся сети. К этому
уровню принадлежат такие протоколы, как HTTP, FTP
и SMTP. Нижние уровни в основном рассматриваются
в качестве «черного ящика», обеспечивающего соедине­
ние, по которому прикладной уровень может передавать
данные.
Этот уровень модели TCP/IP разделен на три уровня
в модели OSI:
z
z уровень 7, или прикладной, — то, с чем непосред­
ственно взаимодействует пользователь (например,
браузер);
z
z уровень 6, или уровень представления, отвечает за
форматирование данных прикладного уровня, то есть
за их подготовку к передаче по сети (а также преобра­
зует полученные из сети данные в формат, понятный
приложениям). Например, на этом уровне данные
могут быть зашифрованы или расшифрованы;

262
Часть VIII. Аппаратное и программное обеспечение
Рис. 28.1. Сравнение моделей OSI и TCP/IP

263
Глава 28. Сети и Интернет
z
z уровень 5, или сеансовый, отвечает за поддержание
сеанса связи между двумя взаимодействующими
устройствами.
28.1.2.  Транспортный уровень
Транспортный уровень предоставляет механизм пере­
дачи сообщений, не зависящий ни от передаваемых дан­
ных, ни от логистических аспектов их перемещения по
сети. Этот уровень обеспечивает передачу данных либо
с установкой соединения (TCP), либо без него (UDP),
а также отвечает за качество обслуживания (то есть за
то, что происходит с потерянными или неправильно
обработанными пакетами данных).
28.1.3.  Межсетевой или сетевой уровень
Межсетевой (модель TCP/IP) или сетевой (модель OSI)
уровень отвечает за маршрутизацию пакетов данных от
одного устройства к другому. На этом уровне для пере­
дачи данных используется интернет-протокол (IPv4
или IPv6).
28.1.4.  Канальный уровень
На канальном уровне работают все хосты (устройства),
к которым можно получить доступ без прохождения че­
рез маршрутизатор. Этот уровень отвечает за перемеще­
ние пакетов между хостами, подключенными к одному
и тому же сетевому сегменту. В модели OSI он разделен
на два подуровня:

264
Часть VIII. Аппаратное и программное обеспечение
z
z уровень 2, или уровень канала передачи данных,
обеспечивает передачу данных между узлами и ис­
правляет ошибки, которые возникли на физиче­
ском уровне;
z
z уровень 1, или физический, имеет отношение к про­
водам, напряжению и параметрам радиосигналов,
обеспечивающих передачу данных.

## Допущение: мы можем восстановить порядок со­
### Протоколы TCP/IP и UDP

Как говорилось выше, транспортный уровень обеспе­
чивает передачу данных либо с установкой соединения,
либо без нее. При использовании ориентированного на
соединение протокола сеанс связи между двумя устрой­
ствами устанавливается до передачи данных. Для под­
держания этого сеанса задействованные устройства
должны хранить информацию о его состоянии, чтобы
соединение оставалось открытым. Задействуя прото­
кол без установки соединения, отправитель просто от­
правляет сообщение, как только оно будет готово, не
дожидаясь никаких подтверждений.
Протоколы, ориентированные на соединение, отлича­
ются надежностью и гарантируют доставку данных
(или по крайней мере сообщают отправителю, если
они не могут быть доставлены). Мы используем эти
протоколы, когда хотим быть уверенными в том, что
данные не потеряются и будут доставлены в правиль­
ном порядке.
Протоколы без установки соединения не гарантируют,
что данные не будут потеряны, искажены, продубли­
рованы или доставлены в неверном порядке (хотя не­

265
Глава 28. Сети и Интернет
которые протоколы более высокого уровня дают такие
гарантии). Благодаря своему минимальному функцио­
налу протоколы без установки соединения отличаются
низкими накладными расходами и используются в тех
случаях, когда пропускная способность оказывается
важнее надежности.
Протокол пользовательских датаграмм (User Datagram
Protocol, UDP) и межсетевой протокол (Internet Protocol,
IP) относятся к протоколам без установки соединения,
а протокол управления передачей (Transmission Control
Protocol, TCP) ориентирован на соединение. Мы, как
правило, говорим о TCP/IP1.

## Допущение: мы можем восстановить порядок со­
### Доставка сообщения

Как говорилось выше, на сетевом уровне происходит
маршрутизация пакетов от источника к месту назначе­
ния. Межсетевой протокол определяет способ доставки
пакетов адресату.
Допустим, некоторые данные должны быть отправлены
через Интернет с помощью TCP/IP. На каждом уровне
этого стека протоколов передаваемые данные называ­
ются блоком данных протокола, или БДП (Protocol Data
Unit, PDU), но форматируются по-разному.
С точки зрения приложения отправитель передает
данные, и они доставляются получателю. На текущем
1
Протоколы HTTP/1.1 и HTTP/2 работают поверх TCP;
HTTP/3 использует протокол QUIC, основанный на UDP, но
обеспечивает аналогичную TCP функциональность с умень­
шенной латентностью.

266
Часть VIII. Аппаратное и программное обеспечение
этапе БДП представляет собой полное сообщение (файл/
электронное письмо и т. д.), подлежащее передаче.
Транспортный уровень устанавливает логическое со­
единение между двумя процессами, выполняемыми на
разных хостах; притом фактическое местонахождение
этих хостов и физические характеристики канала свя­
зи между ними являются несущественными. На те­
кущем уровне сообщение разбивается на сегменты,
размер которых соответствует требованиям распо­
ложенного ниже сетевого уровня. Каждый сегмент
начинается с заголовка, содержащего различную ин­
формацию, в первую очередь номер порта, на который
должен быть доставлен данный сегмент.
В то время как транспортный уровень обеспечивает
логическое соединение между двумя процессами, сете­
вой обеспечивает логическое соединение между двумя
хостами (на каждом из которых может выполняться
множество процессов). На этом уровне сегмент транс­
портного уровня упаковывается в пакет, включающий
различные данные, необходимые для его доставки в ме­
сто назначения, в том числе IP-адреса отправляющего
и принимающего хостов. В то время как сегмент обра­
батывается только в пункте отправки и в пункте назна­
чения, пакет обрабатывается маршрутизаторами вдоль
всего пути следования.
Задача маршрутизатора состоит в обработке пакетов,
поступающих на его входящие интерфейсы, и в их пе­
ренаправлении на соответствующие исходящие ин­
терфейсы. Путь от источника до пункта назначения
вычисляется с помощью специальных алгоритмов

267
Глава 28. Сети и Интернет
маршрутизации. От используемой сетевой модели за­
висит, могут ли различные пакеты, составляющие со­
общение, быть переданы по одному и тому же маршру­
ту и будут ли доставлены в том же порядке, в котором
были отправлены.
Наконец, канальный уровень отвечает за перемещение
данных по одному каналу, то есть между двумя узла­
ми (где узлом может быть маршрутизатор или хост).
На этом уровне пакет инкапсулируется в кадр, который
физически передается от одного узла к другому.

## Допущение: мы можем восстановить порядок со­
### Алгоритмы маршрутизации

На сетевом уровне алгоритмы маршрутизации исполь­
зуются для определения наилучших путей от отправи­
теля до получателя. Наилучшим считается путь, име­
ющий наименьшую стоимость1, учитывая проблемы
политики (например, когда компания A отказывается
пересылать пакеты, поступающие от компании Б).
Сеть можно представить в виде взвешенного графа2,
вершинами которого являются точки переадресации па­
кетов к месту назначения, а веса ребер определяют сто­
имость использования соответствующего канала связи3.
1
См. раздел 6.5 «Кратчайшие пути».
2
Взвешенные графы были рассмотрены в разделе 4.8.
3
Под стоимостью здесь может подразумеваться множество
вещей, от количества времени, необходимого для передачи
данных по этому каналу связи, до стоимости его использо­
вания в денежном выражении.

268
Часть VIII. Аппаратное и программное обеспечение
Алгоритмы маршрутизации классифицируются по не­
скольким направлениям.
z
z Они могут быть централизованными, то есть обла­
дающими всей информацией о сети и вычисляющи­
ми полный путь, или децентрализованными, то есть
предполагающими то, что каждый узел знает только
о своих непосредственных соседях (соседних верши­
нах графа), но не обо всем пути, который предстоит
пройти.
z
z Они могут быть статическими, если маршруты
практически не меняются (и часто конфигуриру­
ются вручную), или динамическими, если маршруты
меняются в зависимости от изменения параметров
сетевого трафика и топологии сети1.
z
z Они могут быть адаптивными, если стоимость из­
меняется в зависимости от нагрузки на сеть, или
неадаптивными, если это не так2.
1
Динамические алгоритмы адаптируются к изменениям бы­
стрее, но могут проявлять склонность к образованию петель
маршрутизации.
2
Первые алгоритмы маршрутизации ARPAnet были адаптив­
ными, в отличие от таких современных алгоритмов, как BGP.

29
Базы данных
Рассмотрим такое типичное приложение для управле­
ния данными, как система инвентаризации. Обычно
оно должно предоставлять возможность создавать или
извлекать записи, изменять их, а затем снова сохра­
нять для последующего извлечения. Это классическое
CRUD-приложение (сокр. от англ. create, read, update,
delete — «создать, прочесть, обновить, удалить»). База
данных — способ организации структурированной ин­
формации (данных) с целью ее хранения и извлечения.

## Допущение: мы можем восстановить порядок со­
### Реляционные базы

данных (РБД)
Практически все современные базы данных являются
реляционными. РБД организована в виде набора та­
блиц, связи между которыми установлены с помощью
ключей.
Например, у компании может быть таблица «Клиен­
ты» (табл. 29.1), которая содержит информацию о каж­
дом клиенте, в том числе ID (идентификатор) или код.

270
Часть VIII. Аппаратное и программное обеспечение
Идентификатор представляет собой первичный ключ —
поле1, которое требуется для каждой записи и является
уникальным для нее.
Таблица 29.1. Таблица «Клиенты» в реляционной базе данных. Код
клиента — это первичный ключ
Имя клиента
Код клиента
Адрес
Капитан Крюк
1904
Веселый Роджер
Билли Кид
1859
Форт-Самнер, штат Нью-Мексико
Мордред
1136
Камелот
Вся информация о заказах клиентов находится в та­
блице «Заказы» (табл. 29.2). Вместо того чтобы вклю­
чать в нее информацию о клиенте (что привело бы
к дублированию большого количества данных, осо­
бенно если один клиент сделал много заказов), каждая
строка содержит код клиента, соответствующий коду
в таблице «Клиенты». Это так называемый внешний
ключ — идентификатор, который может использовать­
ся для многих записей в таблице «Заказы», но при этом
должен соответствовать только одной записи в таблице
«Клиенты».
Таблица 29.2. Таблица «Заказы» в реляционной базе данных. Код
заказа — это первичный ключ, а код клиента — внешний ключ
Код заказа
Код клиента
Стоимость
Товар
1
1904
$27
Крюк
2
1904
$4
Повязка на глаз
3
1136
$0
Меч (украден)
1
Или набор полей.

271
Глава 29. Базы данных
Правильно спроектированная реляционная база данных
обеспечивает точность, предотвращая дублирование ин­
формации, как видно в приведенном выше примере. Мы
сохраняем часть информации только в соответству­ющей
таблице и ссылаемся на нее по мере необходимости.
К наиболее распространенным системам управления
реляционными базами данных (СУРБД) относятся
Microsoft SQL Server, Oracle и MySQL. Как и большин­
ство других подобных систем, они используют SQL
(structured query language — язык структурированных
запросов), который является стандартным языком
для создания запросов к реляционным базам данных.
Язык SQL — декларативный: вы описываете, какой
результат хотите получить, а способ его достижения
находит компьютер.
Пример
Предположим, я хочу просмотреть все заказы, сделан­
ные в период с 15 марта по 1 апреля прошлого года.
Я запрашиваю эту информацию, а затем компьютер
определяет, как следует отсортировать данные в таблице
«Заказы», чтобы найти искомое.
Обычно СУРБД поддерживает как язык SQL (который
является стандартом ANSI), так и дополнительные про­
приетарные команды. Системы Microsoft (с T-SQL)
и Oracle (с PL/SQL) допускают использование проце­
дурного программирования и переменных в дополне­
ние к обычному декларативному программированию,
поддерживаемому в стандартном SQL.

272
Часть VIII. Аппаратное и программное обеспечение

## Допущение: мы можем восстановить порядок со­
### Иерархические базы

данных (ИБД)
ИБД организует данные в виде древовидной структу­
ры, а не таблиц. Такие базы используются в тех случаях,
когда приложению требуется быстро собрать всю ин­
формацию, имеющую отношение к конкретной записи,
а не подмножество доступных данных из множества
записей. Например, электронные медицинские карты
часто хранятся в ИБД, что обеспечивает быстрый до­
ступ к истории болезни пациента (рис. 29.1). Если нам
понадобится создать аналитический отчет (основанный
на данных о популяциях, а не об отдельных пациентах),
то мы можем извлечь нужную информацию в реляци­
онную базу данных.
Рис. 29.1. Пример записи в иерархической базе данных
пациентов

Часть IX
Углубленные темы

30
Основная теорема
о рекуррентных
соотношениях
В разделе 1.7 мы говорили об оценке времени выполне­
ния простых алгоритмов. Здесь мы поговорим об оценке
времени выполнения рекурсивных алгоритмов.
Рассмотрим алгоритм «разделяй и властвуй», разде­
ляющий исходную задачу на несколько независимых
подзадач, которые решаются рекурсивно, а решения
объединяются для получения решения исходной за­
дачи.
Время выполнения этого алгоритма можно описать
с помощью трех параметров:
z
z a — количество подзадач, на которые будет разделена
исходная задача;
z
z n / b — размер подзадач, где b — целое число больше
единицы. Предполагается, что размер каждой из под­
задач не будет превышать это значение;
z
z f(n) — функция, определяющая количество времени,
необходимое для разделения задачи на подзадачи
и объединения результатов их решения.

275
Глава 30. Основная теорема о рекуррентных соотношениях
Основная теорема (Master Theorem) применяется к ал­
горитмам, время выполнения которых может быть вы­
ражено следующим образом:
T(n) = aT(n / b) + f(n),
где T(n) — общее время выполнения (остальные пара­
метры описаны выше).
В зависимости от значения f(n) мы можем получить
оценку времени выполнения для трех случаев.
Математическое предупреждение
Выражение logba означает логарифм числа a по осно­
ванию b.
Если b = 2, то это двоичный логарифм, также сокращенно
обозначаемый lg. Например, log28 = 3.
Другими распространенными основаниями являют­
ся 10 (десятичный логарифм, log) и e (натуральный
логарифм, ln).

## Если f(n) асимптотически меньше1, чем nlogb a, то


время выполнения алгоритма равно Θ(nlogb a).

## Если f(n) = Θ(nlogb a), то общее время выполнения


равно Θ(nlogb a ⋅ log n).

## Если f(n) асимптотически больше, чем nlogb a, то есть


общее время решения всех подзадач меньше, чем
время, необходимое для объединения этих решений,
то время выполнения равно Θ(f(n)).
1
Математически это записывается в виде: f(n) = O(n
logb a–ε),
где ε (эпсилон) — произвольное сколь угодно малое значение.

276
Часть IX. Углубленные темы
Здесь мы видим, что общее время выполнения алго­
ритма определяется путем сравнения объема работы,
необходимой для разделения задачи и последующего
объединения результатов решения подзадач, с объемом
работы, необходимой для фактического решения каж­
дой подзадачи1.
Мы можем изобразить дерево рекурсии глубиной logb n,
содержащее ai узлов на уровне i. Тогда количество ли­
стьев составляет alogb n= nlogb a. Если сравнить количество
листьев с объемом работы, производимой на каждом
уровне, то большее из двух значений определит реше­
ние.
В первом случае объем работы, производимой на каж­
дом уровне, ограничен сверху значением nlogb a. Если
допустить, что значение f(n) ничтожно мало, то время
выполнения асимптотически равно количеству листьев:
nlogb a.
В третьем случае объем работы, производимой на каж­
дом уровне, ограничен снизу значением nlogb a, то есть
превосходит количество листьев, поэтому общее время
выполнения составляет Θ(f (n)).
Во втором случае количество листьев и значение f(n)
асимптотически равны, поэтому время выполнения
определяется объемом работы, производимой на каж­
дом уровне, умноженным на количество уровней в де­
реве, или Θ(nlogb a⋅ log n).
1
Более строгое доказательство этой теоремы вы можете найти
в разделе 4.6 книги Introduction to Algorithms (Cormen et al.)

277
Глава 30. Основная теорема о рекуррентных соотношениях
Пример: сортировка слиянием
Как говорилось в подразделе 8.3.2, сортировка слиянием
предполагает разделение массива на два массива меньше­
го размера и их рекурсивную сортировку.
При разделении или рекомбинации массивов мы не про­
изводим никакой специальной обработки, поэтому про­
цесс занимает O(n) времени. На каждом шаге мы делим
массив пополам, так что количество шагов составляет
O(lg n). Перемножив эти значения, мы получаем общее
время выполнения O(n lg n).
Если мы применим основную теорему, то f(n) = Θ(n). Это
второй случай из описанных выше (где и a, и b равны 2),
и потому время выполнения сортировки слиянием равно
Θ(n lg n).

31
Амортизированное
время выполнения
Допустим, у нас есть пустой массив размером n, и мы
хотим добавить в него значения. Каждая из первых
n вставок занимает O(1) времени. К моменту вставки
n + 1 массив будет заполнен, и его размер придется
изменить, что потребует копирования всех значений
в новый, более крупный массив и займет O(n) времени.
Операция вставки занимает время O(n) в тех случаях,
когда размер массива необходимо изменить; в осталь­
ных случаях время этой операции является постоян­
ным. Сколько времени в среднем занимает каждая опе­
рация вставки?
Если мы будем каждый раз увеличивать размер массива
на постоянную величину, то количество копируемых
элементов в какой-то момент начнет доминировать над
значением этой константы и операции вставки будут
в среднем занимать O(n) времени1.
1
Если мы каждый раз увеличиваем размер массива на c мест,
то общая стоимость добавления c новых элементов составля­
ет n + c. Таким образом, каждая вставка в среднем занимает
(n + c) / c времени, а поскольку n доминирует над c, то это
время равно O(n).

279
Глава 31. Амортизированное время выполнения
Однако если мы будем каждый раз удваивать размер
массива, то общее время, затрачиваемое на добавление
n элементов, будет равно n + n, а каждая вставка будет
в среднем занимать 2n / n = O(1) времени.
Здесь важно понять, что зачастую нас интересует не
время выполнения отдельной операции, а общее время,
затрачиваемое на серию операций. Когда каждая доро­
гостоящая операция сочетается с множеством дешевых,
ее стоимость можно амортизировать. Таким образом,
несмотря на то, что та или иная операция может занять
O(n) времени, ее амортизированная стоимость может
оказаться намного ниже. В описанном выше примере
с массивом, если мы просто посмотрим на наихудшее
время выполнения данной операции, мы придем к вы­
воду о том, что серия из n вставок займет O(n2) време­
ни, однако амортизационный анализ показывает, что
(при условии удвоения количества элементов при из­
менении размера массива) фактическое значение будет
равно O(n).

32
Расширяющееся
дерево
В разделе 5.1 мы говорили о двоичных деревьях поиска,
операции над которыми в общем случае занимают время
Θ(lg n) при условии, что высота дерева остается равной
O(lg n). Расширяющееся, или splay-дерево1, — это само­
регулирующееся двоичное дерево поиска, которое пере­
страивается так, что узлы, к которым недавно обраща­
лись, перемещаются ближе к корню, что в дальнейшем
обеспечивает более быстрый доступ при сохранении
средней высоты O(lg n). Таким образом, часто использу­
емые узлы оказываются более доступными, а доступ ко
всем узлам в среднем занимает время O(lg n).

## Если f(n) асимптотически больше, чем nlogb a, то есть
### Концепции

При каждом обращении к узлу x splay-дерева мы произ­
водим операцию расширения (серию вращений дерева),
1
Подробнее о splay-деревьях вы можете узнать в разделе 4.3
книги Роберта Тарьяна (Robert Tarjan) Data Structure and
Network Algorithms. Если вас интересует тема сбалансирован­
ных деревьев, то обратитесь к подразделу 6.2.3 книги Дональда
Кнута (Donald Knuth) «Искусство программирования».

281
Глава 32. Расширяющееся дерево
чтобы переместить этот узел в корень. Когда дерево
перестает быть сбалансированным, поиск узла, находя­
щегося ниже в иерархии, может занять O(n) времени,
однако при расширении происходит балансировка де­
рева. В результате выполнение всех основных операций
занимает амортизированное время O(lg n).
Отступление
Поворот изменяет структуру двоичного дерева, об­
новляя родительско-дочерние отношения узлов, но
не меняя порядок следования элементов. Если узел a
является левым дочерним элементом b и мы произ­
водим поворот дерева так, чтобы узел b стал правым
дочерним элементом a, то узел b по-прежнему боль­
ше узла  a. Поэтому выполнение центрированного
обхода дерева до и после поворота даст одинаковые
результаты.
Существует три возможные операции, каждая из ко­
торых выполняется в зависимости от следующих фак­
торов:
z
z узел x является левым или правым дочерним элемен­
том своего родителя p;
z
z узел p является корнем;
z
z узел p является правым или левым дочерним элемен­
том своего родителя g (прародителя x).
До тех пор пока узел x не станет корнем, мы используем
указанные выше факторы для выбора одного из трех
возможных вариантов поворота дерева.

282
Часть IX. Углубленные темы

## Если f(n) асимптотически больше, чем nlogb a, то есть
### Zig

Когда узел p является корнем, мы поворачиваем дерево
по ребру между x и p (рис. 32.1).

## Если f(n) асимптотически больше, чем nlogb a, то есть
### Zig-zig

Когда узел p не является корнем, а p и x оба являются
правыми или левыми потомками, мы поворачиваем
дерево по ребру между p и g, а затем по ребру между x
и p (рис. 32.2).

## Если f(n) асимптотически больше, чем nlogb a, то есть
### Zig-zag

Если не применим ни один из вышеперечисленных
случаев, то мы поворачиваем дерево по ребру между p
и x, а затем по ребру между x и g (рис. 32.3).
Рис. 32.1. После выполнения операции Zig узел x
становится корнем

283
Глава 32. Расширяющееся дерево
Рис. 32.2. После выполнения операции Zig-zig узел x
становится на место своего прародителя
Рис. 32.3. После выполнения операции Zig-zag узел x снова
становится на место своего прародителя

33
Декартово дерево
Декартово дерево (treap)1 — еще одна форма самоба­
лансирующегося двоичного дерева поиска, представля­
ющая собой комбинацию дерева и кучи. Все узлы имеют
ключи, для которых выполняется свойство двоичного
дерева. Кроме того, каждый узел имеет приоритет, для
которого выполняется свойство кучи.
Приоритет может присваиваться либо случайным об­
разом, и тогда декартово дерево будет иметь форму
случайного двоичного дерева (и с большой долей веро­
ятности будет иметь высоту O(log n)), либо в зависи­
мости от частоты обращений, и в этом случае часто ис­
пользуемые узлы будут располагаться ближе к корню.
Поиск в декартовом дереве происходит так же, как
и в любом другом двоичном дереве поиска, при этом
приоритеты игнорируются. Добавление нового узла
может потребовать вращения дерева для сохранения
свойства кучи (рис. 33.1). Чтобы удалить узел, нуж­
но сначала превратить его в лист, если он им еще не
1
Seidel R., Aragon C. R. Randomized searchtrees // Algorithmica.

## № 16.


285
Глава 33. Декартово дерево
является. Для этого ему присваивается приоритет –∞
(отрицательная бесконечность), а затем выполняются
необходимые вращения. Как только узел станет ли­
стом, его можно будет удалить.
Рис. 33.1. После вставки нового узла с ключом 1
и приоритетом 20 выполняются вращения дерева,
позволяющие новому узлу занять полагающееся ему место
Помимо обычных поиска/вставки/удаления, декар­
товы деревья поддерживают такие операции, как объ­
единение, пересечение и разность множеств1. Для их
выполнения нам понадобятся две вспомогательные
операции.
z
z Разделение. Эта операция разделяет декартово дере­
во на два дерева меньшего размера: одно с ключами
1
Описание этих операций приведено в разделе 2.6. Более
по­дробную информацию о выполнении операций над мно­
жествами и временных рамках можно найти в работе: Blel­
loch G. E., Reid-Miller M. Fast Set Operations Using Treaps // In
Proc. 10th Annual ACM SPAA, 1998.

286
Часть IX. Углубленные темы
меньше x, а другое с ключами больше x. Для этого
требуется вставить узел с ключом x и максимальным
приоритетом. После того как он окажется вверху
в результате вращений, просто удалите его, чтобы
получить два отдельных декартовых дерева из его
бывших потомков.
z
z Соединение. Чтобы соединить два упорядоченных
декартовых дерева (где все ключи одного дерева не
превосходят ключи другого), создайте новый узел,
который будет родителем корней этих деревьев. На­
значьте ему соответствующий ключ (который боль­
ше ключа его левого дочернего элемента, но меньше
ключа правого дочернего элемента) и минимальный
приоритет. Затем выполните вращение дерева, что­
бы этот узел стал листом, и удалите его, чтобы полу­
чить одно декартово дерево1.
В плане производительности декартовы деревья анало­
гичны расширяющимся деревьям.
1
Очевидно, что соединение и разделение являются обратны­
ми операциями.

34
Искусственный
интеллект
Словарь Merriam-Webster определяет интеллект как спо­
собность учиться, понимать, абстрактно мыслить и при­
менять знания для оказания воздействия на окружающую
среду. Искусственный интеллект — попытка придать эти
свойства машине (или по крайней мере имитировать их).
Здесь используется два подхода. Один из них предпо­
лагает имитацию мышления человека (или животного)
для того, чтобы заставить компьютер решать задачи так
же, как это делаем мы. Другой состоит в нахождении
способов, позволяющих компьютерам решать «интел­
лектуальные» задачи по крайней мере так же хорошо,
как люди, вне зависимости от того, как именно они
рассуждают при этом. Первый подход больше фокуси­
руется на понимании принципов работы интеллекта,
а второй — на решении задач, требующих его наличия.

## № 16.
### Типы искусственного

интеллекта
Итак, каким образом искусственный интеллект (ИИ)
решает задачи?

288
Часть IX. Углубленные темы
Символический ИИ предусматривает набор символов
и правил манипулирования ими, совокупность которых
представляет человеческие знания в декларативной
форме. Такой ИИ использует правила для манипули­
рования символами с целью достижения желаемого
результата. В 1959 году данный подход был использован
для создания универсального решателя задач (General
Problem Solver, GPS)1. Теоретически программа GPS
может решить любую достаточно формализованную
задачу. В данном случае задача представлена ориенти­
рованным графом, а компьютер должен найти способ
достижения одной из вершин, представляющих воз­
можный ответ. Например, программе для игры в шах­
маты требуется достичь конечного состояния, в котором
королю соперника объявлен мат; способы перемещения
между состояниями определяются правилами системы.
Универсальный решатель задач мог справляться с таки­
ми простыми головоломками, как «Ханойская башня»,
но решение реальных задач оказалось ему не под силу
из-за проблемы комбинаторного взрыва.
Когда непрактичность универсальных решателей задач
стала очевидной, исследователи переключились на раз­
работку специализированных экспертных систем, ра­
бота которых основана на базах знаний в определенной
области и правилах логического вывода, что позволяет
им частично заменить человека-эксперта при решении
1
Подробное описание принципа работы программы GPS мож­
но найти в отчете: Newell A., Shaw J. C. Simon H. A. Report on
a general problem-solving program // Proceedings of the Interna­
tional Conference on Information Processing, 1959. P. 256–264.

289
Глава 34. Искусственный интеллект
той или иной задачи. Подобные системы оказываются
особенно полезными в таких областях, как медицина1,
где для решения задачи можно задействовать огромный
объем существенной информации. Такая система может
делать выводы, которые в противном случае потребова­
ли бы участия человека-эксперта.
Отступление
Трудноразрешима такая задача, для решения которой
существует алгоритм, но он слишком неэффективен,
учитывая количество вариантов, которые необходимо
перебрать. Комбинаторный взрыв — термин, описыва­
ющий эффект резкого увеличения количества вариантов
по мере роста размерности задачи.
Рассмотрим игру в шахматы. У белых, как и у черных,
есть 20 возможных вариантов первого хода. Таким об­
разом, после того как каждый из игроков сделает первый
ход, количество допустимых состояний доски будет
равно 400, а после второго хода общее количество воз­
можных вариантов будет выражаться шестизначным
числом.
Субсимволический искусственный интеллект делает вы­
воды, используя уравнения, а не следуя конкретным
правилам. В то время как символический ИИ опира­
ется на правила, разработанные людьми (и, таким об­
разом, может продемонстрировать ход рассуждений,
позволяющих ему прий­ти к заключению), субсимво­
лический ИИ «учится» решать задачу, фактически не
1
В области медицины существует целый ряд экспертных си­
стем. Некоторые из них более эффективны, чем другие.

290
Часть IX. Углубленные темы
имея готовых правил нахождения ее решения. В основу
субсимволического ИИ положен принцип обработки
информации нейронами в человеческом мозге. Нейрон
получает входные сигналы от других связанных с ним
нейронов, и если взвешенная сумма1 входных сигналов
достигает порогового значения, данный нейрон пере­
дает сигнал дальше.
Субсимволический ИИ можно обучить, предварительно
инициализировав веса входов случайными значениями.
При получении неправильного ответа ИИ скорректиру­
ет значения весов, чтобы приблизиться к правильному
результату, соответствующему входным данным. После
проработки множества примеров эффективность ИИ
достигает такого уровня, когда ему удается хорошо ре­
шать задачу, обходясь без алгоритма и имея лишь набор
значений весов. В этом заключается суть машинного
обучения, при котором ИИ учится на собственном опы­
те, не будучи явно запрограммированным на решение
задачи, а люди просто поправляют машину, когда она
допускает ошибку.
Практический пример
В 2020 году исследователи из Калифорнийского универ­
ситета в Сан-Диего разработали алгоритм машинного
обучения для распознавания признаков COVID-19 на
рентгеновских снимках грудной клетки, которому уда­
лось выявить случаи этого заболевания, не замеченные
радиологами.
1
Взвешенная сумма означает, что входные сигналы имеют раз­
ную значимость, зависящую от силы связи между нейронами.

291
Глава 34. Искусственный интеллект

## № 16.
### Подобласти ИИ

Компьютеры способны сравнительно легко
достичь уровня взрослого человека в про­
хождении тестов на интеллект или в игре
в шашки, но когда речь идет о восприятии
или мобильности, они практически неспо­
собны достичь уровня годовалого ребенка.
Ханс Моравек, 1988 год
Парадокс Моравека заключается в том, что компьютеры
зачастую весьма эффективно решают задачи, с кото­
рыми плохо справляются взрослые люди, но оказыва­
ются беспомощными в том, что без труда дается даже
ребенку. Наиболее сложные области искусственного
интеллекта часто связаны с задачами, которые люди
решают совершенно бессознательно. К ним, например,
относится распознавание лиц, ловля мяча и понимание
речи. Многие из этих задач породили целые подобла­
сти ИИ, в их числе:
z
z компьютерное зрение — разработки в данной об­
ласти связаны с попытками научить компьютер
распознавать объекты в изображениях или видео
(рис. 34.1);
z
z обработка естественного языка — эта область по­
священа попыткам научить компьютер понимать
человеческий язык;
z
z нейронные сети и машинное обучение. Нейронная
сеть — это набор алгоритмов, используемых для рас­
познавания связей. Такие сети используются в ма­
шинном обучении;

292
Часть IX. Углубленные темы
Рис. 34.1. Робот, практикующий компьютерное зрение
z
z планирование — компьютер решает, какие действия
необходимо предпринять для достижения постав­
ленной цели;
z
z робототехника — обучение роботов навыкам ори­
ентирования в пространстве и реагирования на не­
ожиданные события в реальном мире;
z
z обработка речи — к этой области относится как рас­
познавание, так и синтез речи.

293
Глава 34. Искусственный интеллект

## № 16.
### Примеры

ИИ уже превратился в повседневное явление. Ниже
перечислены некоторые примеры, наверняка знакомые
многим читателям.
z
z Голосовые помощники, такие как Siri и Алиса, рас­
познают и обрабатывают речь.
z
z Спам-фильтры учатся распознавать спам и пропу­
скать обычные электронные письма, адаптируясь
к изменяющимся методам рассылки спама.
z
z Чтобы вы могли сканировать чек с помощью свое­
го телефона, он должен уметь распознавать буквы
и цифры в изображении.
z
z Беспилотные автомобили распознают препятствия
и избегают их в режиме реального времени. Ро­
бот-пылесос определяет оптимальный маршрут
для уборки комнаты и возвращения к зарядному
устройству.
z
z Компания Amazon составляет прогнозы относитель­
но того, какие товары могут нас заинтересовать, де­
монстрирует их нам и даже обеспечивает их достав­
ку на склад к тому времени, когда мы, по ее мнению,
можем решить их приобрести1.
1
В 2014 году компания Amazon получила патент на систему
упреждающей доставки, предполагающую отправку на мест­
ный склад тех товаров, которые вы, по ее мнению, скорее
всего, купите. То есть Amazon обеспечивает доставку товара
еще до совершения вами фактической покупки.

35
Квантовые
вычисления1
До сих пор мы в основном говорили о классических
компьютерах, хотя я и упомянул квантовую механику
в главе 19.
Терминология
Классический компьютер — это просто компьютер, кото­
рый не является квантовым. Его работа основана на прин­
ципах классической механики, в то время как квантовый
компьютер использует явления квантовой механики.
Квантовый компьютер использует квантовомехани­
ческие эффекты для вычисления вероятностей. При
этом он оперирует не битами, а кубитами (квантовыми
битами), способными находиться в двух состояниях
одновременно. Для данной задачи мы вычисляем веро­
ятность всех возможных ответов и выбираем тот, кото­
рый с наибольшей вероятностью является правильным.
1
Существенный вклад в эту главу внес научный редактор
данной книги, занимающийся исследованиями в области
квантовых вычислений.

295
Глава 35. Квантовые вычисления

## № 16.
### Физика

Квантовая физика изучает поведение материи на суб­
атомном уровне. Для понимания принципа квантовых
вычислений важно познакомиться со следующими кон­
цепциями.
z
z Суперпозиция — это способность квантовой системы
находиться в нескольких состояниях одновременно.
До проведения измерения кубит может находиться
в состоянии суперпозиции, то есть в состоянии 0 и 1
(с некоторой вероятностью каждого из них).
z
z Запутанность — когда две или больше частицы яв­
ляются запутанными, их квантовые состояния ока­
зываются взаимозависимыми. Измерение состояния
(спи́на, поляризации, положения, импульса) одной
частицы влияет на другие, даже если они находятся
на огромном расстоянии друг от друга1.
z
z Квантовое измерение — при измерении состоя­
ния квантовой системы оно коллапсирует в одно из
классических состояний. После этого каждый кубит
имеет значение либо 0, либо 1, а не находится в со­
стоянии суперпозиции.

## № 16.
### Теоретические соображения

Квантовые компьютеры в действительности предна­
значены для решения тех же задач, что и классические,
и вполне могут быть смоделированы машиной Тью­
ринга. Однако они позволяют справиться с задачами,
1
Эйнштейн называл это явление «жутким дальнодействием».

296
Часть IX. Углубленные темы
решать которые на классическом компьютере было бы
нецелесообразно из-за огромного количества вариан­
тов, требующих проверки при использовании наиболее
известных алгоритмов1.

## № 16.
### Практические соображения

До недавнего времени квантовые компьютеры исполь­
зовались только в лабораториях и содержали лишь
несколько кубитов, однако теперь они коммерчески
доступны2. На момент написания этой книги кванто­
вые компьютеры все еще в основном применялись для
исследований, а не для решения практических задач.
Однако технология быстро совершенствуется, и уже
разработано множество языков квантового програм­
мирования.
1
В 2019 году компания Google использовала 53-кубитный
квантовый компьютер для решения весьма специфической
задачи, на что у него ушло 200 секунд. Результат был прове­
рен суперкомпьютером Summit, находящимся в Окриджской
национальной лаборатории. Исследователи компании IBM
подсчитали, что в идеальных условиях и при наличии до­
полнительной памяти Summit смог бы решить эту задачу за
два с половиной дня.
2
Вы можете запускать квантовые схемы на квантовом ком­
пьютере IBM по адресу https://quantum-computing.ibm.com,
а также использовать квантовый компьютер D-Wave 2000Q,
доступный на платформе Leap: https://www.dwavesys.com/
take-leap.

Послесловие
Вы дошли до конца книги! (Если не считать прило­
жения.)
Сейчас вы, возможно, чувствуете некую незавершен­
ность — как будто вам нужно еще многое узнать. И вы
правы.
Эта книга неполна в двух смыслах. Во-первых, ни одна
из описанных тем не рассмотрена глубоко (если бы это
было так, книга была бы втрое толще). Тем не менее те­
перь у вас есть общее представление, которое позволит
вам осмысленно участвовать в обсуждении вопросов
и по мере необходимости искать дополнительную ин­
формацию.
Я надеюсь, что вы посетите мой сайт http://www.what­william­
said.com/books/. Там вы найдете тесты для самопроверки,
которые позволят вам узнать, хорошо ли вы усвоили
каждую главу. Вы можете подписаться на мои рассылки,
чтобы получить уведомление о выходе следующего из­
дания (а также бесплатные дополнительные материа­
лы), и связаться со мной, если у вас возникнут вопросы.
Если вы считаете эту книгу полезной, я буду очень
признателен, если вы потратите пару минут и оставите
отзыв о ней. Обратная связь с читателями очень важна
для авторов!

298
Послесловие
Меня спросили, планирую ли я написать продолжение,
и я ответил отрицательно. Я уже рассказал все, что хо­
тел. При этом я не исключаю, что в серии руководств
для программистов появятся мои новые книги. Как че­
ловек, испытывающий проблемы со слухом, я надеюсь
написать книгу, посвященную теме доступности. Как
старший разработчик, обладающий почти десятилет­
ним опытом работы над масштабными и сложными
программами, я хотел бы написать книгу для начина­
ющих программистов, посвященную профессиональ­
ной разработке программного обеспечения. Ну а там
будет видно.

Приложения

A
Необходимая
математика
Насколько глубокие познания в математике нужны для
изучения Computer Science?
Обычно для поступления на специальности, связанные
с Computer Science, нужно сдавать экзамен по алгебре;
это необходимо потому, что студенты, у которых воз­
никают сложности с пониманием переменных в алге­
бре, скорее всего, также с трудом поймут переменные
в программировании. Поскольку эта книга ориенти­
рована на программистов-практиков, предполагается,
что читатель знаком с концепцией и использованием
переменных.
При анализе времени выполнения алгоритма пона­
добятся алгебра и логарифмы. Логарифм числа — это
степень, в которую нужно возвести основание логариф­
ма (обычно для компьютеров это 2), чтобы получить
данное число; например, логарифм 16 по основанию 2
равен 4, потому что 24 = 16.
Более сложные темы могут также потребовать углу­
бленного знания математики. В компьютерной графике

301
Приложение А. Необходимая математика
используются мнимые числа, а в машинном обучении —
численные методы и статистика. Эти темы выходят за
рамки данной книги.
Если вы не работаете в специализированной области, то
вам, скорее всего, будет достаточно алгебры, логариф­
мов и теории графов (которые подробно рассмотрены
в части II).

Б
Классические
NP-полные задачи
В этом приложении представлен краткий обзор неко­
торых классических NP-полных задач. Здесь не при­
водятся доказательства NP-полноты, а только дана
информация, чтобы вы сами могли распознать эти за­
дачи, когда встретитесь с ними. Обратите внимание,
что задачи описаны так, что интересен не размер наи­
лучшего решения, а то, существует ли решение разме­
ром s. Это связано с тем, что по определению NP-полные
задачи — это задачи принятия решений (ответом на
которые является «да» или «нет»).
Б.1.  SAT и 3-SAT
Задача выполнимости булевых формул, ВЫП (boolean
satisfiability problem, SAT), отвечает на вопрос: мож­
но ли для заданной формулы, состоящей из логиче­
ских переменных, подобрать такие значения этих пе­
ременных, чтобы результат формулы был истинным?
Например, формула «b и не c» принимает значение
«истина», если b истинно, а c — ложно. А вот утвер­

303
Приложение Б. Классические NP-полные задачи
ждение «b и не b» не станет истинным ни при каких
значениях b.
Как правило, формула представлена в виде набора
условий. Например, если задана формула, значение
которой истинно, если истинно любое из приведен­
ных выше утверждений, то ее можно записать как
(b ∧ ¬c) ∨ (b ∧ ¬b) (это читается так: «b и не c или
b и не b»). В данном случае каждое из утверждений со­
держит два литерала, но вообще оно может содержать
любое число литералов. 3-SAT — это та же задача с до­
полнительным ограничением: каждое условие ограни­
чено максимум тремя литералами.
Б.2.  Клика
Для заданного графа G и размера k определите, со­держит
ли G клику (то есть полный подграф) размером k.
Б.3.  Кликовое покрытие
Для заданного графа G и размера k определите, мож­
но ли разбить G на k клик таким образом, чтобы каждая
вершина графа принадлежала хотя бы одной из полу­
ченных клик.
Б.4.  Раскраска графа
Для заданного графа G и размера k определите, можно
ли правильно раскрасить G, используя только k цветов.

304
Приложения
Б.5.  Гамильтонов путь
Для заданного графа G определите, существует ли путь
между вершинами графа, который проходит через каж­
дую вершину ровно один раз.
Б.6.  Укладка рюкзака
Для заданного набора предметов, каждый из которых
имеет вес и ценность, и рюкзака с максимальной вме­
стимостью c определите, можно ли найти набор пред­
метов с общей ценностью не менее v, которые не пре­
вышают вместимость рюкзака.
Б.7.  Наибольшее независимое
множество
Для заданного графа G определите, существует ли неза­
висимое множество (множество вершин, в котором нет
двух смежных вершин) размером k.
Б.8.  Сумма подмножества
Для заданного множества или мультимножества (мно­
жества, в котором допускаются повторяющиеся значе­
ния) целых чисел и значения s определите, существу­
ет ли непустое подмножество, сумма которого равна s?
Например, для множества {–7, –5, –3, –1, 4, 8, 156}
и s = 0 таким подмножеством было бы {–7, –5, 4, 8}.

